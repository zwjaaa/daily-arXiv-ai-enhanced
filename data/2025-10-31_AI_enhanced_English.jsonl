{"id": "2510.25882", "categories": ["cs.SE", "D.2.9"], "pdf": "https://arxiv.org/pdf/2510.25882", "abs": "https://arxiv.org/abs/2510.25882", "authors": ["Wenhao Yang", "Minghui Zhou", "Daniel Izquierdo Cort\u00e1zar", "Yehui Wang"], "title": "Internal Vulnerabilities, External Threats: A Grounded Framework for Enterprise Open Source Risk Governance", "comment": null, "summary": "Enterprise engagement with open source has evolved from tactical adoption to\nstrategic deep integration, exposing them to a complex risk landscape far\nbeyond mere code. However, traditional risk management, narrowly focused on\ntechnical tools, is structurally inadequate for systemic threats like upstream\n\"silent fixes\", community conflicts, or sudden license changes, creating a\ndangerous governance blind spot. To address this governance vacuum and enable\nthe necessary shift from tactical risk management to holistic risk governance,\nwe conducted a grounded theory study with 15 practitioners to develop a\nholistic risk governance framework. Our study formalizes an analytical\nframework built on a foundational risk principle: an uncontrollable External\nThreat (e.g., a sudden license change in a key dependency) only becomes a\ncritical risk when it exploits a controllable Internal Vulnerability (e.g., an\nundefined risk appetite for single-vendor projects), which then amplifies the\nimpact.The framework operationalizes this principle through a clear logical\nchain: \"Objectives -> Threats -> Vulnerabilities -> Mitigation\" (OTVM). This\nprovides a holistic decision model that transcends mere technical checklists.\nBased on this logic, our contributions are: (1) a \"Strategic Objectives Matrix\"\nto clarify goals; (2) a systematic dual taxonomy of External Threats (Ex-Tech,\nEx-Comm, Ex-Eco) and Internal Vulnerabilities (In-Strat, In-Ops, In-Tech); and\n(3) an actionable mitigation framework mapping capability-building to these\nvulnerabilities. The framework's analytical utility was validated by three\nindustry experts through retrospective case studies on real-world incidents.\nThis work provides a novel diagnostic lens and a systematic path for\nenterprises to shift from reactive \"firefighting\" to proactively building an\norganizational \"immune system\".", "AI": {"tldr": "A holistic risk governance framework for enterprise open source engagement that shifts from tactical risk management to systemic governance by analyzing the relationship between external threats and internal vulnerabilities.", "motivation": "Traditional risk management focused on technical tools is inadequate for systemic open source risks like license changes, community conflicts, and silent fixes, creating governance blind spots in enterprise open source adoption.", "method": "Grounded theory study with 15 practitioners to develop a holistic risk governance framework based on the OTVM (Objectives -> Threats -> Vulnerabilities -> Mitigation) logical chain and dual taxonomy of external threats and internal vulnerabilities.", "result": "Developed a validated framework including Strategic Objectives Matrix, systematic taxonomies of External Threats (Ex-Tech, Ex-Comm, Ex-Eco) and Internal Vulnerabilities (In-Strat, In-Ops, In-Tech), and actionable mitigation mapping. Validated through retrospective case studies with industry experts.", "conclusion": "The framework provides enterprises with a systematic approach to shift from reactive firefighting to proactively building organizational resilience against open source risks, addressing the governance vacuum in current practices."}}
{"id": "2510.25890", "categories": ["cs.SE", "cs.AI", "D.2.4; I.2.2"], "pdf": "https://arxiv.org/pdf/2510.25890", "abs": "https://arxiv.org/abs/2510.25890", "authors": ["Tong Ma", "Hui Lai", "Hui Wang", "Zhenhu Tian", "Jizhou Wang", "Haichao Wu", "Yongfan Gao", "Chaochao Li", "Fengjie Xu", "Ling Fang"], "title": "PRISM: Proof-Carrying Artifact Generation through LLM x MDE Synergy and Stratified Constraints", "comment": "45 pages, 9 figures", "summary": "PRISM unifies Large Language Models with Model-Driven Engineering to generate\nregulator-ready artifacts and machine-checkable evidence for safety- and\ncompliance-critical domains. PRISM integrates three pillars: a Unified\nMeta-Model (UMM) reconciles heterogeneous schemas and regulatory text into a\nsingle semantic space; an Integrated Constraint Model (ICM) compiles structural\nand semantic requirements into enforcement artifacts including generation-time\nautomata (GBNF, DFA) and post-generation validators (e.g., SHACL, SMT); and\nConstraint-Guided Verifiable Generation (CVG) applies these through two-layer\nenforcement - structural constraints drive prefix-safe decoding while\nsemantic/logical validation produces machine-checkable certificates. When\nviolations occur, PRISM performs audit-guided repair and records generation\ntraces for compliance review. We evaluate PRISM in automotive software\nengineering (AUTOSAR) and cross-border legal jurisdiction (Brussels I bis).\nPRISM produces structurally valid, auditable artifacts that integrate with\nexisting tooling and substantially reduce manual remediation effort, providing\na practical path toward automated artifact generation with built-in assurance.", "AI": {"tldr": "PRISM unifies LLMs with Model-Driven Engineering to generate regulator-ready artifacts and machine-checkable evidence for safety-critical domains through constraint-guided generation and validation.", "motivation": "To address the challenge of generating compliant artifacts for safety- and compliance-critical domains by combining LLMs with formal methods to ensure regulatory compliance and reduce manual effort.", "method": "Three pillars: Unified Meta-Model (UMM) for semantic integration, Integrated Constraint Model (ICM) for requirement compilation, and Constraint-Guided Verifiable Generation (CVG) with two-layer enforcement and audit-guided repair.", "result": "PRISM produces structurally valid, auditable artifacts that integrate with existing tooling (AUTOSAR, Brussels I bis) and substantially reduce manual remediation effort.", "conclusion": "PRISM provides a practical path toward automated artifact generation with built-in assurance for safety-critical domains through its unified approach."}}
{"id": "2510.25935", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.25935", "abs": "https://arxiv.org/abs/2510.25935", "authors": ["Ant\u00eda Dorado", "Iv\u00e1n Folgueira", "Sof\u00eda Mart\u00edn", "Gonzalo Mart\u00edn", "\u00c1lvaro Porto", "Alejandro Ramos", "John Wallace"], "title": "A Process Mining-Based System For The Analysis and Prediction of Software Development Workflows", "comment": "16 pages, 7 figures, 4 tables", "summary": "CodeSight is an end-to-end system designed to anticipate deadline compliance\nin software development workflows. It captures development and deployment data\ndirectly from GitHub, transforming it into process mining logs for detailed\nanalysis. From these logs, the system generates metrics and dashboards that\nprovide actionable insights into PR activity patterns and workflow efficiency.\nBuilding on this structured representation, CodeSight employs an LSTM model\nthat predicts remaining PR resolution times based on sequential activity traces\nand static features, enabling early identification of potential deadline\nbreaches. In tests, the system demonstrates high precision and F1 scores in\npredicting deadline compliance, illustrating the value of integrating process\nmining with machine learning for proactive software project management.", "AI": {"tldr": "CodeSight is an end-to-end system that predicts deadline compliance in software development by analyzing GitHub data using process mining and LSTM models.", "motivation": "To proactively identify potential deadline breaches in software development workflows and provide actionable insights for project management.", "method": "Captures GitHub development/deployment data, transforms into process mining logs, generates metrics/dashboards, and uses LSTM model with sequential activity traces and static features to predict PR resolution times.", "result": "Demonstrates high precision and F1 scores in predicting deadline compliance during testing.", "conclusion": "Integrating process mining with machine learning provides valuable proactive capabilities for software project management."}}
{"id": "2510.26130", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.26130", "abs": "https://arxiv.org/abs/2510.26130", "authors": ["Musfiqur Rahman", "SayedHassan Khatoonabadi", "Emad Shihab"], "title": "Beyond Synthetic Benchmarks: Evaluating LLM Performance on Real-World Class-Level Code Generation", "comment": "Pre-print prepared for journal submission", "summary": "Large language models (LLMs) have advanced code generation at the function\nlevel, yet their ability to produce correct class-level implementations in\nauthentic software projects remains poorly understood. This work introduces a\nnovel benchmark derived from open-source repositories, comprising real-world\nclasses divided into seen and unseen partitions to evaluate generalization\nunder practical conditions. The evaluation examines multiple LLMs under varied\ninput specifications, retrieval-augmented configurations, and documentation\ncompleteness levels.\n  Results reveal a stark performance disparity: LLMs achieve 84% to 89%\ncorrectness on established synthetic benchmarks but only 25% to 34% on\nreal-world class tasks, with negligible differences between familiar and novel\ncodebases. Comprehensive docstrings yield modest gains of 1% to 3% in\nfunctional accuracy, though statistical significance is rare.\nRetrieval-augmented generation proves most effective with partial\ndocumentation, improving correctness by 4% to 7% by supplying concrete\nimplementation patterns absent from specifications. Error profiling identifies\nAttributeError, TypeError, and AssertionError as dominant failure modes (84% of\ncases), with synthetic tests overemphasizing assertion issues and real-world\nscenarios highlighting type and attribute mismatches. Retrieval augmentation\nreduces logical flaws but can introduce dependency conflicts.\n  The benchmark and analysis expose critical limitations in current LLM\ncapabilities for class-level engineering, offering actionable insights for\nenhancing context modelling, documentation strategies, and retrieval\nintegration in production code assistance tools.", "AI": {"tldr": "LLMs perform well on synthetic benchmarks (84-89% correctness) but poorly on real-world class implementations (25-34% correctness), with retrieval-augmented generation providing modest improvements (4-7%) and comprehensive documentation having minimal impact (1-3% gains).", "motivation": "To understand LLMs' ability to produce correct class-level implementations in real software projects, as current knowledge is limited despite their success at function-level code generation.", "method": "Created a benchmark from open-source repositories with real-world classes divided into seen/unseen partitions, evaluated multiple LLMs under varied input specifications, retrieval-augmented configurations, and documentation completeness levels.", "result": "Major performance gap: 84-89% correctness on synthetic benchmarks vs 25-34% on real-world classes. Retrieval-augmented generation improved correctness by 4-7%, while comprehensive docstrings provided only 1-3% gains. AttributeError, TypeError, and AssertionError accounted for 84% of failures.", "conclusion": "Current LLMs have critical limitations for class-level engineering, highlighting needs for improved context modeling, documentation strategies, and retrieval integration in production code assistance tools."}}
{"id": "2510.26171", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26171", "abs": "https://arxiv.org/abs/2510.26171", "authors": ["Hasnain Iqbal", "Zerina Begum", "Kazi Sakib"], "title": "Reduction of Test Re-runs by Prioritizing Potential Order Dependent Flaky Tests", "comment": null, "summary": "Flaky tests can make automated software testing unreliable due to their\nunpredictable behavior. These tests can pass or fail on the same code base on\nmultiple runs. However, flaky tests often do not refer to any fault, even\nthough they can cause the continuous integration (CI) pipeline to fail. A\ncommon type of flaky test is the order-dependent (OD) test. The outcome of an\nOD test depends on the order in which it is run with respect to other test\ncases. Several studies have explored the detection and repair of OD tests.\nHowever, their methods require re-runs of tests multiple times, that are not\nrelated to the order dependence. Hence, prioritizing potential OD tests is\nnecessary to reduce the re-runs. In this paper, we propose a method to\nprioritize potential order-dependent tests. By analyzing shared static fields\nin test classes, we identify tests that are more likely to be order-dependent.\nIn our experiment on 27 project modules, our method successfully prioritized\nall OD tests in 23 cases, reducing test executions by an average of 65.92% and\nunnecessary re-runs by 72.19%. These results demonstrate that our approach\nsignificantly improves the efficiency of OD test detection by lowering\nexecution costs.", "AI": {"tldr": "Proposes a method to prioritize order-dependent (OD) tests by analyzing shared static fields in test classes, reducing test executions by 65.92% and unnecessary re-runs by 72.19%.", "motivation": "Flaky tests, particularly order-dependent tests, make automated testing unreliable and cause CI pipeline failures. Existing detection methods require multiple test re-runs that are inefficient, creating need for prioritization to reduce execution costs.", "method": "Analyze shared static fields in test classes to identify tests more likely to be order-dependent, enabling prioritization of potential OD tests before running detection algorithms.", "result": "In experiments on 27 project modules, the method successfully prioritized all OD tests in 23 cases, achieving average reductions of 65.92% in test executions and 72.19% in unnecessary re-runs.", "conclusion": "The approach significantly improves OD test detection efficiency by lowering execution costs through effective prioritization based on static field analysis."}}
{"id": "2510.26174", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26174", "abs": "https://arxiv.org/abs/2510.26174", "authors": ["Liming Dong", "Sung Une Lee", "Zhenchang Xing", "Muhammad Ejaz Ahmed", "Stefan Avgoustakis"], "title": "The \"4W+1H\" of Software Supply Chain Security Checklist for Critical Infrastructure", "comment": "18 pages, 4 figures", "summary": "The increasing frequency and sophistication of software supply chain attacks\npose severe risks to critical infrastructure sectors, threatening national\nsecurity, economic stability, and public safety. Despite growing awareness,\nexisting security practices remain fragmented and insufficient, with most\nframeworks narrowly focused on isolated life cycle stages or lacking alignment\nwith the specific needs of critical infrastructure (CI) sectors. In this paper,\nwe conducted a multivocal literature review across international frameworks,\nAustralian regulatory sources, and academic studies to identify and analyze\nsecurity practices across the software supply chain, especially specific CI\nsector. Our analysis found that few existing frameworks are explicitly tailored\nto CI domains. We systematically leveraged identified software supply chain\nsecurity frameworks, using a \"4W+1H\" analytical approach, we synthesized ten\ncore categories (what) of software supply chain security practices, mapped them\nacross life-cycle phases (when), stakeholder roles (who), and implementation\nlevels (how), and examined their coverage across existing frameworks (where).\nBuilding on these insights, the paper culminates in structured, multi-layered\nchecklist of 80 questions designed to relevant stakeholders evaluate and\nenhance their software supply chain security. Our findings reveal gaps between\nframework guidance and sector-specific needs, highlight the need for\nintegrated, context-aware approaches to safeguard critical infrastructure from\nevolving software supply chain risks.", "AI": {"tldr": "This paper analyzes software supply chain security frameworks for critical infrastructure sectors, identifies gaps in existing approaches, and develops a comprehensive 80-question checklist to help stakeholders evaluate and improve their security practices.", "motivation": "The increasing frequency and sophistication of software supply chain attacks pose severe risks to critical infrastructure sectors, threatening national security, economic stability, and public safety. Existing security practices are fragmented and insufficient, with most frameworks not tailored to critical infrastructure needs.", "method": "Conducted a multivocal literature review across international frameworks, Australian regulatory sources, and academic studies. Used a \"4W+1H\" analytical approach to synthesize security practices across categories (what), life-cycle phases (when), stakeholder roles (who), implementation levels (how), and framework coverage (where).", "result": "Found that few existing frameworks are explicitly tailored to critical infrastructure domains. Developed a structured, multi-layered checklist of 80 questions to help stakeholders evaluate and enhance software supply chain security.", "conclusion": "There are significant gaps between framework guidance and sector-specific needs, highlighting the need for integrated, context-aware approaches to safeguard critical infrastructure from evolving software supply chain risks."}}
{"id": "2510.26275", "categories": ["cs.SE", "cs.AI", "cs.ET", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2510.26275", "abs": "https://arxiv.org/abs/2510.26275", "authors": ["Domenico Amalfitano", "Andreas Metzger", "Marco Autili", "Tommaso Fulcini", "Tobias Hey", "Jan Keim", "Patrizio Pelliccione", "Vincenzo Scotti", "Anne Koziolek", "Raffaela Mirandola", "Andreas Vogelsang"], "title": "A Research Roadmap for Augmenting Software Engineering Processes and Software Products with Generative AI", "comment": null, "summary": "Generative AI (GenAI) is rapidly transforming software engineering (SE)\npractices, influencing how SE processes are executed, as well as how software\nsystems are developed, operated, and evolved. This paper applies design science\nresearch to build a roadmap for GenAI-augmented SE. The process consists of\nthree cycles that incrementally integrate multiple sources of evidence,\nincluding collaborative discussions from the FSE 2025 \"Software Engineering\n2030\" workshop, rapid literature reviews, and external feedback sessions\ninvolving peers. McLuhan's tetrads were used as a conceptual instrument to\nsystematically capture the transforming effects of GenAI on SE processes and\nsoftware products.The resulting roadmap identifies four fundamental forms of\nGenAI augmentation in SE and systematically characterizes their related\nresearch challenges and opportunities. These insights are then consolidated\ninto a set of future research directions. By grounding the roadmap in a\nrigorous multi-cycle process and cross-validating it among independent author\nteams and peers, the study provides a transparent and reproducible foundation\nfor analyzing how GenAI affects SE processes, methods and tools, and for\nframing future research within this rapidly evolving area. Based on these\nfindings, the article finally makes ten predictions for SE in the year 2030.", "AI": {"tldr": "This paper presents a roadmap for GenAI-augmented software engineering using design science research, identifying four fundamental forms of GenAI augmentation and their research challenges, with ten predictions for SE in 2030.", "motivation": "To systematically address how Generative AI is transforming software engineering practices and provide a structured foundation for future research in this rapidly evolving area.", "method": "Applied design science research with three cycles integrating multiple evidence sources: FSE 2025 workshop discussions, rapid literature reviews, and external feedback sessions. Used McLuhan's tetrads as conceptual instrument to capture GenAI's transforming effects.", "result": "Identified four fundamental forms of GenAI augmentation in SE and systematically characterized their research challenges and opportunities. Developed a set of future research directions and ten predictions for SE in 2030.", "conclusion": "The study provides a transparent and reproducible foundation for analyzing GenAI's impact on SE processes, methods, and tools, offering a roadmap to frame future research in this rapidly evolving domain."}}
{"id": "2510.26287", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26287", "abs": "https://arxiv.org/abs/2510.26287", "authors": ["Guochang Li", "Yuchen Liu", "Zhen Qin", "Yunkun Wang", "Jianping Zhong", "Chen Zhi", "Binhua Li", "Fei Huang", "Yongbin Li", "Shuiguang Deng"], "title": "Empowering RepoQA-Agent based on Reinforcement Learning Driven by Monte-carlo Tree Search", "comment": null, "summary": "Repository-level software engineering tasks require large language models\n(LLMs) to efficiently navigate and extract information from complex codebases\nthrough multi-turn tool interactions. Existing approaches face significant\nlimitations: training-free, in-context learning methods struggle to guide\nagents effectively in tool utilization and decision-making based on\nenvironmental feedback, while training-based approaches typically rely on\ncostly distillation from larger LLMs, introducing data compliance concerns in\nenterprise environments. To address these challenges, we introduce\nRepoSearch-R1, a novel agentic reinforcement learning framework driven by\nMonte-carlo Tree Search (MCTS). This approach allows agents to generate\ndiverse, high-quality reasoning trajectories via self-training without\nrequiring model distillation or external supervision. Based on RepoSearch-R1,\nwe construct a RepoQA-Agent specifically designed for repository\nquestion-answering tasks. Comprehensive evaluation on repository\nquestion-answering tasks demonstrates that RepoSearch-R1 achieves substantial\nimprovements of answer completeness: 16.0% enhancement over no-retrieval\nmethods, 19.5% improvement over iterative retrieval methods, and 33% increase\nin training efficiency compared to general agentic reinforcement learning\napproaches. Our cold-start training methodology eliminates data compliance\nconcerns while maintaining robust exploration diversity and answer completeness\nacross repository-level reasoning tasks.", "AI": {"tldr": "RepoSearch-R1 is a novel agentic reinforcement learning framework using Monte-carlo Tree Search for repository-level software engineering tasks, achieving significant improvements in answer completeness and training efficiency without requiring model distillation.", "motivation": "Existing approaches for repository-level software engineering tasks face limitations: training-free methods struggle with effective tool utilization and decision-making, while training-based approaches rely on costly distillation from larger LLMs with data compliance concerns.", "method": "Introduces RepoSearch-R1, an agentic reinforcement learning framework driven by Monte-carlo Tree Search (MCTS), enabling agents to generate diverse reasoning trajectories via self-training without model distillation or external supervision.", "result": "Achieves 16.0% improvement in answer completeness over no-retrieval methods, 19.5% improvement over iterative retrieval methods, and 33% increase in training efficiency compared to general agentic reinforcement learning approaches.", "conclusion": "The cold-start training methodology eliminates data compliance concerns while maintaining robust exploration diversity and answer completeness across repository-level reasoning tasks."}}
{"id": "2510.26413", "categories": ["cs.SE", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.26413", "abs": "https://arxiv.org/abs/2510.26413", "authors": ["Nuno Saavedra", "Alexandra Mendes", "Jo\u00e3o F. Ferreira"], "title": "Environmental Impact of CI/CD Pipelines", "comment": "This work has been submitted to the IEEE for possible publication", "summary": "CI/CD pipelines are widely used in software development, yet their\nenvironmental impact, particularly carbon and water footprints (CWF), remains\nlargely unknown to developers, as CI service providers typically do not\ndisclose such information. With the growing environmental impact of cloud\ncomputing, understanding the CWF of CI/CD services has become increasingly\nimportant.\n  This work investigates the CWF of using GitHub Actions, focusing on\nopen-source repositories where usage is free and unlimited for standard\nrunners. We build upon a methodology from the Cloud Carbon Footprint framework\nand we use the largest dataset of workflow runs reported in the literature to\ndate, comprising over 2.2 million workflow runs from more than 18,000\nrepositories.\n  Our analysis reveals that the GitHub Actions ecosystem results in a\nsubstantial CWF. Our estimates for the carbon footprint in 2024 range from\n150.5 MTCO2e in the most optimistic scenario to 994.9 MTCO2e in the most\npessimistic scenario, while the water footprint ranges from 1,989.6 to 37,664.5\nkiloliters. The most likely scenario estimates are 456.9 MTCO2e for carbon\nfootprint and 5,738.2 kiloliters for water footprint. To provide perspective,\nthe carbon footprint in the most likely scenario is equivalent to the carbon\ncaptured by 7,615 urban trees in a year, and the water footprint is comparable\nto the water consumed by an average American family over 5,053 years.\n  We explore strategies to mitigate this impact, primarily by reducing wasted\ncomputational resources. Key recommendations include deploying runners in\nregions whose energy production has a low environmental impact such as France\nand the United Kingdom, implementing stricter deactivation policies for\nscheduled runs and aligning their execution with periods when the regional\nenergy mix is more environmentally favorable, and reducing the size of\nrepositories.", "AI": {"tldr": "This study quantifies the significant carbon and water footprint of GitHub Actions CI/CD pipelines, estimating 456.9 MTCO2e carbon footprint and 5,738.2 kiloliters water footprint in the most likely scenario for 2024.", "motivation": "CI/CD pipelines have substantial environmental impacts that are not disclosed by service providers, making it important to understand and quantify their carbon and water footprints given the growing environmental impact of cloud computing.", "method": "Built upon Cloud Carbon Footprint framework methodology and analyzed the largest dataset of workflow runs reported in literature - over 2.2 million workflow runs from 18,000+ repositories.", "result": "GitHub Actions ecosystem has substantial environmental impact: carbon footprint ranges from 150.5-994.9 MTCO2e and water footprint from 1,989.6-37,664.5 kiloliters, with most likely estimates at 456.9 MTCO2e and 5,738.2 kiloliters respectively.", "conclusion": "Key mitigation strategies include deploying runners in low-impact regions like France and UK, implementing stricter deactivation policies for scheduled runs, aligning execution with favorable energy mix periods, and reducing repository sizes to reduce wasted computational resources."}}
{"id": "2510.26423", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.26423", "abs": "https://arxiv.org/abs/2510.26423", "authors": ["Dong Huang", "Mingzhe Du", "Jie M. Zhang", "Zheng Lin", "Meng Luo", "Qianru Zhang", "See-Kiong Ng"], "title": "Nexus: Execution-Grounded Multi-Agent Test Oracle Synthesis", "comment": "Under Review", "summary": "Test oracle generation in non-regression testing is a longstanding challenge\nin software engineering, where the goal is to produce oracles that can\naccurately determine whether a function under test (FUT) behaves as intended\nfor a given input. In this paper, we introduce Nexus, a novel multi-agent\nframework to address this challenge. Nexus generates test oracles by leveraging\na diverse set of specialized agents that synthesize test oracles through a\nstructured process of deliberation, validation, and iterative self-refinement.\nDuring the deliberation phase, a panel of four specialist agents, each\nembodying a distinct testing philosophy, collaboratively critiques and refines\nan initial set of test oracles. Then, in the validation phase, Nexus generates\na plausible candidate implementation of the FUT and executes the proposed\noracles against it in a secure sandbox. For any oracle that fails this\nexecution-based check, Nexus activates an automated selfrefinement loop, using\nthe specific runtime error to debug and correct the oracle before\nre-validation. Our extensive evaluation on seven diverse benchmarks\ndemonstrates that Nexus consistently and substantially outperforms\nstate-of-theart baselines. For instance, Nexus improves the test-level oracle\naccuracy on the LiveCodeBench from 46.30% to 57.73% for GPT-4.1-Mini. The\nimproved accuracy also significantly enhances downstream tasks: the bug\ndetection rate of GPT4.1-Mini generated test oracles on HumanEval increases\nfrom 90.91% to 95.45% for Nexus compared to baselines, and the success rate of\nautomated program repair improves from 35.23% to 69.32%.", "AI": {"tldr": "Nexus is a multi-agent framework that generates test oracles through specialized agents that deliberate, validate, and self-refine oracle candidates, significantly outperforming state-of-the-art methods.", "motivation": "Test oracle generation in non-regression testing is a longstanding challenge in software engineering, where the goal is to produce oracles that can accurately determine whether a function under test behaves as intended for a given input.", "method": "Nexus uses a multi-agent framework with four specialist agents embodying distinct testing philosophies to collaboratively critique and refine test oracles. It then validates oracles by generating candidate implementations and executing them in a secure sandbox, with an automated self-refinement loop to debug failing oracles.", "result": "Nexus improves test-level oracle accuracy on LiveCodeBench from 46.30% to 57.73% for GPT-4.1-Mini. It also enhances bug detection rate on HumanEval from 90.91% to 95.45% and improves automated program repair success rate from 35.23% to 69.32%.", "conclusion": "Nexus consistently and substantially outperforms state-of-the-art baselines in test oracle generation, demonstrating significant improvements in accuracy and downstream task performance."}}
{"id": "2510.26431", "categories": ["cs.SE", "cs.LO", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.26431", "abs": "https://arxiv.org/abs/2510.26431", "authors": ["Mih\u00e1ly Dobos-Kov\u00e1cs", "Levente Bajczi", "Andr\u00e1s V\u00f6r\u00f6s"], "title": "CHCVerif: A Portfolio-Based Solver for Constrained Horn Clauses", "comment": "In Proceedings HCVS 2025, arXiv:2510.25468", "summary": "Constrained Horn Clauses (CHCs) are widely adopted as intermediate\nrepresentations for a variety of verification tasks, including safety checking,\ninvariant synthesis, and interprocedural analysis. This paper introduces\nCHCVERIF, a portfolio-based CHC solver that adopts a software verification\napproach for solving CHCs. This approach enables us to reuse mature software\nverification tools to tackle CHC benchmarks, particularly those involving\nbitvectors and low-level semantics. Our evaluation shows that while the method\nenjoys only moderate success with linear integer arithmetic, it achieves modest\nsuccess on bitvector benchmarks. Moreover, our results demonstrate the\nviability and potential of using software verification tools as backends for\nCHC solving, particularly when supported by a carefully constructed portfolio.", "AI": {"tldr": "CHCVERIF is a portfolio-based CHC solver that uses software verification tools to solve CHC benchmarks, showing particular success with bitvector problems.", "motivation": "To leverage mature software verification tools for solving CHCs, especially for benchmarks involving bitvectors and low-level semantics.", "method": "Portfolio-based approach using software verification tools as backends for CHC solving.", "result": "Moderate success with linear integer arithmetic and modest success on bitvector benchmarks.", "conclusion": "Software verification tools are viable and promising as backends for CHC solving when used in a carefully constructed portfolio."}}
{"id": "2510.26457", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.26457", "abs": "https://arxiv.org/abs/2510.26457", "authors": ["Fang Liu", "Simiao Liu", "Yinghao Zhu", "Xiaoli Lian", "Li Zhang"], "title": "SecureReviewer: Enhancing Large Language Models for Secure Code Review through Secure-aware Fine-tuning", "comment": "Accepted by ICSE 2026. Code and data:\n  https://github.com/SIMIAO515/SecureReviewer", "summary": "Identifying and addressing security issues during the early phase of the\ndevelopment lifecycle is critical for mitigating the long-term negative impacts\non software systems. Code review serves as an effective practice that enables\ndevelopers to check their teammates' code before integration into the codebase.\nTo streamline the generation of review comments, various automated code review\napproaches have been proposed, where LLM-based methods have significantly\nadvanced the capabilities of automated review generation. However, existing\nmodels primarily focus on general-purpose code review, their effectiveness in\nidentifying and addressing security-related issues remains underexplored.\nMoreover, adapting existing code review approaches to target security issues\nfaces substantial challenges, including data scarcity and inadequate evaluation\nmetrics. To address these limitations, we propose SecureReviewer, a new\napproach designed for enhancing LLMs' ability to identify and resolve\nsecurity-related issues during code review. Specifically, we first construct a\ndataset tailored for training and evaluating secure code review capabilities.\nLeveraging this dataset, we fine-tune LLMs to generate code review comments\nthat can effectively identify security issues and provide fix suggestions with\nour proposed secure-aware fine-tuning strategy. To mitigate hallucination in\nLLMs and enhance the reliability of their outputs, we integrate the RAG\ntechnique, which grounds the generated comments in domain-specific security\nknowledge. Additionally, we introduce SecureBLEU, a new evaluation metric\ndesigned to assess the effectiveness of review comments in addressing security\nissues. Experimental results demonstrate that SecureReviewer outperforms\nstate-of-the-art baselines in both security issue detection accuracy and the\noverall quality and practical utility of generated review comments.", "AI": {"tldr": "SecureReviewer is an LLM-based approach for automated security-focused code review that addresses data scarcity and evaluation challenges through a specialized dataset, secure-aware fine-tuning, RAG integration, and a new SecureBLEU metric.", "motivation": "Existing automated code review approaches primarily focus on general-purpose reviews and lack effectiveness in identifying security issues. There are challenges in adapting these approaches including data scarcity and inadequate evaluation metrics for security-specific reviews.", "method": "Constructed a specialized dataset for secure code review, fine-tuned LLMs with secure-aware strategy, integrated RAG technique to mitigate hallucination and ground comments in security knowledge, and introduced SecureBLEU evaluation metric.", "result": "SecureReviewer outperforms state-of-the-art baselines in both security issue detection accuracy and the overall quality and practical utility of generated review comments.", "conclusion": "The proposed approach effectively enhances LLMs' ability to identify and resolve security-related issues during code review, addressing key limitations in existing automated code review methods."}}
{"id": "2510.26480", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26480", "abs": "https://arxiv.org/abs/2510.26480", "authors": ["Sivajeet Chand", "Melih Kilic", "Roland W\u00fcrsching", "Sushant Kumar Pandey", "Alexander Pretschner"], "title": "Automated Extract Method Refactoring with Open-Source LLMs: A Comparative Study", "comment": "Accepted at AIware'25 - Main Track", "summary": "Automating the Extract Method refactoring (EMR) remains challenging and\nlargely manual despite its importance in improving code readability and\nmaintainability. Recent advances in open-source, resource-efficient Large\nLanguage Models (LLMs) offer promising new approaches for automating such\nhigh-level tasks. In this work, we critically evaluate five state-of-the-art\nopen-source LLMs, spanning 3B to 8B parameter sizes, on the EMR task for Python\ncode. We systematically assess functional correctness and code quality using\nautomated metrics and investigate the impact of prompting strategies by\ncomparing one-shot prompting to a Recursive criticism and improvement (RCI)\napproach. RCI-based prompting consistently outperforms one-shot prompting in\ntest pass rates and refactoring quality. The best-performing models,\nDeepseek-Coder-RCI and Qwen2.5-Coder-RCI, achieve test pass percentage (TPP)\nscores of 0.829 and 0.808, while reducing lines of code (LOC) per method from\n12.103 to 6.192 and 5.577, and cyclomatic complexity (CC) from 4.602 to 3.453\nand 3.294, respectively. A developer survey on RCI-generated refactorings shows\nover 70% acceptance, with Qwen2.5-Coder rated highest across all evaluation\ncriteria. In contrast, the original code scored below neutral, particularly in\nreadability and maintainability, underscoring the benefits of automated\nrefactoring guided by quality prompts. While traditional metrics like CC and\nLOC provide useful signals, they often diverge from human judgments,\nemphasizing the need for human-in-the-loop evaluation. Our open-source\nbenchmark offers a foundation for future research on automated refactoring with\nLLMs.", "AI": {"tldr": "Evaluating open-source LLMs (3B-8B parameters) for Extract Method refactoring in Python code, showing RCI prompting outperforms one-shot prompting with best models achieving ~83% test pass rates and significant code quality improvements.", "motivation": "Automating Extract Method refactoring remains challenging despite its importance for code readability and maintainability, with recent open-source LLMs offering promising approaches for such high-level tasks.", "method": "Systematic evaluation of five state-of-the-art open-source LLMs using automated metrics for functional correctness and code quality, comparing one-shot prompting with Recursive criticism and improvement (RCI) approach.", "result": "RCI-based prompting consistently outperformed one-shot prompting. Best models achieved test pass percentages of 0.829 and 0.808, reduced LOC from 12.103 to 6.192/5.577, and cyclomatic complexity from 4.602 to 3.453/3.294. Developer survey showed over 70% acceptance of RCI-generated refactorings.", "conclusion": "RCI prompting significantly improves automated refactoring quality, though traditional metrics like CC and LOC often diverge from human judgments, emphasizing the need for human-in-the-loop evaluation. The benchmark provides foundation for future LLM-based refactoring research."}}
{"id": "2510.26516", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26516", "abs": "https://arxiv.org/abs/2510.26516", "authors": ["Truong Hai Dang", "Jingyu Xiao", "Yintong Huo"], "title": "Envisioning Future Interactive Web Development: Editing Webpage with Natural Language", "comment": "accepted by AIWare'25", "summary": "The evolution of web applications relies on iterative code modifications, a\nprocess that is traditionally manual and time-consuming. While Large Language\nModels (LLMs) can generate UI code, their ability to edit existing code from\nnew design requirements (e.g., \"center the logo\") remains a challenge. This is\nlargely due to the absence of large-scale, high-quality tuning data to align\nmodel performance with human expectations. In this paper, we introduce a novel,\nautomated data generation pipeline that uses LLMs to synthesize a high-quality\nfine-tuning dataset for web editing, named Instruct4Edit. Our approach\ngenerates diverse instructions, applies the corresponding code modifications,\nand performs visual verification to ensure correctness. By fine-tuning models\non Instruct4Edit, we demonstrate consistent improvement in translating human\nintent into precise, structurally coherent, and visually accurate code changes.\nThis work provides a scalable and transparent foundation for natural language\nbased web editing, demonstrating that fine-tuning smaller open-source models\ncan achieve competitive performance with proprietary systems. We release all\ndata, code implementations, and model checkpoints for reproduction.", "AI": {"tldr": "Instruct4Edit: A novel pipeline using LLMs to generate high-quality fine-tuning data for web code editing, enabling smaller open-source models to achieve competitive performance in translating natural language instructions into precise code modifications.", "motivation": "Traditional web application evolution requires manual code modifications, and while LLMs can generate UI code, they struggle with editing existing code from design requirements due to lack of large-scale, high-quality tuning data aligned with human expectations.", "method": "Automated data generation pipeline that uses LLMs to synthesize a high-quality fine-tuning dataset (Instruct4Edit) by generating diverse instructions, applying corresponding code modifications, and performing visual verification to ensure correctness.", "result": "Fine-tuning models on Instruct4Edit consistently improves translation of human intent into precise, structurally coherent, and visually accurate code changes, with smaller open-source models achieving competitive performance with proprietary systems.", "conclusion": "Provides a scalable and transparent foundation for natural language based web editing, demonstrating that fine-tuning smaller open-source models can achieve competitive performance. All data, code implementations, and model checkpoints are released for reproduction."}}
{"id": "2510.26538", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26538", "abs": "https://arxiv.org/abs/2510.26538", "authors": ["David Williams", "Max Hort", "Maria Kechagia", "Aldeida Aleti", "Justyna Petke", "Federica Sarro"], "title": "Reflecting on Empirical and Sustainability Aspects of Software Engineering Research in the Era of Large Language Models", "comment": "5 pages", "summary": "Software Engineering (SE) research involving the use of Large Language Models\n(LLMs) has introduced several new challenges related to rigour in benchmarking,\ncontamination, replicability, and sustainability. In this paper, we invite the\nresearch community to reflect on how these challenges are addressed in SE. Our\nresults provide a structured overview of current LLM-based SE research at ICSE,\nhighlighting both encouraging practices and persistent shortcomings. We\nconclude with recommendations to strengthen benchmarking rigour, improve\nreplicability, and address the financial and environmental costs of LLM-based\nSE.", "AI": {"tldr": "Analysis of challenges in LLM-based Software Engineering research focusing on benchmarking rigor, contamination, replicability, and sustainability issues.", "motivation": "To address emerging challenges in Software Engineering research using Large Language Models, particularly regarding benchmarking rigor, contamination, replicability, and sustainability concerns.", "method": "Conducted structured analysis of current LLM-based SE research presented at ICSE, examining practices and identifying shortcomings in the field.", "result": "Provides overview of current LLM-based SE research practices, highlighting both encouraging approaches and persistent limitations in addressing key research challenges.", "conclusion": "Recommends strengthening benchmarking rigor, improving replicability, and addressing financial/environmental costs of LLM-based SE research."}}
{"id": "2510.26576", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26576", "abs": "https://arxiv.org/abs/2510.26576", "authors": ["Filippo Scaramuzza", "Renato Cordeiro Ferreira", "Tomaz Maia Suller", "Giovanni Quattrocchi", "Damian Andrew Tamburri", "Willem-Jan van den Heuvel"], "title": "\"Show Me You Comply... Without Showing Me Anything\": Zero-Knowledge Software Auditing for AI-Enabled Systems", "comment": "This work has been submitted to the ACM Transactions on Software\n  Engineering and Methodology for possible publication", "summary": "The increasing exploitation of Artificial Intelligence (AI) enabled systems\nin critical domains has made trustworthiness concerns a paramount showstopper,\nrequiring verifiable accountability, often by regulation (e.g., the EU AI Act).\nClassical software verification and validation techniques, such as procedural\naudits, formal methods, or model documentation, are the mechanisms used to\nachieve this. However, these methods are either expensive or heavily manual and\nill-suited for the opaque, \"black box\" nature of most AI models. An intractable\nconflict emerges: high auditability and verifiability are required by law, but\nsuch transparency conflicts with the need to protect assets being audited-e.g.,\nconfidential data and proprietary models-leading to weakened accountability. To\naddress this challenge, this paper introduces ZKMLOps, a novel MLOps\nverification framework that operationalizes Zero-Knowledge Proofs\n(ZKPs)-cryptographic protocols allowing a prover to convince a verifier that a\nstatement is true without revealing additional information-within\nMachine-Learning Operations lifecycles. By integrating ZKPs with established\nsoftware engineering patterns, ZKMLOps provides a modular and repeatable\nprocess for generating verifiable cryptographic proof of compliance. We\nevaluate the framework's practicality through a study of regulatory compliance\nin financial risk auditing and assess feasibility through an empirical\nevaluation of top ZKP protocols, analyzing performance trade-offs for ML models\nof increasing complexity.", "AI": {"tldr": "ZKMLOps is a framework that uses Zero-Knowledge Proofs (ZKPs) to enable verifiable compliance auditing of AI systems while protecting confidential data and proprietary models, addressing the conflict between transparency requirements and asset protection.", "motivation": "There's a fundamental conflict in AI regulation: laws require high auditability and verifiability, but traditional verification methods conflict with the need to protect confidential data and proprietary models, leading to weakened accountability.", "method": "The paper introduces ZKMLOps, which integrates Zero-Knowledge Proofs (ZKPs) with established software engineering patterns within Machine-Learning Operations lifecycles. This creates a modular, repeatable process for generating verifiable cryptographic proof of compliance without revealing sensitive information.", "result": "The framework was evaluated for regulatory compliance in financial risk auditing and assessed through empirical evaluation of top ZKP protocols. The study analyzed performance trade-offs for ML models of increasing complexity, demonstrating the framework's practicality and feasibility.", "conclusion": "ZKMLOps provides a viable solution to the auditability-transparency conflict in AI systems by leveraging cryptographic proofs to enable verifiable compliance while maintaining data and model confidentiality."}}
{"id": "2510.26579", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26579", "abs": "https://arxiv.org/abs/2510.26579", "authors": ["Nathanael Nussbaumer", "Markus B\u00f6ck", "J\u00fcrgen Cito"], "title": "Online and Interactive Bayesian Inference Debugging", "comment": "Accepted by ICSE 2026", "summary": "Probabilistic programming is a rapidly developing programming paradigm which\nenables the formulation of Bayesian models as programs and the automation of\nposterior inference. It facilitates the development of models and conducting\nBayesian inference, which makes these techniques available to practitioners\nfrom multiple fields. Nevertheless, probabilistic programming is notoriously\ndifficult as identifying and repairing issues with inference requires a lot of\ntime and deep knowledge. Through this work, we introduce a novel approach to\ndebugging Bayesian inference that reduces time and required knowledge\nsignificantly. We discuss several requirements a Bayesian inference debugging\nframework has to fulfill, and propose a new tool that meets these key\nrequirements directly within the development environment. We evaluate our\nresults in a study with 18 experienced participants and show that our approach\nto online and interactive debugging of Bayesian inference significantly reduces\ntime and difficulty on inference debugging tasks.", "AI": {"tldr": "A novel approach to debugging Bayesian inference in probabilistic programming that reduces time and required knowledge through online interactive debugging tools integrated into development environments.", "motivation": "Probabilistic programming enables Bayesian modeling but is notoriously difficult to debug, requiring significant time and deep expertise to identify and fix inference issues.", "method": "Proposed a Bayesian inference debugging framework that meets key requirements and implements online interactive debugging tools directly within development environments.", "result": "Evaluation with 18 experienced participants showed the approach significantly reduces time and difficulty on inference debugging tasks.", "conclusion": "The interactive debugging framework successfully addresses the challenges of debugging Bayesian inference, making probabilistic programming more accessible to practitioners."}}
{"id": "2510.26634", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26634", "abs": "https://arxiv.org/abs/2510.26634", "authors": ["Yuan Si", "Kyle Qi", "Daming Li", "Hanyuan Shi", "Jialu Zhang"], "title": "Stitch: Step-by-step LLM Guided Tutoring for Scratch", "comment": null, "summary": "Block-based environments such as Scratch are increasingly popular in\nprogramming education. While block syntax reduces surface errors, semantic bugs\nremain common and challenging for novices to resolve. Existing debugging\nworkflows typically show the correct program directly to learners, a strategy\nthat may fix errors but undermines the development of problem-solving skills.\n  We present Stitch, an interactive tutoring system that replaces \"showing the\nanswer\" with step-by-step scaffolding. The system's Diff-Analyze module\ncontrasts a student's project with a reference implementation, identifies the\nmost critical differences, and uses a large language model to explain why these\nchanges matter. Learners inspect highlighted blocks through a custom rendering\nengine, understand the explanations, and selectively apply partial fixes. This\niterative process continues until the intended functionality is achieved.\n  We evaluate Stitch in an empirical study, comparing it against a\nstate-of-the-art automated feedback generation tool for Scratch. Our key\ninsight is that simply presenting the correct program is pedagogically\nineffective. In contrast, our interactive, step-by-step guided system promotes\na more effective learning experience. More broadly, what constitutes effective\nfeedback in block-based programming remains an open question. Our evaluation\nprovides new evidence that step-by-step tutoring significantly enhances\nlearning outcomes, outperforming both direct-answer approaches and current\nautomated feedback generation tools.", "AI": {"tldr": "Stitch is an interactive tutoring system for Scratch programming that provides step-by-step scaffolding instead of showing the correct answer directly, helping students learn debugging skills through iterative partial fixes guided by AI explanations.", "motivation": "Existing debugging workflows in block-based programming often show the correct program directly, which fixes errors but undermines problem-solving skill development. There's a need for more pedagogically effective feedback approaches.", "method": "Stitch uses a Diff-Analyze module to compare student projects with reference implementations, identifies critical differences, and uses a large language model to explain why changes matter. Students inspect highlighted blocks and selectively apply partial fixes iteratively.", "result": "Evaluation shows Stitch significantly outperforms state-of-the-art automated feedback generation tools and direct-answer approaches. The step-by-step guided system promotes more effective learning experiences and better learning outcomes.", "conclusion": "Step-by-step tutoring significantly enhances learning outcomes in block-based programming, outperforming both direct-answer approaches and current automated feedback tools. What constitutes effective feedback in block-based programming remains an open question."}}
{"id": "2510.26676", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26676", "abs": "https://arxiv.org/abs/2510.26676", "authors": ["Samiha Shimmi", "Nicholas M. Synovic", "Mona Rahimi", "George K. Thiruvathukal"], "title": "Process-based Indicators of Vulnerability Re-Introducing Code Changes: An Exploratory Case Study", "comment": "9 pages, 6 figures; Samiha Shimmi and Nicholas M. Synovic contributed\n  equally to this work (co-first authors); Mona Rahimi and George K.\n  Thiruvathukal contributed equally to this work (co-supervisors)", "summary": "Software vulnerabilities often persist or re-emerge even after being fixed,\nrevealing the complex interplay between code evolution and socio-technical\nfactors. While source code metrics provide useful indicators of\nvulnerabilities, software engineering process metrics can uncover patterns that\nlead to their introduction. Yet few studies have explored whether process\nmetrics can reveal risky development activities over time -- insights that are\nessential for anticipating and mitigating software vulnerabilities. This work\nhighlights the critical role of process metrics along with code changes in\nunderstanding and mitigating vulnerability reintroduction. We move beyond\nfile-level prediction and instead analyze security fixes at the commit level,\nfocusing not only on whether a single fix introduces a vulnerability but also\non the longer sequences of changes through which vulnerabilities evolve and\nre-emerge. Our approach emphasizes that reintroduction is rarely the result of\none isolated action, but emerges from cumulative development activities and\nsocio-technical conditions. To support this analysis, we conducted a case study\non the ImageMagick project by correlating longitudinal process metrics such as\nbus factor, issue density, and issue spoilage with vulnerability reintroduction\nactivities, encompassing 76 instances of reintroduced vulnerabilities. Our\nfindings show that reintroductions often align with increased issue spoilage\nand fluctuating issue density, reflecting short-term inefficiencies in issue\nmanagement and team responsiveness. These observations provide a foundation for\nbroader studies that combine process and code metrics to predict risky fixes\nand strengthen software security.", "AI": {"tldr": "The paper analyzes vulnerability reintroduction in software by examining process metrics and code changes at the commit level, using ImageMagick as a case study to show how development activities and socio-technical factors contribute to security issues.", "motivation": "Software vulnerabilities often persist or re-emerge after fixes, revealing complex interactions between code evolution and socio-technical factors. Current approaches focus mainly on source code metrics, but process metrics can uncover patterns leading to vulnerability introduction over time.", "method": "Analyzed security fixes at commit level rather than file-level, examining longer sequences of changes through which vulnerabilities evolve and re-emerge. Conducted case study on ImageMagick project, correlating longitudinal process metrics (bus factor, issue density, issue spoilage) with 76 instances of reintroduced vulnerabilities.", "result": "Reintroductions often align with increased issue spoilage and fluctuating issue density, reflecting short-term inefficiencies in issue management and team responsiveness. Vulnerability reintroduction rarely results from isolated actions but emerges from cumulative development activities and socio-technical conditions.", "conclusion": "Process metrics combined with code metrics provide essential insights for predicting risky fixes and strengthening software security. The findings establish foundation for broader studies using both process and code metrics to anticipate and mitigate software vulnerabilities."}}
{"id": "2510.26699", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26699", "abs": "https://arxiv.org/abs/2510.26699", "authors": ["Aylton Almeida", "Laerte Xavier", "Marco Tulio Valente"], "title": "Using Copilot Agent Mode to Automate Library Migration: A Quantitative Assessment", "comment": null, "summary": "Keeping software systems up to date is essential to avoid technical debt,\nsecurity vulnerabilities, and the rigidity typical of legacy systems. However,\nupdating libraries and frameworks remains a time consuming and error-prone\nprocess. Recent advances in Large Language Models (LLMs) and agentic coding\nsystems offer new opportunities for automating such maintenance tasks. In this\npaper, we evaluate the update of a well-known Python library, SQLAlchemy,\nacross a dataset of ten client applications. For this task, we use the Github's\nCopilot Agent Mode, an autonomous AI systema capable of planning and executing\nmulti-step migration workflows. To assess the effectiveness of the automated\nmigration, we also introduce Migration Coverage, a metric that quantifies the\nproportion of API usage points correctly migrated. The results of our study\nshow that the LLM agent was capable of migrating functionalities and API usages\nbetween SQLAlchemy versions (migration coverage: 100%, median), but failed to\nmaintain the application functionality, leading to a low test-pass rate\n(39.75%, median).", "AI": {"tldr": "Evaluates GitHub's Copilot Agent Mode for automating SQLAlchemy library updates across 10 Python applications, achieving 100% API migration coverage but only 39.75% test pass rate.", "motivation": "Software library updates are time-consuming and error-prone, and recent LLM advances offer opportunities to automate these maintenance tasks.", "method": "Used GitHub's Copilot Agent Mode to automate SQLAlchemy migrations across 10 client applications, introducing Migration Coverage metric to quantify API usage migration.", "result": "LLM agent achieved 100% median migration coverage (API usage points correctly migrated) but only 39.75% median test pass rate (functionality not maintained).", "conclusion": "While LLM agents can successfully migrate API usages between library versions, they struggle to maintain application functionality, highlighting a gap between API migration and functional preservation."}}
{"id": "2510.26793", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.26793", "abs": "https://arxiv.org/abs/2510.26793", "authors": ["Nafid Enan", "Gias Uddin"], "title": "Optimized Log Parsing with Syntactic Modifications", "comment": null, "summary": "Logs provide valuable insights into system runtime and assist in software\ndevelopment and maintenance. Log parsing, which converts semi-structured log\ndata into structured log data, is often the first step in automated log\nanalysis. Given the wide range of log parsers utilizing diverse techniques, it\nis essential to evaluate them to understand their characteristics and\nperformance. In this paper, we conduct a comprehensive empirical study\ncomparing syntax- and semantic-based log parsers, as well as single-phase and\ntwo-phase parsing architectures. Our experiments reveal that semantic-based\nmethods perform better at identifying the correct templates and syntax-based\nlog parsers are 10 to 1,000 times more efficient and provide better grouping\naccuracy although they fall short in accurate template identification.\nMoreover, two-phase architecture consistently improves accuracy compared to\nsingle-phase architecture. Based on the findings of this study, we propose\nSynLog+, a template identification module that acts as the second phase in a\ntwo-phase log parsing architecture. SynLog+ improves the parsing accuracy of\nsyntax-based and semantic-based log parsers by 236\\% and 20\\% on average,\nrespectively, with virtually no additional runtime cost.", "AI": {"tldr": "Comprehensive empirical study comparing syntax- and semantic-based log parsers, showing semantic methods are better at template identification while syntax methods are much faster. Two-phase architecture improves accuracy, leading to SynLog+ which boosts parsing accuracy significantly.", "motivation": "Log parsing is crucial for automated log analysis, and with many diverse log parsers available, it's essential to evaluate their characteristics and performance to understand which approaches work best.", "method": "Conducted empirical study comparing syntax-based and semantic-based log parsers, as well as single-phase vs two-phase parsing architectures. Proposed SynLog+ as a template identification module for two-phase architecture.", "result": "Semantic-based methods perform better at template identification, while syntax-based parsers are 10-1000x more efficient with better grouping accuracy. Two-phase architecture consistently improves accuracy. SynLog+ improves parsing accuracy by 236% for syntax-based and 20% for semantic-based parsers with minimal runtime cost.", "conclusion": "Two-phase parsing architecture with SynLog+ significantly enhances log parsing accuracy across both syntax- and semantic-based approaches, providing an effective solution for automated log analysis."}}
