{"id": "2510.24749", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.24749", "abs": "https://arxiv.org/abs/2510.24749", "authors": ["Aofan Liu", "Shiyuan Song", "Haoxuan Li", "Cehao Yang", "Yiyan Qi"], "title": "Beyond Function-Level Search: Repository-Aware Dual-Encoder Code Retrieval with Adversarial Verification", "comment": "Accepted by EMNLP 2025", "summary": "The escalating complexity of modern codebases has intensified the need for\nretrieval systems capable of interpreting cross-component change intents, a\ncapability fundamentally absent in conventional function-level search\nparadigms. While recent studies have improved the alignment between natural\nlanguage queries and code snippets, retrieving contextually relevant code for\nspecific change requests remains largely underexplored. To address this gap, we\nintroduce RepoAlign-Bench, the first benchmark specifically designed to\nevaluate repository-level code retrieval under change request driven scenarios,\nencompassing 52k annotated instances. This benchmark shifts the retrieval\nparadigm from function-centric matching to holistic repository-level reasoning.\nFurthermore, we propose ReflectCode, an adversarial reflection augmented\ndual-tower architecture featuring disentangled code_encoder and doc_encoder\ncomponents. ReflectCode dynamically integrates syntactic patterns, function\ndependencies, and semantic expansion intents through large language model\nguided reflection. Comprehensive experiments demonstrate that ReflectCode\nachieves 12.2% improvement in Top-5 Accuracy and 7.1% in Recall over\nstate-of-the-art baselines, establishing a new direction for context-aware code\nretrieval.", "AI": {"tldr": "RepoAlign-Bench is the first benchmark for repository-level code retrieval under change requests, and ReflectCode is a dual-tower architecture that improves retrieval performance through LLM-guided reflection.", "motivation": "Modern codebases are complex and require retrieval systems that can interpret cross-component change intents, which conventional function-level search cannot handle. Retrieving contextually relevant code for change requests remains underexplored.", "method": "ReflectCode uses an adversarial reflection augmented dual-tower architecture with disentangled code_encoder and doc_encoder components. It dynamically integrates syntactic patterns, function dependencies, and semantic expansion intents through LLM-guided reflection.", "result": "ReflectCode achieves 12.2% improvement in Top-5 Accuracy and 7.1% in Recall over state-of-the-art baselines.", "conclusion": "The approach establishes a new direction for context-aware code retrieval by shifting from function-centric matching to holistic repository-level reasoning."}}
{"id": "2510.24799", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.24799", "abs": "https://arxiv.org/abs/2510.24799", "authors": ["Filipe R. Cogo", "Gustavo A. Oliva", "Ahmed E. Hassan"], "title": "Compiler.next: A Search-Based Compiler to Power the AI-Native Future of Software Engineering", "comment": "31 pages, 5 figures, submitted to ACM Transactions on Software\n  Engineering and Methodology", "summary": "The rapid advancement of AI-assisted software engineering has brought\ntransformative potential to the field of software engineering, but existing\ntools and paradigms remain limited by cognitive overload, inefficient tool\nintegration, and the narrow capabilities of AI copilots. In response, we\npropose Compiler.next, a novel search-based compiler designed to enable the\nseamless evolution of AI-native software systems as part of the emerging\nSoftware Engineering 3.0 era. Unlike traditional static compilers,\nCompiler.next takes human-written intents and automatically generates working\nsoftware by searching for an optimal solution. This process involves dynamic\noptimization of cognitive architectures and their constituents (e.g., prompts,\nfoundation model configurations, and system parameters) while finding the\noptimal trade-off between several objectives, such as accuracy, cost, and\nlatency. This paper outlines the architecture of Compiler.next and positions it\nas a cornerstone in democratizing software development by lowering the\ntechnical barrier for non-experts, enabling scalable, adaptable, and reliable\nAI-powered software. We present a roadmap to address the core challenges in\nintent compilation, including developing quality programming constructs,\neffective search heuristics, reproducibility, and interoperability between\ncompilers. Our vision lays the groundwork for fully automated, search-driven\nsoftware development, fostering faster innovation and more efficient AI-driven\nsystems.", "AI": {"tldr": "Compiler.next is a search-based compiler that transforms human-written intents into working software by dynamically optimizing cognitive architectures and finding optimal trade-offs between objectives like accuracy, cost, and latency.", "motivation": "To address limitations in current AI-assisted software engineering tools, including cognitive overload, inefficient tool integration, and narrow AI copilot capabilities, by enabling seamless evolution of AI-native software systems.", "method": "Proposes a search-based compiler that takes human intents and automatically generates software through dynamic optimization of cognitive architectures, including prompts, foundation model configurations, and system parameters.", "result": "The paper outlines Compiler.next's architecture and positions it as a cornerstone for democratizing software development by lowering technical barriers for non-experts and enabling scalable, adaptable AI-powered software.", "conclusion": "Provides a roadmap for addressing challenges in intent compilation and lays groundwork for fully automated, search-driven software development to foster faster innovation and more efficient AI-driven systems."}}
{"id": "2510.24819", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.24819", "abs": "https://arxiv.org/abs/2510.24819", "authors": ["Vincenzo Scotti", "Jan Keim", "Tobias Hey", "Andreas Metzger", "Anne Koziolek", "Raffaela Mirandola"], "title": "A Roadmap for Tamed Interactions with Large Language Models", "comment": null, "summary": "We are witnessing a bloom of AI-powered software driven by Large Language\nModels (LLMs). Although the applications of these LLMs are impressive and\nseemingly countless, their unreliability hinders adoption. In fact, the\ntendency of LLMs to produce faulty or hallucinated content makes them\nunsuitable for automating workflows and pipelines. In this regard, Software\nEngineering (SE) provides valuable support, offering a wide range of formal\ntools to specify, verify, and validate software behaviour. Such SE tools can be\napplied to define constraints over LLM outputs and, consequently, offer\nstronger guarantees on the generated content. In this paper, we argue that the\ndevelopment of a Domain Specific Language (DSL) for scripting interactions with\nLLMs using an LLM Scripting Language (LSL) may be key to improve AI-based\napplications. Currently, LLMs and LLM-based software still lack reliability,\nrobustness, and trustworthiness, and the tools or frameworks to cope with these\nissues suffer from fragmentation. In this paper, we present our vision of LSL.\nWith LSL, we aim to address the limitations above by exploring ways to control\nLLM outputs, enforce structure in interactions, and integrate these aspects\nwith verification, validation, and explainability. Our goal is to make LLM\ninteraction programmable and decoupled from training or implementation.", "AI": {"tldr": "Proposes a Domain Specific Language (LSL) for scripting LLM interactions to improve reliability, robustness, and trustworthiness of AI applications by enabling output control, structured interactions, and integration with verification tools.", "motivation": "Current LLMs produce unreliable and hallucinated content, making them unsuitable for automated workflows. Software Engineering tools can provide formal verification but current approaches are fragmented.", "method": "Develop an LLM Scripting Language (LSL) as a Domain Specific Language to program LLM interactions, control outputs, enforce structure, and integrate with verification and validation tools.", "result": "Vision presented for LSL framework that would make LLM interactions programmable and decoupled from training/implementation, addressing reliability issues.", "conclusion": "A specialized scripting language for LLMs is needed to overcome current limitations and enable more reliable, verifiable AI applications through structured programming of interactions."}}
{"id": "2510.25015", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25015", "abs": "https://arxiv.org/abs/2510.25015", "authors": ["Chuyue Sun", "Yican Sun", "Daneshvar Amrollahi", "Ethan Zhang", "Shuvendu Lahiri", "Shan Lu", "David Dill", "Clark Barrett"], "title": "VeriStruct: AI-assisted Automated Verification of Data-Structure Modules in Verus", "comment": null, "summary": "We introduce VeriStruct, a novel framework that extends AI-assisted automated\nverification from single functions to more complex data structure modules in\nVerus. VeriStruct employs a planner module to orchestrate the systematic\ngeneration of abstractions, type invariants, specifications, and proof code. To\naddress the challenge that LLMs often misunderstand Verus' annotation syntax\nand verification-specific semantics, VeriStruct embeds syntax guidance within\nprompts and includes a repair stage to automatically correct annotation errors.\nIn an evaluation on eleven Rust data structure modules, VeriStruct succeeds on\nten of the eleven, successfully verifying 128 out of 129 functions (99.2%) in\ntotal. These results represent an important step toward the goal of automatic\nAI-assisted formal verification.", "AI": {"tldr": "VeriStruct is a framework that extends AI-assisted verification from single functions to complex data structure modules in Verus, using LLMs with syntax guidance and repair mechanisms to achieve high verification success rates.", "motivation": "To address the limitation of existing AI-assisted verification tools that only handle single functions, and to overcome LLMs' difficulties with Verus' annotation syntax and verification semantics.", "method": "Uses a planner module to generate abstractions, type invariants, specifications, and proof code. Embeds syntax guidance in prompts and includes a repair stage to automatically correct annotation errors.", "result": "Successfully verified 128 out of 129 functions (99.2%) across eleven Rust data structure modules, succeeding on ten out of eleven modules.", "conclusion": "VeriStruct represents an important advancement toward automatic AI-assisted formal verification by effectively extending verification capabilities to complex data structure modules."}}
{"id": "2510.25016", "categories": ["cs.SE", "cs.AI", "cs.HC", "cs.LG", "68T07, 68N30", "D.2.1; I.2.6; I.2.7"], "pdf": "https://arxiv.org/pdf/2510.25016", "abs": "https://arxiv.org/abs/2510.25016", "authors": ["Mateen Ahmed Abbasi", "Petri Ihantola", "Tommi Mikkonen", "Niko M\u00e4kitalo"], "title": "Towards Human-AI Synergy in Requirements Engineering: A Framework and Preliminary Study", "comment": "Accepted at the 2025 Sixth International Conference on Intelligent\n  Data Science Technologies and Applications (IDSTA 2025),8 pages, 4 figures.\n  Published in IEEE", "summary": "The future of Requirements Engineering (RE) is increasingly driven by\nartificial intelligence (AI), reshaping how we elicit, analyze, and validate\nrequirements. Traditional RE is based on labor-intensive manual processes prone\nto errors and complexity. AI-powered approaches, specifically large language\nmodels (LLMs), natural language processing (NLP), and generative AI, offer\ntransformative solutions and reduce inefficiencies. However, the use of AI in\nRE also brings challenges like algorithmic bias, lack of explainability, and\nethical concerns related to automation. To address these issues, this study\nintroduces the Human-AI RE Synergy Model (HARE-SM), a conceptual framework that\nintegrates AI-driven analysis with human oversight to improve requirements\nelicitation, analysis, and validation. The model emphasizes ethical AI use\nthrough transparency, explainability, and bias mitigation. We outline a\nmulti-phase research methodology focused on preparing RE datasets, fine-tuning\nAI models, and designing collaborative human-AI workflows. This preliminary\nstudy presents the conceptual framework and early-stage prototype\nimplementation, establishing a research agenda and practical design direction\nfor applying intelligent data science techniques to semi-structured and\nunstructured RE data in collaborative environments.", "AI": {"tldr": "The paper proposes a Human-AI RE Synergy Model (HARE-SM) that integrates AI technologies with human oversight to address challenges in Requirements Engineering while ensuring ethical AI use through transparency and bias mitigation.", "motivation": "Traditional Requirements Engineering is labor-intensive and error-prone, while AI-powered approaches offer transformative solutions but face challenges like algorithmic bias, lack of explainability, and ethical concerns.", "method": "The study introduces HARE-SM framework with multi-phase research methodology including preparing RE datasets, fine-tuning AI models, and designing collaborative human-AI workflows.", "result": "Preliminary study presents conceptual framework and early-stage prototype implementation, establishing research agenda for applying intelligent data science to RE data in collaborative environments.", "conclusion": "The HARE-SM model provides a foundation for integrating AI-driven analysis with human oversight to improve requirements elicitation, analysis, and validation while addressing ethical AI concerns."}}
{"id": "2510.25039", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.25039", "abs": "https://arxiv.org/abs/2510.25039", "authors": ["Amanda Dsouza", "Harit Vishwakarma", "Zhengyang Qi", "Justin Bauer", "Derek Pham", "Thomas Walshe", "Armin Parchami", "Frederic Sala", "Paroma Varma"], "title": "Automating Benchmark Design", "comment": null, "summary": "The rapid progress and widespread deployment of LLMs and LLM-powered agents\nhas outpaced our ability to evaluate them. Hand-crafted, static benchmarks are\nthe primary tool for assessing model capabilities, but these quickly become\nsaturated. In contrast, dynamic benchmarks evolve alongside the models they\nevaluate, but are expensive to create and continuously update. To address these\nchallenges, we develop BeTaL (Benchmark Tuning with an LLM-in-the-loop), a\nframework that leverages environment design principles to automate the process\nof dynamic benchmark design. BeTaL works by parameterizing key design choices\nin base benchmark templates and uses LLMs to reason through the resulting\nparameter space to obtain target properties (such as difficulty and realism) in\na cost-efficient manner. We validate this approach on its ability to create\nbenchmarks with desired difficulty levels. Using BeTaL, we create two new\nbenchmarks and extend a popular agentic benchmark $\\tau$-bench. Extensive\nevaluation on these three tasks and multiple target difficulty levels shows\nthat BeTaL produces benchmarks much closer to the desired difficulty, with\naverage deviations ranging from 5.3% to 13.2% -- a 2-4x improvement over the\nbaselines.", "AI": {"tldr": "BeTaL is a framework that uses LLMs to automatically design dynamic benchmarks by parameterizing benchmark templates and optimizing for target properties like difficulty, achieving 2-4x better alignment with desired difficulty levels compared to baselines.", "motivation": "Current static benchmarks quickly become saturated as LLMs evolve, while dynamic benchmarks are expensive to create and update manually. There's a need for automated, cost-efficient dynamic benchmark design.", "method": "BeTaL parameterizes key design choices in base benchmark templates and uses LLMs to reason through the parameter space to achieve target properties like difficulty and realism in a cost-efficient manner.", "result": "BeTaL created two new benchmarks and extended \u03c4-bench, achieving average deviations from target difficulty ranging from 5.3% to 13.2% - a 2-4x improvement over baselines.", "conclusion": "BeTaL successfully automates dynamic benchmark design, producing benchmarks that closely match desired difficulty levels and addressing the limitations of both static and manually-created dynamic benchmarks."}}
{"id": "2510.25057", "categories": ["cs.SE", "K.3.2; K.6.5; K.4.1"], "pdf": "https://arxiv.org/pdf/2510.25057", "abs": "https://arxiv.org/abs/2510.25057", "authors": ["Robin Maisch", "Larissa Schmid", "Timur Sa\u011flam", "Nils Niehues"], "title": "Same Same But Different: Preventing Refactoring Attacks on Software Plagiarism Detection", "comment": "To be published at ICSE'26. 13 pages, 6 figures", "summary": "Plagiarism detection in programming education faces growing challenges due to\nincreasingly sophisticated obfuscation techniques, particularly automated\nrefactoring-based attacks. While code plagiarism detection systems used in\neducation practice are resilient against basic obfuscation, they struggle\nagainst structural modifications that preserve program behavior, especially\ncaused by refactoring-based obfuscation. This paper presents a novel and\nextensible framework that enhances state-of-the-art detectors by leveraging\ncode property graphs and graph transformations to counteract refactoring-based\nobfuscation. Our comprehensive evaluation of real-world student submissions,\nobfuscated using both algorithmic and AI-based obfuscation attacks,\ndemonstrates a significant improvement in detecting plagiarized code.", "AI": {"tldr": "A framework using code property graphs and graph transformations to improve plagiarism detection in programming education against refactoring-based obfuscation attacks.", "motivation": "Current plagiarism detection systems struggle against sophisticated obfuscation techniques, especially refactoring-based attacks that preserve program behavior while changing structure.", "method": "Leverages code property graphs and graph transformations to enhance state-of-the-art detectors, creating an extensible framework to counteract refactoring-based obfuscation.", "result": "Comprehensive evaluation on real-world student submissions shows significant improvement in detecting plagiarized code, tested against both algorithmic and AI-based obfuscation attacks.", "conclusion": "The proposed framework effectively enhances plagiarism detection capabilities against advanced obfuscation techniques in programming education."}}
{"id": "2510.25103", "categories": ["cs.SE", "D.2.4"], "pdf": "https://arxiv.org/pdf/2510.25103", "abs": "https://arxiv.org/abs/2510.25103", "authors": ["Minghai Lu", "Zhe Zhou", "Danning Xie", "Songlin Jia", "Benjamin Delaware", "Tianyi Zhang"], "title": "Adaptive Proof Refinement with LLM-Guided Strategy Selection", "comment": "11 pages, 11 figures", "summary": "Formal verification via theorem proving enables the expressive specification\nand rigorous proof of software correctness, but it is difficult to scale due to\nthe significant manual effort and expertise required. While Large Language\nModels (LLMs) show potential in proof generation, they frequently produce\nincorrect proofs on the first attempt and require additional strategies for\niterative refinement. However, existing approaches employ fixed refinement\nstrategies and cannot dynamically choose an effective strategy based on the\nparticular issues in a generated proof, which limits their performance. To\novercome this limitation, we introduce Adapt, a novel proof refinement\nframework that leverages an LLM-guided decision-maker to dynamically select a\nsuitable refinement strategy according to the state of the proof assistant and\navailable context of an incorrect proof. We evaluate Adapt on two benchmarks\nagainst four existing methods and find that it significantly outperforms the\nbest baseline on both by proving 16.63% and 18.58% more theorems, respectively.\nFurthermore, we demonstrate Adapt's generalizability by evaluating it across\nfive different LLMs. We also conduct ablation studies to measure the\ncontribution of each component and compare the trade-offs of alternative\ndecision-maker designs.", "AI": {"tldr": "Adapt is a proof refinement framework that uses LLM-guided decision-making to dynamically select refinement strategies for theorem proving, outperforming existing methods by proving 16.63-18.58% more theorems.", "motivation": "Formal verification via theorem proving requires significant manual effort, and while LLMs show potential, they often produce incorrect proofs initially and existing refinement approaches use fixed strategies that can't adapt to specific proof issues.", "method": "Adapt leverages an LLM-guided decision-maker to dynamically select suitable refinement strategies based on the proof assistant state and context of incorrect proofs, enabling adaptive proof correction.", "result": "Adapt significantly outperforms four existing methods on two benchmarks, proving 16.63% and 18.58% more theorems respectively, and shows strong generalizability across five different LLMs.", "conclusion": "The dynamic strategy selection approach in Adapt effectively addresses limitations of fixed refinement strategies in LLM-based theorem proving, demonstrating substantial performance improvements and generalizability across different language models."}}
{"id": "2510.25148", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25148", "abs": "https://arxiv.org/abs/2510.25148", "authors": ["Katsuki Yamagishi", "Norihiro Yoshida", "Erina Makihara", "Katsuro Inoue"], "title": "Automated Program Repair Based on REST API Specifications Using Large Language Models", "comment": null, "summary": "Many cloud services provide REST API accessible to client applications.\nHowever, developers often identify specification violations only during\ntesting, as error messages typically lack the detail necessary for effective\ndiagnosis. Consequently, debugging requires trial and error. This study\nproposes dcFix, a method for detecting and automatically repairing REST API\nmisuses in client programs. In particular, dcFix identifies non-conforming code\nfragments, integrates them with the relevant API specifications into prompts,\nand leverages a Large Language Model (LLM) to produce the corrected code. Our\nevaluation demonstrates that dcFix accurately detects misuse and outperforms\nthe baseline approach, in which prompts to the LLM omit any indication of code\nfragments non conforming to REST API specifications.", "AI": {"tldr": "dcFix is a method that automatically detects and repairs REST API misuses in client programs by identifying non-conforming code, integrating API specifications into prompts, and using LLMs to generate corrected code.", "motivation": "Developers often discover REST API specification violations only during testing, and error messages lack sufficient detail for effective diagnosis, making debugging a trial-and-error process.", "method": "dcFix identifies non-conforming code fragments, integrates them with relevant API specifications into prompts, and leverages Large Language Models to produce corrected code.", "result": "Evaluation shows dcFix accurately detects misuse and outperforms baseline approaches where LLM prompts omit indications of code fragments non-conforming to REST API specifications.", "conclusion": "dcFix provides an effective automated solution for detecting and repairing REST API misuses in client programs, improving over manual debugging approaches."}}
{"id": "2510.25195", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25195", "abs": "https://arxiv.org/abs/2510.25195", "authors": ["Shuochuan Li", "Zan Wang", "Xiaoning Du", "Zhuo Wu", "Jiuqiao Yu", "Junjie Chen"], "title": "Optimizing Knowledge Utilization for Multi-Intent Comment Generation with Large Language Models", "comment": null, "summary": "Code comment generation aims to produce a generic overview of a code snippet,\nhelping developers understand and maintain code. However, generic summaries\nalone are insufficient to meet the diverse needs of practitioners; for example,\ndevelopers expect the implementation insights to be presented in an untangled\nmanner, while users seek clear usage instructions. This highlights the\nnecessity of multi-intent comment generation. With the widespread adoption of\nLarge Language Models (LLMs) for code-related tasks, these models have been\nleveraged to tackle the challenge of multi-intent comment generation. Despite\ntheir successes, state-of-the-art LLM-based approaches often struggle to\nconstruct correct relationships among intents, code, and comments within a\nsmaller number of demonstration examples. To mitigate this issue, we propose a\nframework named KUMIC for multi-intent comment generation. Built upon\nin-context learning, KUMIC leverages Chain-of-Thought (CoT) to optimize\nknowledge utilization for LLMs to generate intent-specific comments.\nSpecifically, KUMIC first designs a retrieval mechanism to obtain similar\ndemonstration examples, which exhibit high code-comment consistency. Then,\nKUMIC leverages CoT to guide LLMs to focus on statements facilitating the\nderivation of code comments aligned with specific intents. In this context,\nKUMIC constructs a mapping knowledge chain, linking code to intent-specific\nstatements to comments, which enables LLMs to follow similar reasoning steps\nwhen generating the desired comments. We conduct extensive experiments to\nevaluate KUMIC, and the results demonstrate that KUMIC outperforms\nstate-of-the-art baselines by 14.49\\%, 22.41\\%, 20.72\\%, and 12.94\\% in terms\nof BLEU, METEOR, ROUGE-L, and SBERT, respectively.", "AI": {"tldr": "KUMIC is a framework for multi-intent code comment generation that uses Chain-of-Thought and retrieval mechanisms to help LLMs generate intent-specific comments by establishing proper relationships between code, intents, and comments.", "motivation": "Generic code summaries are insufficient for diverse practitioner needs - developers want implementation insights while users need usage instructions, highlighting the need for multi-intent comment generation. Current LLM approaches struggle with constructing correct relationships among intents, code, and comments with limited examples.", "method": "KUMIC uses in-context learning with Chain-of-Thought (CoT) to optimize knowledge utilization. It retrieves similar demonstration examples with high code-comment consistency, then uses CoT to guide LLMs to focus on statements that help derive intent-specific comments, constructing a mapping knowledge chain from code to intent-specific statements to comments.", "result": "KUMIC outperforms state-of-the-art baselines by significant margins: 14.49% in BLEU, 22.41% in METEOR, 20.72% in ROUGE-L, and 12.94% in SBERT scores.", "conclusion": "KUMIC effectively addresses the multi-intent comment generation challenge by leveraging CoT and retrieval mechanisms to help LLMs generate high-quality intent-specific comments through proper reasoning steps and knowledge mapping."}}
{"id": "2510.25242", "categories": ["cs.SE", "C.3; D.2"], "pdf": "https://arxiv.org/pdf/2510.25242", "abs": "https://arxiv.org/abs/2510.25242", "authors": ["Nao Yoshimura", "Hiroshi Oyama", "Takuya Azumi"], "title": "TECS/Rust-OE: Optimizing Exclusive Control in Rust-based Component Systems for Embedded Devices", "comment": "5 pages (layout expanded from the 4-page IEEE version due to minor\n  lstlisting configuration adjustments for compilation). Originally published\n  as a poster paper at IEEE ISORC 2025", "summary": "The diversification of functionalities and the development of the IoT are\nmaking embedded systems larger and more complex in structure. Ensuring system\nreliability, especially in terms of security, necessitates selecting an\nappropriate programming language. As part of existing research, TECS/Rust has\nbeen proposed as a framework that combines Rust and component-based development\n(CBD) to enable scalable system design and enhanced reliability. This framework\nrepresents system structures using static mutable variables, but excessive\nexclusive controls applied to ensure thread safety have led to performance\ndegradation. This paper proposes TECS/Rust-OE, a memory-safe CBD framework\nutilizing call flows to address these limitations. The proposed Rust code\nleverages real-time OS exclusive control mechanisms, optimizing performance\nwithout compromising reusability. Rust code is automatically generated based on\ncomponent descriptions. Evaluations demonstrate reduced overhead due to\noptimized exclusion control and high reusability of the generated code.", "AI": {"tldr": "TECS/Rust-OE is a memory-safe component-based development framework that uses call flows to optimize performance while maintaining reusability, addressing performance issues in the original TECS/Rust framework.", "motivation": "Embedded systems are becoming larger and more complex, requiring reliable programming languages. The existing TECS/Rust framework suffered from performance degradation due to excessive exclusive controls for thread safety.", "method": "Proposes TECS/Rust-OE framework that uses call flows and leverages real-time OS exclusive control mechanisms. Rust code is automatically generated from component descriptions to optimize performance without compromising reusability.", "result": "Evaluations show reduced overhead from optimized exclusion control and high reusability of the generated code.", "conclusion": "TECS/Rust-OE successfully addresses the performance limitations of TECS/Rust while maintaining memory safety and reusability in component-based embedded system development."}}
{"id": "2510.25270", "categories": ["cs.SE", "C.3; D.2"], "pdf": "https://arxiv.org/pdf/2510.25270", "abs": "https://arxiv.org/abs/2510.25270", "authors": ["Nao Yoshimura", "Hiroshi Oyama", "Takuya Azumi"], "title": "TECS/Rust: Memory-safe Component Framework for Embedded Systems", "comment": "10 pages. This version includes minor lstlisting configuration\n  adjustments for successful compilation. No changes to content or layout.\n  Originally published at IEEE ISORC 2024", "summary": "As embedded systems grow in complexity and scale due to increased functional\ndiversity, component-based development (CBD) emerges as a solution to\nstreamline their architecture and enhance functionality reuse. CBD typically\nutilizes the C programming language for its direct hardware access and\nlow-level operations, despite its susceptibility to memory-related issues. To\naddress these concerns, this paper proposes TECS/Rust, a Rust-based framework\nspecifically designed for TECS, which is a component framework for embedded\nsystems. It leverages Rust's compile-time memory-safe features, such as\nlifetime and borrowing, to mitigate memory vulnerabilities common with C. The\nproposed framework not only ensures memory safety but also maintains the\nflexibility of CBD, automates Rust code generation for CBD components, and\nsupports efficient integration with real-time operating systems. An evaluation\nof the amount of generated code indicates that the code generated by this paper\nframework accounts for a large percentage of the actual code. Compared to code\ndeveloped without the proposed framework, the difference in execution time is\nminimal, indicating that the overhead introduced by the proposed framework is\nnegligible.", "AI": {"tldr": "TECS/Rust is a Rust-based framework for embedded systems that replaces C in component-based development to provide memory safety while maintaining performance and CBD flexibility.", "motivation": "As embedded systems grow more complex, component-based development using C faces memory-related vulnerabilities. Rust's compile-time memory safety features offer a solution to these issues.", "method": "Proposes TECS/Rust framework that leverages Rust's lifetime and borrowing features, automates Rust code generation for CBD components, and supports integration with real-time operating systems.", "result": "Evaluation shows generated code accounts for large percentage of actual code, with minimal execution time difference compared to non-framework code, indicating negligible overhead.", "conclusion": "TECS/Rust successfully provides memory safety for embedded CBD while maintaining performance and flexibility, with minimal runtime overhead."}}
{"id": "2510.25297", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25297", "abs": "https://arxiv.org/abs/2510.25297", "authors": ["Hidetake Tanaka", "Haruto Tanaka", "Kazumasa Shimari", "Kenichi Matsumoto"], "title": "Understanding the Characteristics of LLM-Generated Property-Based Tests in Exploring Edge Cases", "comment": "Accepted for publication in 2nd IEEE/ACM international conference on\n  AI-powered Software (AIware 2025) : 8 pages, 1 table, 8 figures", "summary": "As Large Language Models (LLMs) increasingly generate code in software\ndevelopment, ensuring the quality of LLM-generated code has become important.\nTraditional testing approaches using Example-based Testing (EBT) often miss\nedge cases -- defects that occur at boundary values, special input patterns, or\nextreme conditions. This research investigates the characteristics of\nLLM-generated Property-based Testing (PBT) compared to EBT for exploring edge\ncases. We analyze 16 HumanEval problems where standard solutions failed on\nextended test cases, generating both PBT and EBT test codes using\nClaude-4-sonnet. Our experimental results reveal that while each method\nindividually achieved a 68.75\\% bug detection rate, combining both approaches\nimproved detection to 81.25\\%. The analysis demonstrates complementary\ncharacteristics: PBT effectively detects performance issues and edge cases\nthrough extensive input space exploration, while EBT effectively detects\nspecific boundary conditions and special patterns. These findings suggest that\na hybrid approach leveraging both testing methods can improve the reliability\nof LLM-generated code, providing guidance for test generation strategies in\nLLM-based code generation.", "AI": {"tldr": "Combining Property-based Testing (PBT) and Example-based Testing (EBT) improves bug detection in LLM-generated code from 68.75% to 81.25%, showing complementary strengths in finding edge cases.", "motivation": "As LLMs increasingly generate code, ensuring code quality is crucial. Traditional EBT often misses edge cases, prompting investigation of PBT's effectiveness for detecting boundary conditions and extreme scenarios.", "method": "Analyzed 16 HumanEval problems where standard solutions failed on extended tests, generating both PBT and EBT test codes using Claude-4-sonnet and comparing their bug detection capabilities.", "result": "Individual PBT and EBT methods each achieved 68.75% bug detection rate, but combining both approaches increased detection to 81.25%. PBT excels at finding performance issues and edge cases through input space exploration, while EBT is better at specific boundary conditions.", "conclusion": "A hybrid approach combining PBT and EBT can significantly improve the reliability of LLM-generated code, providing valuable guidance for test generation strategies in LLM-based code development."}}
{"id": "2510.25406", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25406", "abs": "https://arxiv.org/abs/2510.25406", "authors": ["Changjie Wang", "Mariano Scazzariello", "Anoud Alshnaka", "Roberto Guanciale", "Dejan Kosti\u0107", "Marco Chiesa"], "title": "Dissect-and-Restore: AI-based Code Verification with Transient Refactoring", "comment": null, "summary": "Formal verification is increasingly recognized as a critical foundation for\nbuilding reliable software systems. However, the need for specialized expertise\nto write precise specifications, navigate complex proof obligations, and learn\nannotations often makes verification an order of magnitude more expensive than\nimplementation. While modern AI systems can recognize patterns in mathematical\nproofs and interpret natural language, effectively integrating them into the\nformal verification process remains an open challenge. We present Prometheus, a\nnovel AI-assisted system that facilitates automated code verification with\ncurrent AI capabilities in conjunction with modular software engineering\nprinciples (e.g., modular refactoring). Our approach begins by decomposing\ncomplex program logic, such as nested loops, into smaller, verifiable\ncomponents. Once verified, these components are recomposed to construct a proof\nof the original program. This decomposition-recomposition workflow is\nnon-trivial. Prometheus addresses this by guiding the proof search through\nstructured decomposition of complex lemmas into smaller, verifiable sub-lemmas.\nWhen automated tools are insufficient, users can provide lightweight natural\nlanguage guidance to steer the proof process effectively. Our evaluation\ndemonstrates that transiently applying modular restructuring to the code\nsubstantially improves the AI's effectiveness in verifying individual\ncomponents. This approach successfully verifies 86% of tasks in our curated\ndataset, compared to 68% for the baseline. Gains are more pronounced with\nincreasing specification complexity, improving from 30% to 69%, and when\nintegrating proof outlines for complex programs, from 25% to 87%.", "AI": {"tldr": "Prometheus is an AI-assisted system that uses modular decomposition and recomposition to automate formal verification, improving verification success rates from 68% to 86% compared to baseline approaches.", "motivation": "Formal verification is critical for reliable software but requires specialized expertise, making it expensive. AI systems can recognize patterns but struggle to integrate effectively into verification workflows.", "method": "Decomposes complex program logic into smaller verifiable components, then recomposes them. Uses structured decomposition of lemmas and allows natural language guidance when automated tools fail.", "result": "Verifies 86% of tasks vs 68% baseline. More significant gains with complex specifications (30% to 69%) and with proof outlines for complex programs (25% to 87%).", "conclusion": "Modular restructuring combined with AI guidance substantially improves verification effectiveness, making formal verification more accessible and efficient."}}
{"id": "2510.25423", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25423", "abs": "https://arxiv.org/abs/2510.25423", "authors": ["Ali Asgari", "Annibale Panichella", "Pouria Derakhshanfar", "Mitchell Olsthoorn"], "title": "What Challenges Do Developers Face in AI Agent Systems? An Empirical Study on Stack Overflow", "comment": "12 pages, 4 Figures", "summary": "AI agents have rapidly gained popularity across research and industry as\nsystems that extend large language models with additional capabilities to plan,\nuse tools, remember, and act toward specific goals. Yet despite their promise,\ndevelopers face persistent and often underexplored challenges when building,\ndeploying, and maintaining these emerging systems. To identify these\nchallenges, we study developer discussions on Stack Overflow, the world's\nlargest developer-focused Q and A platform with about 60 million questions and\nanswers and 30 million users. We construct a taxonomy of developer challenges\nthrough tag expansion and filtering, apply LDA-MALLET for topic modeling, and\nmanually validate and label the resulting themes. Our analysis reveals seven\nmajor areas of recurring issues encompassing 77 distinct technical challenges\nrelated to runtime integration, dependency management, orchestration\ncomplexity, and evaluation reliability. We further quantify topic popularity\nand difficulty to identify which issues are most common and hardest to resolve,\nmap the tools and programming languages used in agent development, and track\ntheir evolution from 2021 to 2025 in relation to major AI model and framework\nreleases. Finally, we present the implications of our results, offering\nconcrete guidance for practitioners, researchers, and educators on agent\nreliability and developer support.", "AI": {"tldr": "This paper analyzes developer challenges in building AI agents by studying Stack Overflow discussions, identifying 77 technical issues across 7 major areas, and tracking their evolution from 2021-2025.", "motivation": "AI agents are rapidly gaining popularity but developers face persistent and underexplored challenges when building, deploying, and maintaining these systems.", "method": "Studied developer discussions on Stack Overflow using tag expansion/filtering, applied LDA-MALLET for topic modeling, and manually validated themes. Analyzed 60M questions/answers from 30M users.", "result": "Identified 7 major areas with 77 distinct technical challenges related to runtime integration, dependency management, orchestration complexity, and evaluation reliability. Quantified topic popularity/difficulty and tracked evolution from 2021-2025.", "conclusion": "Provides concrete guidance for practitioners, researchers, and educators on agent reliability and developer support based on the identified challenges and their patterns."}}
{"id": "2510.25506", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.25506", "abs": "https://arxiv.org/abs/2510.25506", "authors": ["Florian Angermeir", "Maximilian Amougou", "Mark Kreitz", "Andreas Bauer", "Matthias Linhuber", "Davide Fucci", "Fabiola Moy\u00f3n C.", "Daniel Mendez", "Tony Gorschek"], "title": "Reflections on the Reproducibility of Commercial LLM Performance in Empirical Software Engineering Studies", "comment": null, "summary": "Large Language Models have gained remarkable interest in industry and\nacademia. The increasing interest in LLMs in academia is also reflected in the\nnumber of publications on this topic over the last years. For instance, alone\n78 of the around 425 publications at ICSE 2024 performed experiments with LLMs.\nConducting empirical studies with LLMs remains challenging and raises questions\non how to achieve reproducible results, for both other researchers and\npractitioners. One important step towards excelling in empirical research on\nLLMs and their application is to first understand to what extent current\nresearch results are eventually reproducible and what factors may impede\nreproducibility. This investigation is within the scope of our work. We\ncontribute an analysis of the reproducibility of LLM-centric studies, provide\ninsights into the factors impeding reproducibility, and discuss suggestions on\nhow to improve the current state. In particular, we studied the 86 articles\ndescribing LLM-centric studies, published at ICSE 2024 and ASE 2024. Of the 86\narticles, 18 provided research artefacts and used OpenAI models. We attempted\nto replicate those 18 studies. Of the 18 studies, only five were fit for\nreproduction. For none of the five studies, we were able to fully reproduce the\nresults. Two studies seemed to be partially reproducible, and three studies did\nnot seem to be reproducible. Our results highlight not only the need for\nstricter research artefact evaluations but also for more robust study designs\nto ensure the reproducible value of future publications.", "AI": {"tldr": "Analysis of reproducibility in LLM-centric studies from ICSE 2024 and ASE 2024 conferences, finding only 5 out of 86 studies were suitable for reproduction attempts, with none fully reproducible.", "motivation": "The increasing use of LLMs in research raises concerns about reproducibility. Understanding current reproducibility challenges is crucial for improving empirical research quality and reliability.", "method": "Analyzed 86 LLM-centric studies from ICSE 2024 and ASE 2024, focusing on 18 that provided research artifacts and used OpenAI models. Attempted to replicate these 18 studies.", "result": "Only 5 out of 18 studies were fit for reproduction. None were fully reproducible - 2 appeared partially reproducible, 3 not reproducible at all.", "conclusion": "Current LLM research faces significant reproducibility issues, highlighting the need for stricter artifact evaluation and more robust study designs to ensure research value."}}
{"id": "2510.25665", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.25665", "abs": "https://arxiv.org/abs/2510.25665", "authors": ["Ayse Irmak Ercevik", "Aidan Dakhama", "Melane Navaratnarajah", "Yazhuo Cao", "Leo Fernandes"], "title": "Fuzz Smarter, Not Harder: Towards Greener Fuzzing with GreenAFL", "comment": null, "summary": "Fuzzing has become a key search-based technique for software testing, but\ncontinuous fuzzing campaigns consume substantial computational resources and\ngenerate significant carbon footprints. Existing grey-box fuzzing approaches\nlike AFL++ focus primarily on coverage maximisation, without considering the\nenergy costs of exploring different execution paths. This paper presents\nGreenAFL, an energy-aware framework that incorporates power consumption into\nthe fuzzing heuristics to reduce the environmental impact of automated testing\nwhilst maintaining coverage. GreenAFL introduces two key modifications to\ntraditional fuzzing workflows: energy-aware corpus minimisation considering\npower consumption when reducing initial corpora, and energy-guided heuristics\nthat direct mutation towards high-coverage, low-energy inputs. We conduct an\nablation study comparing vanilla AFL++, energy-based corpus minimisation, and\nenergy-based heuristics to evaluate the individual contributions of each\ncomponent. Results show that highest coverage, and lowest energy usage is\nachieved whenever at least one of our modifications is used.", "AI": {"tldr": "GreenAFL is an energy-aware fuzzing framework that incorporates power consumption into fuzzing heuristics to reduce environmental impact while maintaining coverage.", "motivation": "Traditional grey-box fuzzing approaches like AFL++ focus on coverage maximization without considering energy costs, leading to substantial computational resources and carbon footprints in continuous fuzzing campaigns.", "method": "GreenAFL introduces two key modifications: energy-aware corpus minimization that considers power consumption when reducing initial corpora, and energy-guided heuristics that direct mutation towards high-coverage, low-energy inputs.", "result": "Results from ablation studies show that highest coverage and lowest energy usage are achieved when at least one of the energy-aware modifications is used compared to vanilla AFL++.", "conclusion": "GreenAFL successfully reduces the environmental impact of automated testing while maintaining coverage by incorporating energy awareness into fuzzing workflows."}}
{"id": "2510.25692", "categories": ["cs.SE", "cs.LG", "D.2.6; I.2.6"], "pdf": "https://arxiv.org/pdf/2510.25692", "abs": "https://arxiv.org/abs/2510.25692", "authors": ["Tim Strnad", "Bla\u017e Bertalani\u010d", "Carolina Fortuna"], "title": "A Configuration-First Framework for Reproducible, Low-Code Localization", "comment": "20 pages, 7 figures. Preprint submitted to ACM Transactions on\n  Software Engineering and Methodology (TOSEM), 2025", "summary": "Machine learning is increasingly permeating radio-based localization\nservices. To keep results credible and comparable, everyday workflows should\nmake rigorous experiment specification and exact repeatability the default,\nwithout blocking advanced experimentation. However, in practice, researchers\nface a three-way gap that could be filled by a framework that offers (i) low\ncoding effort for end-to-end studies, (ii) reproducibility by default including\nversioned code, data, and configurations, controlled randomness, isolated runs,\nand recorded artifacts, and (iii) built-in extensibility so new models,\nmetrics, and stages can be added with minimal integration effort. Existing\ntools rarely deliver all three for machine learning in general and localization\nworkflows in particular. In this paper we introduce LOCALIZE, a low-code,\nconfiguration-first framework for radio localization in which experiments are\ndeclared in human-readable configuration, a workflow orchestrator runs\nstandardized pipelines from data preparation to reporting, and all artifacts,\nsuch as datasets, models, metrics, and reports, are versioned. The\npreconfigured, versioned datasets reduce initial setup and boilerplate,\nspeeding up model development and evaluation. The design, with clear extension\npoints, allows experts to add components without reworking the infrastructure.\nIn a qualitative comparison and a head-to-head study against a plain Jupyter\nnotebook baseline, we show that the framework reduces authoring effort while\nmaintaining comparable runtime and memory behavior. Furthermore, using a\nBluetooth Low Energy dataset, we show that scaling across training data (1x to\n10x) keeps orchestration overheads bounded as data grows. Overall, the\nframework makes reproducible machine-learning-based localization\nexperimentation practical, accessible, and extensible.", "AI": {"tldr": "LOCALIZE is a low-code framework for reproducible radio localization experiments that uses configuration-first approach with versioned artifacts and standardized pipelines.", "motivation": "To address the gap in tools that offer low coding effort, reproducibility by default, and built-in extensibility for machine learning in radio-based localization services.", "method": "A configuration-first framework where experiments are declared in human-readable config files, with workflow orchestrator running standardized pipelines from data prep to reporting, and all artifacts are versioned.", "result": "Reduces authoring effort while maintaining comparable runtime and memory behavior to Jupyter notebooks, with bounded orchestration overhead when scaling data from 1x to 10x.", "conclusion": "The framework makes reproducible machine-learning-based localization experimentation practical, accessible, and extensible."}}
{"id": "2510.25694", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.25694", "abs": "https://arxiv.org/abs/2510.25694", "authors": ["Jiayi Kuang", "Yinghui Li", "Xin Zhang", "Yangning Li", "Di Yin", "Xing Sun", "Ying Shen", "Philip S. Yu"], "title": "Process-Level Trajectory Evaluation for Environment Configuration in Software Engineering Agents", "comment": null, "summary": "Large language model-based agents show promise for software engineering, but\nenvironment configuration remains a bottleneck due to heavy manual effort and\nscarce large-scale, high-quality datasets. Existing benchmarks assess only\nend-to-end build/test success, obscuring where and why agents succeed or fail.\nWe introduce the Environment Configuration Diagnosis Benchmark, Enconda-bench,\nwhich provides process-level trajectory assessment of fine-grained agent\ncapabilities during environment setup-planning, perception-driven error\ndiagnosis, feedback-driven repair, and action to execute final environment\nconfiguration. Our task instances are automatically constructed by injecting\nrealistic README errors and are validated in Docker for scalable, high-quality\nevaluation. Enconda-bench combines process-level analysis with end-to-end\nexecutability to enable capability assessments beyond aggregate success rates.\nEvaluations across state-of-the-art LLMs and agent frameworks show that while\nagents can localize errors, they struggle to translate feedback into effective\ncorrections, limiting end-to-end performance. To our knowledge, Enconda-bench\nis the first framework to provide process-level internal capability assessment\nfor environment configuration, offering actionable insights for improving\nsoftware engineering agents.", "AI": {"tldr": "Enconda-bench is a new benchmark that provides process-level trajectory assessment for LLM-based agents in software environment configuration, going beyond end-to-end success rates to analyze fine-grained capabilities like error diagnosis and repair.", "motivation": "Current benchmarks only assess end-to-end build/test success, which obscures where and why agents succeed or fail in environment configuration tasks. There's a need for process-level analysis to understand agent capabilities during environment setup.", "method": "Automatically construct task instances by injecting realistic README errors and validate in Docker for scalable evaluation. The benchmark assesses planning, perception-driven error diagnosis, feedback-driven repair, and action execution during environment configuration.", "result": "Evaluations show that while agents can localize errors, they struggle to translate feedback into effective corrections, limiting end-to-end performance. The benchmark enables capability assessments beyond aggregate success rates.", "conclusion": "Enconda-bench is the first framework to provide process-level internal capability assessment for environment configuration, offering actionable insights for improving software engineering agents."}}
