<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 13]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [AutoCode: LLMs as Problem Setters for Competitive Programming](https://arxiv.org/abs/2510.12803)
*Shang Zhou,Zihan Zheng,Kaiyuan Liu,Zeyu Shen,Zerui Cheng,Zexing Chen,Hansen He,Jianzhu Yao,Huanzhi Mao,Qiuyang Mang,Tianfu Fu,Beichen Li,Dongruixuan Li,Wenhao Chai,Zhuang Liu,Aleksandra Korolova,Peter Henderson,Natasha Jaques,Pramod Viswanath,Saining Xie,Jingbo Shang*

Main category: cs.SE

TL;DR: AutoCode is a system that uses multiple validation rounds to automatically generate competition-grade programming problems and test cases, achieving 99% consistency with official judgments and producing novel problems judged by top programmers as contest quality.


<details>
  <summary>Details</summary>
Motivation: Competitive programming problem creation is challenging and requires setting constraints, input distributions, edge cases, targeting specific algorithms, and calibrating complexity - making it an ideal test for large language model capabilities.

Method: AutoCode uses multiple rounds of validation to generate problem statements and test cases. It can create novel variants from random seed problems with reference and brute-force solutions, then cross-verifies these solutions against test cases to filter out malformed problems.

Result: AutoCode achieves 99% consistency with official judgments on held-out problems, significantly outperforming state-of-the-art methods like HardTests (81%). Human experts verify high correctness, and Grandmaster-level programmers judge the generated problems as contest quality.

Conclusion: AutoCode demonstrates that large language models can reliably generate competition-grade programming problems through systematic validation and cross-verification, producing novel problems that meet professional standards.

Abstract: Writing competitive programming problems is exacting. Authors must: set
constraints, input distributions, and edge cases that rule out shortcuts;
target specific algorithms (e.g., max-flow, dynamic programming, data
structures); and calibrate complexity beyond the reach of most competitors. We
argue that this makes for an ideal test of general large language model
capabilities and study whether they can do this reliably. We introduce
AutoCode, which uses multiple rounds of validation to yield competition-grade
problem statements and test cases. On held-out problems, AutoCode test suites
approach 99% consistency with official judgments, a significant improvement
over current state-of-the-art methods like HardTests, which achieve less than
81%. Furthermore, starting with a random seed problem, AutoCode can create
novel variants with reference and brute-force solutions. By cross-verifying
these generated solutions against test cases, we can further filter out
malformed problems. Our system ensures high correctness, as verified by human
experts. AutoCode successfully produces novel problems judged by
Grandmaster-level (top 0.3%) competitive programmers to be of contest quality.

</details>


### [2] [SpareCodeSearch: Searching for Code Context When You Have No Spare GPU](https://arxiv.org/abs/2510.12948)
*Minh Nguyen*

Main category: cs.SE

TL;DR: Keyword-search is sufficient for code context retrieval in RAG frameworks, outperforming semantic search in resource efficiency while achieving competitive completion results.


<details>
  <summary>Details</summary>
Motivation: Semantic search in RAG frameworks requires substantial computational resources, making them impractical for lightweight applications like in-IDE code completion.

Method: Proposed using keyword-search instead of semantic search to retrieve relevant code context from large codebases without extensive GPU resources.

Result: Achieved 0.748 and 0.725 chRF scores on Kotlin and Python tracks respectively in the Code Context Competition benchmark.

Conclusion: Keyword-search provides a viable, resource-efficient alternative to semantic search for code context retrieval in RAG frameworks.

Abstract: Retrieval-Augmented Generation (RAG) frameworks aim to enhance Code Language
Models (CLMs) by including another module for retrieving relevant context to
construct the input prompt. However, these retrieval modules commonly use
semantic search, requiring substantial computational resources for training and
hosting these embedded models, making them infeasible to integrate into
lightweight applications such as in-IDE AI-based code completion. In this
solution paper, we prove that using keyword-search is sufficient to retrieve
relevant and useful code context inside large codebases, without the need for
extensive GPU resources. The usefulness of code contexts found by our solution
is demonstrated through their completion results on the Code Context
Competition's benchmark, reaching 0.748 and 0.725 chRF scores on Kotlin and
Python tracks, respectively.

</details>


### [3] [ADPerf: Investigating and Testing Performance in Autonomous Driving Systems](https://arxiv.org/abs/2510.13078)
*Tri Minh-Triet Pham,Diego Elias Costa,Weiyi Shang,Jinqiu Yang*

Main category: cs.SE

TL;DR: ADPerf is a tool that generates realistic LiDAR point cloud test cases to expose increased detection latency in autonomous driving systems, which can propagate to other modules and reduce overall system reliability.


<details>
  <summary>Details</summary>
Motivation: Obstacle detection latency is critical for autonomous driving safety, but current understanding of detection module performance and resilience to LiDAR data changes is limited.

Method: Conducted comprehensive investigation of Apollo and Autoware systems, then developed ADPerf tool to generate realistic point cloud test cases that stress detection modules and measure latency impact.

Result: Evaluation showed that 3D obstacle detection modules can be major latency bottlenecks, and increased detection latency negatively propagates to subsequent modules like trajectory prediction.

Conclusion: Performance testing of obstacle detection components is essential as they can significantly impact autonomous driving system latency and overall reliability.

Abstract: Obstacle detection is crucial to the operation of autonomous driving systems,
which rely on multiple sensors, such as cameras and LiDARs, combined with code
logic and deep learning models to detect obstacles for time-sensitive
decisions. Consequently, obstacle detection latency is critical to the safety
and effectiveness of autonomous driving systems. However, the latency of the
obstacle detection module and its resilience to various changes in the LiDAR
point cloud data are not yet fully understood. In this work, we present the
first comprehensive investigation on measuring and modeling the performance of
the obstacle detection modules in two industry-grade autonomous driving
systems, i.e., Apollo and Autoware. Learning from this investigation, we
introduce ADPerf, a tool that aims to generate realistic point cloud data test
cases that can expose increased detection latency. Increasing latency decreases
the availability of the detected obstacles and stresses the capabilities of
subsequent modules in autonomous driving systems, i.e., the modules may be
negatively impacted by the increased latency in obstacle detection.
  We applied ADPerf to stress-test the performance of widely used 3D obstacle
detection modules in autonomous driving systems, as well as the propagation of
such tests on trajectory prediction modules. Our evaluation highlights the need
to conduct performance testing of obstacle detection components, especially 3D
obstacle detection, as they can be a major bottleneck to increased latency of
the autonomous driving system. Such an adverse outcome will also further
propagate to other modules, reducing the overall reliability of autonomous
driving systems.

</details>


### [4] [TRUSTVIS: A Multi-Dimensional Trustworthiness Evaluation Framework for Large Language Models](https://arxiv.org/abs/2510.13106)
*Ruoyu Sun,Da Song,Jiayang Song,Yuheng Huang,Lei Ma*

Main category: cs.SE

TL;DR: TRUSTVIS is an automated evaluation framework with interactive visualizations that assesses LLM trustworthiness using perturbation methods and majority voting across multiple evaluation approaches.


<details>
  <summary>Details</summary>
Motivation: Address critical concerns about LLM trustworthiness, particularly in safety and robustness, as LLMs revolutionize NLP applications.

Method: Integrates well-known perturbation methods like AutoDAN and employs majority voting across various evaluation methods, with an interactive user interface for intuitive visualizations.

Result: Preliminary case studies on Vicuna-7b, Llama2-7b, and GPT-3.5 demonstrate effectiveness in identifying safety and robustness vulnerabilities.

Conclusion: TRUSTVIS provides reliable results and makes complex evaluation processes accessible, empowering targeted model improvements through detailed result exploration.

Abstract: As Large Language Models (LLMs) continue to revolutionize Natural Language
Processing (NLP) applications, critical concerns about their trustworthiness
persist, particularly in safety and robustness. To address these challenges, we
introduce TRUSTVIS, an automated evaluation framework that provides a
comprehensive assessment of LLM trustworthiness. A key feature of our framework
is its interactive user interface, designed to offer intuitive visualizations
of trustworthiness metrics. By integrating well-known perturbation methods like
AutoDAN and employing majority voting across various evaluation methods,
TRUSTVIS not only provides reliable results but also makes complex evaluation
processes accessible to users. Preliminary case studies on models like
Vicuna-7b, Llama2-7b, and GPT-3.5 demonstrate the effectiveness of our
framework in identifying safety and robustness vulnerabilities, while the
interactive interface allows users to explore results in detail, empowering
targeted model improvements. Video Link: https://youtu.be/k1TrBqNVg8g

</details>


### [5] [Isolating Compiler Bugs through Compilation Steps Analysis](https://arxiv.org/abs/2510.13128)
*Yujie Liu,Mingxuan Zhu,Shengyu Cheng,Dan Hao*

Main category: cs.SE

TL;DR: CompSCAN is a novel compiler bug isolation technique that analyzes compilation step sequences to identify bug-causing steps and rank suspicious code elements, outperforming state-of-the-art methods on real-world LLVM and GCC bugs.


<details>
  <summary>Details</summary>
Motivation: Compiler bugs are critical as they propagate to dependent software, but existing techniques lack causal analysis of internal compilation steps, limiting their effectiveness in isolating bugs.

Method: Three-stage process: (1) extract compilation steps leading to failure, (2) identify bug-causing steps and collect compiler code elements, (3) calculate suspicious scores and output ranked list.

Result: Evaluated on 185 real-world LLVM and GCC bugs, CompSCAN successfully isolated 50, 85, 100, and 123 bugs within Top-1/3/5/10 ranks respectively, achieving 24-50% improvements over ETEM and ODFL while running faster.

Conclusion: CompSCAN effectively isolates compiler bugs by analyzing compilation step sequences, demonstrating superior performance and efficiency compared to state-of-the-art techniques.

Abstract: Compilers are essential to software systems, and their bugs can propagate to
dependent software. Ensuring compiler correctness is critical. However,
isolating compiler bugs remains challenging due to the internal complexity of
compiler execution. Existing techniques primarily mutate compilation inputs to
generate passing and failing tests, but often lack causal analysis of internal
steps, limiting their effectiveness.
  To address this limitation, we propose CompSCAN, a novel compiler bug
isolation technique that applies analysis over the sequence of compilation
steps. CompSCAN follows a three-stage process: (1) extracting the array of
compilation steps that leads to the original failure, (2) identifying
bug-causing steps and collecting corresponding compiler code elements, and (3)
calculating suspicious scores for each code element and outputting a suspicious
ranking list as the bug isolation result.
  We evaluate CompSCAN on 185 real-world LLVM and GCC bugs. Results show that
CompSCAN outperforms state-of-the-art techniques in both effectiveness and
efficiency. CompSCAN successfully isolates 50, 85, 100, and 123 bugs within the
Top-1/3/5/10 ranks, respectively. Compared with ETEM and ODFL, two
state-of-the-art compiler bug isolation techniques, CompSCAN achieves relative
improvements of 44.51% / 50.18% / 36.24% / 24.49% over ETEM, and 31.58% /
49.12% / 44.93% / 21.78% over ODFL on those metrics. Moreover, CompSCAN runs
faster on average per bug than both baselines.

</details>


### [6] [GRACE: Globally-Seeded Representation-Aware Cluster-Specific Evolution for Compiler Auto-Tuning](https://arxiv.org/abs/2510.13176)
*Haolin Pan,Chao Zha,Jinyuan Dong,Mingjie Xing,Yanjun Wu*

Main category: cs.SE

TL;DR: GRACE is a compiler auto-tuning framework that uses pass synergies, contrastive learning, and evolutionary search to generate specialized pass sequences, achieving significant code size reduction with minimal tuning time.


<details>
  <summary>Details</summary>
Motivation: Standard compiler heuristics are suboptimal for program-specific optimization, while iterative compilation is too expensive and machine learning approaches struggle with generalization to unseen programs.

Method: GRACE leverages pass synergies to generate initial candidates, uses contrastive learning for program embeddings and clustering, performs evolutionary search to create a coreset of specialized sequences, and applies lightweight refinement at test time.

Result: GRACE reduces LLVM IR instruction count by an average of 10.09-10.19% compared to opt -Oz across seven datasets, with average tuning time under 1s per program.

Conclusion: GRACE demonstrates state-of-the-art performance in compiler auto-tuning, achieving significant code size optimization with practical efficiency and robust generalization to unseen programs.

Abstract: Compiler pass selection and phase ordering present a significant challenge in
achieving optimal program performance, particularly for objectives like code
size reduction. Standard compiler heuristics offer general applicability but
often yield suboptimal, program-specific results due to their one-size-fits-all
nature. While iterative compilation can find tailored solutions, its
prohibitive search cost limits practical use. Machine learning approaches
promise faster inference but frequently struggle with generalization to unseen
programs. This paper introduces GRACE, a novel framework for compiler
auto-tuning, demonstrated for LLVM IR instruction count optimization. GRACE
effectively curtails the search space by leveraging pass synergies and a
weighted scoring method to generate initial high-quality candidate sequences
and a pass pool. It then employs contrastive learning, using pass
sequence-based data augmentation, to create program embeddings that facilitate
similarity-aware clustering. Evolutionary search within these clusters yields a
coreset of $k$ specialized pass sequences designed for robust generalization to
unseen programs. At test time, GRACE efficiently selects the best coreset
sequence and refines it using lightweight techniques. Experimental results on
seven diverse datasets show that GRACE reduces LLVM IR instruction count by an
average of 10.09% on LLVM 10.0.0 and 10.19% on LLVM 18.1.6 compared to opt -Oz,
while incurring an average tuning time of less than 1s per program,
demonstrating its state-of-the-art performance and practical effectiveness.

</details>


### [7] [Synergy-Guided Compiler Auto-Tuning of Nested LLVM Pass Pipelines](https://arxiv.org/abs/2510.13184)
*Haolin Pan,Jinyuan Dong,Mingjie Xing,Yanjun Wu*

Main category: cs.SE

TL;DR: A new compiler auto-tuning framework designed specifically for LLVM's New Pass Manager that uses a formal grammar and forest-based representation to ensure syntactically valid optimization pipelines, achieving 13.62% better instruction count reduction than standard optimizations.


<details>
  <summary>Details</summary>
Motivation: Existing compiler auto-tuning approaches assume linear pass sequences, which misaligns with LLVM's hierarchical New Pass Manager design and cannot guarantee syntactically valid optimization pipelines.

Method: Uses a formal grammar to define valid nested pipelines, forest-based data structures for native representation, and a structure-aware Genetic Algorithm that manipulates forests directly to ensure validity. Includes synergistic pass mining and optional refinement for structural variations.

Result: Achieves average 13.62% additional instruction count reduction compared to standard opt -Oz optimization level across seven benchmark datasets using LLVM 18.1.6.

Conclusion: The framework successfully navigates the complex, constrained search space to identify valid and effective pass pipelines, demonstrating significant performance improvements over standard compiler optimizations.

Abstract: Compiler optimization relies on sequences of passes to improve program
performance. Selecting and ordering these passes automatically, known as
compiler auto-tuning, is challenging due to the large and complex search space.
Existing approaches generally assume a linear sequence of passes, a model
compatible with legacy compilers but fundamentally misaligned with the
hierarchical design of the LLVM New Pass Manager. This misalignment prevents
them from guaranteeing the generation of syntactically valid optimization
pipelines. In this work, we present a new auto-tuning framework built from the
ground up for the New Pass Manager. We introduce a formal grammar to define the
space of valid nested pipelines and a forest-based data structure for their
native representation. Upon this foundation, we develop a structure-aware
Genetic Algorithm whose operators manipulate these forests directly, ensuring
that all candidate solutions are valid by construction. The framework first
mines synergistic pass relationships to guide the search. An optional
refinement stage further explores subtle performance variations arising from
different valid structural arrangements.
  We evaluate our approach on seven benchmark datasets using LLVM 18.1.6. The
discovered pipelines achieve an average of 13.62% additional instruction count
reduction compared to the standard opt -Oz optimization level, showing that our
framework is capable of navigating this complex, constrained search space to
identify valid and effective pass pipelines.

</details>


### [8] [Towards Richer Challenge Problems for Scientific Computing Correctness](https://arxiv.org/abs/2510.13423)
*Matthew Sottile,Mohit Tekriwal,John Sarracino*

Main category: cs.SE

TL;DR: The paper calls for specialized challenge problems to bridge the gap between scientific computing and formal methods communities, proposing dimensions of correctness and guidelines for evaluating verification techniques in scientific computing.


<details>
  <summary>Details</summary>
Motivation: There is a lack of common understanding between scientific computing (SC) and formal methods/programming languages (FM/PL) communities regarding machine-verifiable correctness challenges, and existing verification techniques struggle with realistic SC applications.

Method: Proposes specialized challenge problems to inform development and evaluation of FM/PL verification techniques, augmenting existing general program verification approaches with SC-specific requirements.

Result: The paper identifies several dimensions of correctness relevant to scientific computing and discusses guidelines and criteria for designing appropriate challenge problems.

Conclusion: Specialized challenge problems are needed to ensure FM/PL verification techniques can effectively address the unique correctness requirements of scientific computing applications.

Abstract: Correctness in scientific computing (SC) is gaining increasing attention in
the formal methods (FM) and programming languages (PL) community. Existing
PL/FM verification techniques struggle with the complexities of realistic SC
applications. Part of the problem is a lack of a common understanding between
the SC and PL/FM communities of machine-verifiable correctness challenges and
dimensions of correctness in SC applications.
  To address this gap, we call for specialized challenge problems to inform the
development and evaluation of FM/PL verification techniques for correctness in
SC. These specialized challenges are intended to augment existing problems
studied by FM/PL researchers for general programs to ensure the needs of SC
applications can be met. We propose several dimensions of correctness relevant
to scientific computing, and discuss some guidelines and criteria for designing
challenge problems to evaluate correctness in scientific computing.

</details>


### [9] [Verifying a Sparse Matrix Algorithm Using Symbolic Execution](https://arxiv.org/abs/2510.13424)
*Alexander C. Wilton*

Main category: cs.SE

TL;DR: Using symbolic execution to test complex scientific software, specifically sparse matrix algorithms, providing stronger verification than traditional unit tests.


<details>
  <summary>Details</summary>
Motivation: Scientific software is complex, mathematical, and highly optimized, making it prone to subtle bugs that traditional testing methods may not easily detect.

Method: Applying symbolic execution to write tests similar to traditional unit tests, but with enhanced verification capabilities.

Result: The methodology was successfully applied to a sparse matrix algorithm, demonstrating its effectiveness in detecting subtle bugs.

Conclusion: Symbolic execution offers a powerful approach for testing scientific software, providing stronger verification guarantees compared to traditional unit testing methods.

Abstract: Scientific software is, by its very nature, complex. It is mathematical and
highly optimized which makes it prone to subtle bugs not as easily detected by
traditional testing. We outline how symbolic execution can be used to write
tests similar to traditional unit tests while providing stronger verification
guarantees and apply this methodology to a sparse matrix algorithm.

</details>


### [10] [OpenDerisk: An Industrial Framework for AI-Driven SRE, with Design, Implementation, and Case Studies](https://arxiv.org/abs/2510.13561)
*Peng Di,Faqiang Chen,Xiao Bai,Hongjun Yang,Qingfeng Li,Ganglin Wei,Jian Mou,Feng Shi,Keting Chen,Peng Tang,Zhitao Shen,Zheng Li,Wenhui Shi,Junwei Guo,Hang Yu*

Main category: cs.SE

TL;DR: OpenDerisk is a specialized multi-agent framework for Site Reliability Engineering that outperforms existing solutions in accuracy and efficiency, with proven scalability in large-scale production deployment.


<details>
  <summary>Details</summary>
Motivation: Modern software complexity creates unsustainable operational burden on SRE teams, requiring AI-driven automation that can emulate expert diagnostic reasoning, which existing solutions fail to provide.

Method: OpenDerisk integrates a diagnostic-native collaboration model, pluggable reasoning engine, knowledge engine, and standardized MCP protocol to enable specialist agents to solve complex multi-domain problems.

Result: Significantly outperforms state-of-the-art baselines in accuracy and efficiency, with successful large-scale deployment at Ant Group serving over 3,000 daily users across diverse scenarios.

Conclusion: OpenDerisk provides industrial-grade scalability and practical impact for SRE automation, addressing the gap in specialized diagnostic reasoning frameworks.

Abstract: The escalating complexity of modern software imposes an unsustainable
operational burden on Site Reliability Engineering (SRE) teams, demanding
AI-driven automation that can emulate expert diagnostic reasoning. Existing
solutions, from traditional AI methods to general-purpose multi-agent systems,
fall short: they either lack deep causal reasoning or are not tailored for the
specialized, investigative workflows unique to SRE. To address this gap, we
present OpenDerisk, a specialized, open-source multi-agent framework
architected for SRE. OpenDerisk integrates a diagnostic-native collaboration
model, a pluggable reasoning engine, a knowledge engine, and a standardized
protocol (MCP) to enable specialist agents to collectively solve complex,
multi-domain problems. Our comprehensive evaluation demonstrates that
OpenDerisk significantly outperforms state-of-the-art baselines in both
accuracy and efficiency. This effectiveness is validated by its large-scale
production deployment at Ant Group, where it serves over 3,000 daily users
across diverse scenarios, confirming its industrial-grade scalability and
practical impact. OpenDerisk is open source and available at
https://github.com/derisk-ai/OpenDerisk/

</details>


### [11] [Auto-repair without test cases: How LLMs fix compilation errors in large industrial embedded code](https://arxiv.org/abs/2510.13575)
*Han Fu,Sigrid Eldh,Kristian Wiklund,Andreas Ermedahl,Philipp Haller,Cyrille Artho*

Main category: cs.SE

TL;DR: LLM-driven automated repair can fix 63% of compilation errors in industrial embedded systems, with 83% of successful fixes being reasonable, and reduces debugging time from hours to under 8 minutes.


<details>
  <summary>Details</summary>
Motivation: Co-development of hardware and software in industrial embedded systems causes frequent compilation errors in CI, and existing repair techniques require test cases which are unavailable for non-compilable code.

Method: Employed LLM-driven automated repair approach, collected 40,000+ commits from product source code, and assessed performance of CI system enhanced by four state-of-the-art LLMs compared to manual human corrections.

Result: LLM-equipped CI systems resolved up to 63% of compilation errors, with 83% of successful fixes deemed reasonable, and significantly reduced debugging time to under 8 minutes vs hours for manual debugging.

Conclusion: LLM-driven automated repair is highly effective for fixing compilation errors in industrial embedded systems, providing substantial time savings and reasonable fix quality.

Abstract: The co-development of hardware and software in industrial embedded systems
frequently leads to compilation errors during continuous integration (CI).
Automated repair of such failures is promising, but existing techniques rely on
test cases, which are not available for non-compilable code.
  We employ an automated repair approach for compilation errors driven by large
language models (LLMs). Our study encompasses the collection of more than 40000
commits from the product's source code. We assess the performance of an
industrial CI system enhanced by four state-of-the-art LLMs, comparing their
outcomes with manual corrections provided by human programmers. LLM-equipped CI
systems can resolve up to 63 % of the compilation errors in our baseline
dataset. Among the fixes associated with successful CI builds, 83 % are deemed
reasonable. Moreover, LLMs significantly reduce debugging time, with the
majority of successful cases completed within 8 minutes, compared to hours
typically required for manual debugging.

</details>


### [12] [Property Testing for Ocean Models. Can We Specify It? (Invited Talk)](https://arxiv.org/abs/2510.13692)
*Deepak A. Cherian*

Main category: cs.SE

TL;DR: Applying property-testing concepts from computer science to ocean modeling by framing geophysical fluid dynamics theory as property tests to address the oracle problem in model verification.


<details>
  <summary>Details</summary>
Motivation: To explore how property-testing ideas from computer science can be applied to numerical ocean models, specifically using geophysical fluid dynamics theory to solve the oracle problem in testing model correctness.

Method: Proposing that simple idealized geophysical fluid dynamics problems can be framed as property tests, using physics to naturally specify these tests.

Result: The examples clearly demonstrate how physics lends itself to specifying property tests, though the feasibility and usefulness of specific tests remain to be determined.

Conclusion: Property testing concepts show promise for ocean model verification by leveraging geophysical fluid dynamics theory, but further investigation is needed to identify the most practical and valuable applications.

Abstract: I take inspiration from the property-testing literature, particularly the
work of Prof. John Hughes, and explore how such ideas might be applied to
numerical models of the ocean. Specifically, I ask whether geophysical fluid
dynamics (GFD) theory, expressed as property tests, might be used to address
the oracle problem of testing the correctness of ocean models. I propose that a
number of simple idealized GFD problems can be framed as property tests. These
examples clearly illustrate how physics naturally lends itself to specifying
property tests. Which of these proposed tests might be most feasible and
useful, remains to be seen.

</details>


### [13] [On Pretraining for Project-Level Code Completion](https://arxiv.org/abs/2510.13697)
*Maksim Sapronov,Evgeniy Glukhov*

Main category: cs.SE

TL;DR: Repository-level pretraining enhances code completion by using codebase-wide context. OpenCoder, a 1.5B-parameter model, achieves comparable performance with smaller datasets by extending context windows and using RoPE scaling.


<details>
  <summary>Details</summary>
Motivation: To improve code completion accuracy by leveraging repository-level context and investigate how different repository-processing strategies affect in-context learning.

Method: Extended context window from 4,096 to 16,384 tokens by training on 1B tokens of curated repository-level data. Used rotary positional embedding (RoPE) scaling and compared various repository-processing techniques.

Result: Achieved comparable performance on Long Code Arena benchmark despite using smaller dataset than competitors. Found that repository-processing techniques yield similar results, with main gains from RoPE scaling adaptation.

Conclusion: Simpler file-level training at original sequence length remains effective, making repository-level code completion research accessible to settings with constrained data and compute resources.

Abstract: Repository-level pretraining is commonly used to enable large language models
for code to leverage codebase-wide context. This enhances their ability to
generate accurate and context-aware code completions. In this work, we
investigate how different repository-processing strategies affect in-context
learning in OpenCoder, a 1.5B-parameter model. We extend its context window
from 4,096 to 16,384 tokens by training on additional 1B tokens of curated
repository-level data. Despite relying on a smaller dataset than competing
models (which often use hundreds of billions of tokens), our model achieves
comparable performance on the Long Code Arena benchmark. We find that various
repository-processing techniques yield similarly strong results, with the
primary gain coming from adapting to a new rotary positional embedding (RoPE)
scaling parameter. Finally, we show that a simpler file-level training approach
at the original sequence length remains highly effective, opening up
repository-level code completion research to settings with more constrained
data and compute resources.

</details>
