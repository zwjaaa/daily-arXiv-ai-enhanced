{"id": "2509.18337", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18337", "abs": "https://arxiv.org/abs/2509.18337", "authors": ["Bo Xiong", "Linghao Zhang", "Chong Wang", "Peng Liang"], "title": "CoRaCMG: Contextual Retrieval-Augmented Framework for Commit Message Generation", "comment": "15 pages, 4 images, 6 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "Commit messages play a key role in documenting the intent behind code\nchanges. However, they are often low-quality, vague, or incomplete, limiting\ntheir usefulness. Commit Message Generation (CMG) aims to automatically\ngenerate descriptive commit messages from code diffs to reduce developers'\neffort and improve message quality. Although recent advances in LLMs have shown\npromise in automating CMG, their performance remains limited. This paper aims\nto enhance CMG performance by retrieving similar diff-message pairs to guide\nLLMs to generate commit messages that are more precise and informative. We\nproposed CoRaCMG, a Contextual Retrieval-augmented framework for Commit Message\nGeneration, structured in three phases: (1) Retrieve: retrieving the similar\ndiff-message pairs; (2) Augment: combining them with the query diff into a\nstructured prompt; and (3) Generate: generating commit messages corresponding\nto the query diff via LLMs. CoRaCMG enables LLMs to learn project-specific\nterminologies and writing styles from the retrieved diff-message pairs, thereby\nproducing high-quality commit messages. We evaluated our method on various\nLLMs, including closed-source GPT models and open-source DeepSeek models.\nExperimental results show that CoRaCMG significantly boosts LLM performance\nacross four metrics (BLEU, Rouge-L, METEOR, and CIDEr). Specifically,\nDeepSeek-R1 achieves relative improvements of 76% in BLEU and 71% in CIDEr when\naugmented with a single retrieved example pair. After incorporating the single\nexample pair, GPT-4o achieves the highest improvement rate, with BLEU\nincreasing by 89%. Moreover, performance gains plateau after more than three\nexamples are used, indicating diminishing returns. Further analysis shows that\nthe improvements are attributed to the model's ability to capture the\nterminologies and writing styles of human-written commit messages from the\nretrieved example pairs.", "AI": {"tldr": "CoRaCMG is a retrieval-augmented framework that enhances commit message generation by using similar diff-message pairs to guide LLMs, achieving significant performance improvements across multiple metrics.", "motivation": "Commit messages are often low-quality and incomplete, limiting their usefulness. While LLMs show promise in automating commit message generation, their performance remains limited and needs enhancement.", "method": "CoRaCMG uses a three-phase approach: (1) Retrieve similar diff-message pairs, (2) Augment by combining them with query diff into structured prompts, (3) Generate commit messages via LLMs. This helps LLMs learn project-specific terminologies and writing styles.", "result": "CoRaCMG significantly boosts LLM performance across BLEU, Rouge-L, METEOR, and CIDEr metrics. DeepSeek-R1 achieved 76% BLEU and 71% CIDEr improvements with single example. GPT-4o showed 89% BLEU improvement. Performance plateaus after 3 examples.", "conclusion": "The framework effectively enhances commit message generation by enabling LLMs to capture human-written message patterns from retrieved examples, with diminishing returns beyond 3 examples."}}
{"id": "2509.18361", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.18361", "abs": "https://arxiv.org/abs/2509.18361", "authors": ["Daye Nam", "Malgorzata Salawa", "Satish Chandra"], "title": "Reading Between the Lines: Scalable User Feedback via Implicit Sentiment in Developer Prompts", "comment": null, "summary": "Evaluating developer satisfaction with conversational AI assistants at scale\nis critical but challenging. User studies provide rich insights, but are\nunscalable, while large-scale quantitative signals from logs or in-product\nratings are often too shallow or sparse to be reliable. To address this gap, we\npropose and evaluate a new approach: using sentiment analysis of developer\nprompts to identify implicit signals of user satisfaction. With an analysis of\nindustrial usage logs of 372 professional developers, we show that this\napproach can identify a signal in ~8% of all interactions, a rate more than 13\ntimes higher than explicit user feedback, with reasonable accuracy even with an\noff-the-shelf sentiment analysis approach. This new practical approach to\ncomplement existing feedback channels would open up new directions for building\na more comprehensive understanding of the developer experience at scale.", "AI": {"tldr": "The paper proposes using sentiment analysis of developer prompts as a scalable method to evaluate developer satisfaction with conversational AI assistants, showing it can capture implicit feedback 13x more frequently than explicit ratings.", "motivation": "Traditional user studies are unscalable for evaluating developer satisfaction with AI assistants, while large-scale quantitative signals like logs or ratings are often too shallow or sparse to be reliable.", "method": "The authors analyzed industrial usage logs of 372 professional developers and applied sentiment analysis to developer prompts to identify implicit signals of user satisfaction.", "result": "The approach identified satisfaction signals in ~8% of all interactions, which is more than 13 times higher than explicit user feedback rates, with reasonable accuracy using off-the-shelf sentiment analysis.", "conclusion": "Sentiment analysis of developer prompts provides a practical, scalable approach to complement existing feedback channels for understanding developer experience with AI assistants at scale."}}
{"id": "2509.18454", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18454", "abs": "https://arxiv.org/abs/2509.18454", "authors": ["Andrzej Bia\u0142ecki", "Piotr Bia\u0142ecki", "Piotr Sowi\u0144ski", "Mateusz Budziak", "Jan Gajewski"], "title": "SC2Tools: StarCraft II Toolset and Dataset API", "comment": null, "summary": "Computer games, as fully controlled simulated environments, have been\nutilized in significant scientific studies demonstrating the application of\nReinforcement Learning (RL). Gaming and esports are key areas influenced by the\napplication of Artificial Intelligence (AI) and Machine Learning (ML) solutions\nat scale. Tooling simplifies scientific workloads and is essential for\ndeveloping the gaming and esports research area.\n  In this work, we present ``SC2Tools'', a toolset containing multiple\nsubmodules responsible for working with, and producing larger datasets. We\nprovide a modular structure of the implemented tooling, leaving room for future\nextensions where needed. Additionally, some of the tools are not StarCraft~2\nexclusive and can be used with other types of data for dataset creation.\n  The tools we present were leveraged in creating one of the largest\nStarCraft~2 tournament datasets to date with a separate PyTorch and PyTorch\nLightning application programming interface (API) for easy access to the data.\n  We conclude that alleviating the burden of data collection, preprocessing,\nand custom code development is essential for less technically proficient\nresearchers to engage in the growing gaming and esports research area. Finally,\nour solution provides some foundational work toward normalizing experiment\nworkflow in StarCraft~2", "AI": {"tldr": "SC2Tools is a modular toolset for creating and working with large datasets, particularly for StarCraft 2 research, designed to simplify data collection and preprocessing for gaming and esports studies.", "motivation": "To address the need for simplified scientific workloads and tooling in gaming and esports research, making it easier for less technically proficient researchers to engage in AI/ML applications in this domain.", "method": "Developed a modular toolset called SC2Tools with multiple submodules for dataset creation and processing, including PyTorch and PyTorch Lightning APIs for easy data access.", "result": "Created one of the largest StarCraft 2 tournament datasets to date, with tools that can also be used with other types of data beyond StarCraft 2.", "conclusion": "Alleviating data collection and preprocessing burdens is essential for broader researcher engagement in gaming/esports research, and SC2Tools provides foundational work toward normalizing experiment workflows in StarCraft 2."}}
{"id": "2509.18548", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18548", "abs": "https://arxiv.org/abs/2509.18548", "authors": ["Steven R Brandt", "Max Morris", "Patrick Diehl", "Christopher Bowen", "Jacob Tucker", "Lauren Bristol", "Golden G. Richard III"], "title": "Locking Down Science Gateways", "comment": null, "summary": "The most recent Linux kernels have a new feature for securing applications:\nLandlock. Like Seccomp before it, Landlock makes it possible for a running\nprocess to give up access to resources. For applications running as Science\nGateways, network access is required while starting up MPI, but for the sake of\nsecurity, it should be taken away prior to the reading of user-supplied\nparameter files. We explore the usefulness of Landlock by modifying and locking\ndown three mature scientific codes: The Einstein Toolkit (a code that studies\nthe dynamics of relativistic astrophysics, e.g. neutron star collisions),\nOcto-Tiger (a code for studying the dynamics of non-relativistic astrophysics,\ne.g. white dwarfs), and FUKA (an initial data solver for relativistic codes).\nFinally, we implement a fully-functioning FUKA science gateway that relies on\nLandlock (instead of user authentication) for security.", "AI": {"tldr": "This paper explores the use of Landlock, a new Linux kernel security feature, to secure scientific applications by removing network access after MPI initialization but before processing user inputs.", "motivation": "Science Gateways require network access during MPI startup but need to restrict access for security before handling user-supplied parameter files. Landlock provides a way to dynamically revoke resource access for running processes.", "method": "The researchers modified three mature scientific codes (Einstein Toolkit, Octo-Tiger, FUKA) to implement Landlock restrictions and created a fully-functioning FUKA science gateway that uses Landlock instead of traditional user authentication for security.", "result": "The study demonstrates successful implementation of Landlock in scientific applications, showing that it can effectively secure processes by removing unnecessary network access after required initialization phases.", "conclusion": "Landlock proves to be a useful security feature for scientific applications, enabling dynamic access control that enhances security without compromising functionality, particularly for Science Gateways handling sensitive user inputs."}}
{"id": "2509.18808", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18808", "abs": "https://arxiv.org/abs/2509.18808", "authors": ["Zexun Zhan", "Shuzheng Gao", "Ruida Hu", "Cuiyun Gao"], "title": "SR-Eval: Evaluating LLMs on Code Generation under Stepwise Requirement Refinement", "comment": null, "summary": "Large language models (LLMs) have achieved remarkable progress in code\ngeneration. However, existing benchmarks mainly formalize the task as a static,\nsingle-turn problem, overlooking the stepwise requirement changes and iterative\nworkflows in real-world software development. This mismatch limits the\nunderstanding of how well LLMs can support real-world development workflows.\nConstructing such iterative benchmarks is challenging due to the lack of public\ninteraction traces and the difficulty of creating discriminative, turn-specific\ntest cases.\n  To bridge this gap, we present SR-Eval, a benchmark specifically designed to\nassess LLMs on iterative code generation under Stepwise requirements\nRefinement. SR-Eval spans both function-level and repository-level tasks in\nPython and Java, enabling fine-grained and progressive evaluation across\nevolving requirements. The construction of SR-Eval follows a carefully designed\npipeline that first leverages a multi-agent-based requirement generation method\nto simulate the development process and recover the multi-round interaction\nprocess from final requirements, then employs a semantic-aware discriminative\ntest case generation component to ensure discriminative and consistent\nevaluation at each turn. SR-Eval comprises 443 multi-turn tasks and 1,857\nquestions at both function and repository levels. Using SR-Eval, we evaluate 11\nrepresentative LLMs with three prompting strategies that simulate different\nusage patterns. Results show that iterative code generation under stepwise\nrequirement refinement remains highly challenging: the best-performing model\nachieves only 22.67% completion rate on function-level tasks and 20.00% on\nrepository-level tasks. We further observe that prompting strategies\nsubstantially influence performance, highlighting the need for the development\nof advanced methods.", "AI": {"tldr": "SR-Eval is a benchmark for evaluating LLMs on iterative code generation under stepwise requirement refinement, addressing the gap in existing static benchmarks by simulating real-world development workflows.", "motivation": "Existing code generation benchmarks are static and single-turn, failing to capture the iterative nature of real-world software development with evolving requirements, limiting understanding of LLMs' practical utility.", "method": "SR-Eval uses a multi-agent-based requirement generation method to simulate development processes and recover multi-round interactions from final requirements, with semantic-aware discriminative test cases for consistent evaluation across 443 multi-turn tasks.", "result": "Evaluation of 11 LLMs shows iterative code generation remains highly challenging - best model achieves only 22.67% completion on function-level and 20.00% on repository-level tasks, with performance significantly influenced by prompting strategies.", "conclusion": "Iterative code generation under stepwise requirement refinement is a difficult task for current LLMs, highlighting the need for advanced methods and better prompting strategies to support real-world development workflows."}}
{"id": "2509.19136", "categories": ["cs.SE", "cs.AI", "D.2.4; D.2.5; F.3.1"], "pdf": "https://arxiv.org/pdf/2509.19136", "abs": "https://arxiv.org/abs/2509.19136", "authors": ["S\u00e9bastien Salva", "Redha Taguelmimt"], "title": "On the Soundness and Consistency of LLM Agents for Executing Test Cases Written in Natural Language", "comment": null, "summary": "The use of natural language (NL) test cases for validating graphical user\ninterface (GUI) applications is emerging as a promising direction to manually\nwritten executable test scripts, which are costly to develop and difficult to\nmaintain. Recent advances in large language models (LLMs) have opened the\npossibility of the direct execution of NL test cases by LLM agents. This paper\ninvestigates this direction, focusing on the impact on NL test case unsoundness\nand on test case execution consistency. NL test cases are inherently unsound,\nas they may yield false failures due to ambiguous instructions or unpredictable\nagent behaviour. Furthermore, repeated executions of the same NL test case may\nlead to inconsistent outcomes, undermining test reliability. To address these\nchallenges, we propose an algorithm for executing NL test cases with guardrail\nmechanisms and specialised agents that dynamically verify the correct execution\nof each test step. We introduce measures to evaluate the capabilities of LLMs\nin test execution and one measure to quantify execution consistency. We propose\na definition of weak unsoundness to characterise contexts in which NL test case\nexecution remains acceptable, with respect to the industrial quality levels Six\nSigma. Our experimental evaluation with eight publicly available LLMs, ranging\nfrom 3B to 70B parameters, demonstrates both the potential and current\nlimitations of current LLM agents for GUI testing. Our experiments show that\nMeta Llama 3.1 70B demonstrates acceptable capabilities in NL test case\nexecution with high execution consistency (above the level 3-sigma). We provide\nprototype tools, test suites, and results.", "AI": {"tldr": "This paper investigates using LLM agents to execute natural language test cases for GUI applications, addressing challenges of unsoundness and inconsistency through guardrail mechanisms and specialized agents.", "motivation": "Natural language test cases are emerging as an alternative to manual test scripts, but they face issues with unsoundness (false failures) and inconsistent execution outcomes when using LLM agents.", "method": "Proposed algorithm with guardrail mechanisms and specialized agents that dynamically verify each test step execution. Introduced evaluation measures for LLM capabilities and execution consistency, and defined weak unsoundness concept.", "result": "Experimental evaluation with 8 LLMs (3B-70B parameters) showed Meta Llama 3.1 70B achieves acceptable NL test execution capabilities with high consistency (above 3-sigma level).", "conclusion": "LLM agents show potential for GUI testing but have current limitations; the proposed approach addresses key challenges and demonstrates feasibility with certain LLM models."}}
{"id": "2509.19185", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.19185", "abs": "https://arxiv.org/abs/2509.19185", "authors": ["Mohammed Mehedi Hasan", "Hao Li", "Emad Fallahzadeh", "Gopi Krishnan Rajbahadur", "Bram Adams", "Ahmed E. Hassan"], "title": "An Empirical Study of Testing Practices in Open Source AI Agent Frameworks and Agentic Applications", "comment": null, "summary": "Foundation model (FM)-based AI agents are rapidly gaining adoption across\ndiverse domains, but their inherent non-determinism and non-reproducibility\npose testing and quality assurance challenges. While recent benchmarks provide\ntask-level evaluations, there is limited understanding of how developers verify\nthe internal correctness of these agents during development.\n  To address this gap, we conduct the first large-scale empirical study of\ntesting practices in the AI agent ecosystem, analyzing 39 open-source agent\nframeworks and 439 agentic applications. We identify ten distinct testing\npatterns and find that novel, agent-specific methods like DeepEval are seldom\nused (around 1%), while traditional patterns like negative and membership\ntesting are widely adapted to manage FM uncertainty. By mapping these patterns\nto canonical architectural components of agent frameworks and agentic\napplications, we uncover a fundamental inversion of testing effort:\ndeterministic components like Resource Artifacts (tools) and Coordination\nArtifacts (workflows) consume over 70% of testing effort, while the FM-based\nPlan Body receives less than 5%. Crucially, this reveals a critical blind spot,\nas the Trigger component (prompts) remains neglected, appearing in around 1% of\nall tests.\n  Our findings offer the first empirical testing baseline in FM-based agent\nframeworks and agentic applications, revealing a rational but incomplete\nadaptation to non-determinism. To address it, framework developers should\nimprove support for novel testing methods, application developers must adopt\nprompt regression testing, and researchers should explore barriers to adoption.\nStrengthening these practices is vital for building more robust and dependable\nAI agents.", "AI": {"tldr": "This paper presents the first large-scale empirical study of testing practices in AI agent ecosystems, revealing that traditional testing methods dominate while novel agent-specific testing is rare, and identifies a critical blind spot in prompt testing.", "motivation": "Foundation model-based AI agents face testing challenges due to non-determinism and non-reproducibility, but there's limited understanding of how developers verify internal correctness during development.", "method": "Conducted empirical study analyzing 39 open-source agent frameworks and 439 agentic applications to identify testing patterns and map them to architectural components.", "result": "Found that traditional testing patterns dominate (70% effort on deterministic components), while FM-based components receive minimal testing (<5%), with prompts being particularly neglected (1% of tests).", "conclusion": "Framework developers should improve support for novel testing methods, application developers must adopt prompt regression testing, and researchers should explore adoption barriers to build more robust AI agents."}}
