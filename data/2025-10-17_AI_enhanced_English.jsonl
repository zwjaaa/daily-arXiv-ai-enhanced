{"id": "2510.13857", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.13857", "abs": "https://arxiv.org/abs/2510.13857", "authors": ["Qiang Xu", "Xiangyu Wen", "Changran Xu", "Zeju Li", "Jianyuan Zhong"], "title": "From Craft to Constitution: A Governance-First Paradigm for Principled Agent Engineering", "comment": null, "summary": "The advent of powerful Large Language Models (LLMs) has ushered in an ``Age\nof the Agent,'' enabling autonomous systems to tackle complex goals. However,\nthe transition from prototype to production is hindered by a pervasive ``crisis\nof craft,'' resulting in agents that are brittle, unpredictable, and ultimately\nuntrustworthy in mission-critical applications. This paper argues this crisis\nstems from a fundamental paradigm mismatch -- attempting to command inherently\nprobabilistic processors with the deterministic mental models of traditional\nsoftware engineering. To solve this crisis, we introduce a governance-first\nparadigm for principled agent engineering, embodied in a formal architecture we\ncall ArbiterOS.", "AI": {"tldr": "The paper introduces ArbiterOS, a governance-first paradigm for principled agent engineering to address the brittleness and unpredictability of LLM-based autonomous systems in production.", "motivation": "The transition from prototype to production for LLM-based agents is hindered by a 'crisis of craft' - agents are brittle, unpredictable, and untrustworthy in mission-critical applications due to a paradigm mismatch between probabilistic processors and deterministic software engineering models.", "method": "Introduces a governance-first paradigm embodied in a formal architecture called ArbiterOS, which provides principled agent engineering to address the fundamental paradigm mismatch.", "result": "The paper proposes ArbiterOS as a solution to the crisis of craft in LLM-based agent systems, though specific implementation results are not detailed in the abstract.", "conclusion": "A governance-first approach through formal architectures like ArbiterOS is needed to overcome the paradigm mismatch and enable trustworthy deployment of LLM-based agents in production environments."}}
{"id": "2510.13859", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.13859", "abs": "https://arxiv.org/abs/2510.13859", "authors": ["Ruchit Rawal", "Jeffrey Yang Fan Chiang", "Chihao Shen", "Jeffery Siyuan Tian", "Aastha Mahajan", "Tom Goldstein", "Yizheng Chen"], "title": "Benchmarking Correctness and Security in Multi-Turn Code Generation", "comment": null, "summary": "AI coding assistants powered by large language models (LLMs) have transformed\nsoftware development, significantly boosting productivity. While existing\nbenchmarks evaluate the correctness and security of LLM-generated code, they\nare typically limited to single-turn tasks that do not reflect the iterative\nnature of real-world development. We introduce MT-Sec, the first benchmark to\nsystematically evaluate both correctness and security in multi-turn coding\nscenarios. We construct this using a synthetic data pipeline that transforms\nexisting single-turn tasks into semantically aligned multi-turn interaction\nsequences, allowing reuse of original test suites while modeling the complexity\nof real-world coding processes. We evaluate 32 open- and closed-source models,\nand three agent-scaffolding on MT-Sec and observe a consistent 20-27% drop in\n\"correct and secure\" outputs from single-turn to multi-turn settings -- even\namong state-of-the-art models. Beyond full-program generation, we also evaluate\nmodels on multi-turn code-diff generation -- an unexplored yet practically\nrelevant setting -- and find that models perform worse here, with increased\nrates of functionally incorrect and insecure outputs. Finally, we find that\nwhile agent scaffoldings boost single-turn code generation performance, they\nare not quite as effective in multi-turn evaluations. Together, these findings\nhighlight the need for benchmarks that jointly evaluate correctness and\nsecurity in multi-turn, real-world coding workflows.", "AI": {"tldr": "MT-Sec is the first benchmark for evaluating both correctness and security in multi-turn coding scenarios, showing significant performance drops compared to single-turn tasks.", "motivation": "Existing benchmarks only evaluate single-turn code generation, which doesn't reflect the iterative nature of real-world software development where developers work through multiple rounds of feedback and refinement.", "method": "Created a synthetic data pipeline that transforms existing single-turn tasks into semantically aligned multi-turn interaction sequences, allowing reuse of original test suites while modeling real-world coding complexity.", "result": "Evaluation of 32 models showed consistent 20-27% drop in 'correct and secure' outputs from single-turn to multi-turn settings. Models performed worse on multi-turn code-diff generation with increased rates of functionally incorrect and insecure outputs. Agent scaffoldings were less effective in multi-turn evaluations.", "conclusion": "There's a critical need for benchmarks that jointly evaluate correctness and security in multi-turn, real-world coding workflows, as current models struggle significantly with iterative development processes."}}
{"id": "2510.13914", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.13914", "abs": "https://arxiv.org/abs/2510.13914", "authors": ["Janghan Yoon", "Jaegwan Cho", "Junhyeok Kim", "Jiwan Chung", "Jaehyun Jeon", "Youngjae Yu"], "title": "A11YN: aligning LLMs for accessible web UI code generation", "comment": null, "summary": "Large language models (LLMs) have recently demonstrated strong capabilities\nin generating functional and aesthetic web interfaces directly from\ninstructions. However, these models often replicate accessibility flaws from\ntheir training data, resulting in interfaces that exclude users with diverse\nneeds and contexts. To address this gap, we introduce A11yn, the first method\nthat aligns code-generating LLMs to reliably produce accessibility-compliant\nweb UIs. A11yn optimizes a novel reward function that penalizes violations of\nthe Web Content Accessibility Guidelines (WCAG), with penalties scaled to the\nseverity of each violation as identified by an accessibility testing engine. To\nsupport training, we construct UIReq-6.8K, a dataset of 6,800 diverse\ninstructions for web UI generation. For evaluation, we introduce RealUIReq-300,\na benchmark of 300 real-world web UI requests grounded and manually curated\nfrom public web pages, spanning a broad range of use cases. Empirical results\nshow that A11yn significantly outperforms strong baselines, lowering the\nInaccessibility Rate by 60% over the base model while preserving semantic\nfidelity and visual quality of generated UIs. These findings demonstrate that\naccessibility can be systematically optimized within LLMs, showing the\nfeasibility of aligning code generation for accessibility.", "AI": {"tldr": "A11yn is a method that aligns code-generating LLMs to produce accessibility-compliant web UIs by optimizing a reward function based on WCAG violations.", "motivation": "LLMs often replicate accessibility flaws from training data, creating interfaces that exclude users with diverse needs and contexts.", "method": "A11yn optimizes a novel reward function that penalizes WCAG violations scaled by severity, using UIReq-6.8K dataset for training and RealUIReq-300 benchmark for evaluation.", "result": "A11yn lowers the Inaccessibility Rate by 60% over the base model while preserving semantic fidelity and visual quality of generated UIs.", "conclusion": "Accessibility can be systematically optimized within LLMs, demonstrating feasibility of aligning code generation for accessibility."}}
{"id": "2510.13992", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.13992", "abs": "https://arxiv.org/abs/2510.13992", "authors": ["Quoc Hung Le", "Thanh Le-Cong", "Bach Le", "Bowen Xu"], "title": "Signature in Code Backdoor Detection, how far are we?", "comment": "20 pages, 3 figures", "summary": "As Large Language Models (LLMs) become increasingly integrated into software\ndevelopment workflows, they also become prime targets for adversarial attacks.\nAmong these, backdoor attacks are a significant threat, allowing attackers to\nmanipulate model outputs through hidden triggers embedded in training data.\nDetecting such backdoors remains a challenge, and one promising approach is the\nuse of Spectral Signature defense methods that identify poisoned data by\nanalyzing feature representations through eigenvectors. While some prior works\nhave explored Spectral Signatures for backdoor detection in neural networks,\nrecent studies suggest that these methods may not be optimally effective for\ncode models. In this paper, we revisit the applicability of Spectral\nSignature-based defenses in the context of backdoor attacks on code models. We\nsystematically evaluate their effectiveness under various attack scenarios and\ndefense configurations, analyzing their strengths and limitations. We found\nthat the widely used setting of Spectral Signature in code backdoor detection\nis often suboptimal. Hence, we explored the impact of different settings of the\nkey factors. We discovered a new proxy metric that can more accurately estimate\nthe actual performance of Spectral Signature without model retraining after the\ndefense.", "AI": {"tldr": "Spectral Signature defense methods for detecting backdoor attacks in code LLMs are often suboptimal, and a new proxy metric is proposed to better estimate their performance without model retraining.", "motivation": "As LLMs are increasingly used in software development, they become targets for backdoor attacks. Existing Spectral Signature defenses may not work well for code models, requiring better evaluation and optimization.", "method": "Systematically evaluate Spectral Signature defenses under various attack scenarios and defense configurations for code models, exploring different settings of key factors and discovering a new proxy metric.", "result": "Found that widely used Spectral Signature settings in code backdoor detection are often suboptimal. Identified a new proxy metric that can more accurately estimate defense performance without requiring model retraining.", "conclusion": "Spectral Signature defenses need optimization for code models, and the proposed proxy metric provides better performance estimation without the computational cost of retraining."}}
{"id": "2510.14036", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.14036", "abs": "https://arxiv.org/abs/2510.14036", "authors": ["Qiushi Wu", "Yue Xiao", "Dhilung Kirat", "Kevin Eykholt", "Jiyong Jang", "Douglas Lee Schales"], "title": "One Bug, Hundreds Behind: LLMs for Large-Scale Bug Discovery", "comment": null, "summary": "Fixing bugs in large programs is a challenging task that demands substantial\ntime and effort. Once a bug is found, it is reported to the project\nmaintainers, who work with the reporter to fix it and eventually close the\nissue. However, across the program, there are often similar code segments,\nwhich may also contain the bug, but were missed during discovery. Finding and\nfixing each recurring bug instance individually is labor intensive. Even more\nconcerning, bug reports can inadvertently widen the attack surface as they\nprovide attackers with an exploitable pattern that may be unresolved in other\nparts of the program.\n  In this paper, we explore these Recurring Pattern Bugs (RPBs) that appear\nrepeatedly across various code segments of a program or even in different\nprograms, stemming from a same root cause, but are unresolved. Our\ninvestigation reveals that RPBs are widespread and can significantly compromise\nthe security of software programs. This paper introduces BugStone, a program\nanalysis system empowered by LLVM and a Large Language Model (LLM). The key\nobservation is that many RPBs have one patched instance, which can be leveraged\nto identify a consistent error pattern, such as a specific API misuse. By\nexamining the entire program for this pattern, it is possible to identify\nsimilar sections of code that may be vulnerable. Starting with 135 unique RPBs,\nBugStone identified more than 22K new potential issues in the Linux kernel.\nManual analysis of 400 of these findings confirmed that 246 were valid. We also\ncreated a dataset from over 1.9K security bugs reported by 23 recent top-tier\nconference works. We manually annotate the dataset, identify 80 recurring\npatterns and 850 corresponding fixes. Even with a cost-efficient model choice,\nBugStone achieved 92.2% precision and 79.1% pairwise accuracy on the dataset.", "AI": {"tldr": "BugStone is a program analysis system that uses LLVM and LLMs to identify Recurring Pattern Bugs (RPBs) across codebases, achieving high precision in detecting similar vulnerabilities from known bug patterns.", "motivation": "Fixing individual bugs is labor-intensive, and bug reports can inadvertently expose exploitable patterns that remain unresolved in other code segments, widening the attack surface.", "method": "Leverages LLVM and Large Language Models to identify consistent error patterns from patched bug instances, then scans the entire program for similar vulnerable code sections.", "result": "Identified over 22K potential issues in Linux kernel from 135 unique RPBs, with 246 confirmed valid out of 400 manually analyzed. Achieved 92.2% precision and 79.1% pairwise accuracy on a dataset of 1.9K security bugs.", "conclusion": "RPBs are widespread and significantly compromise software security. BugStone effectively identifies and helps fix these recurring patterns at scale with high accuracy."}}
{"id": "2510.14115", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.14115", "abs": "https://arxiv.org/abs/2510.14115", "authors": ["Philipp Bauerfeind", "Amir Salarpour", "David Fernandez", "Pedram MohajerAnsari", "Johannes Reschke", "Mert D. Pes\u00e9"], "title": "David vs. Goliath: A comparative study of different-sized LLMs for code generation in the domain of automotive scenario generation", "comment": null, "summary": "Scenario simulation is central to testing autonomous driving systems. Scenic,\na domain-specific language (DSL) for CARLA, enables precise and reproducible\nscenarios, but NL-to-Scenic generation with large language models (LLMs)\nsuffers from scarce data, limited reproducibility, and inconsistent metrics. We\nintroduce NL2Scenic, an open dataset and framework with 146 NL/Scenic pairs, a\ndifficulty-stratified 30-case test split, an Example Retriever, and 14\nprompting variants (ZS, FS, CoT, SP, MoT). We evaluate 13 models: four\nproprietary (GPT-4o, GPT-5, Claude-Sonnet-4, Gemini-2.5-pro) and nine\nopen-source code models (Qwen2.5Coder 0.5B-32B; CodeLlama 7B/13B/34B), using\ntext metrics (BLEU, ChrF, EDIT-SIM, CrystalBLEU) and execution metrics\n(compilation and generation), and compare them with an expert study (n=11).\nEDIT-SIM correlates best with human judgments; we also propose EDIT-COMP (F1 of\nEDIT-SIM and compilation) as a robust dataset-level proxy that improves ranking\nfidelity. GPT-4o performs best overall, while Qwen2.5Coder-14B reaches about 88\npercent of its expert score on local hardware. Retrieval-augmented prompting,\nFew-Shot with Example Retriever (FSER), consistently boosts smaller models, and\nscaling shows diminishing returns beyond mid-size, with Qwen2.5Coder\noutperforming CodeLlama at comparable scales. NL2Scenic and EDIT-COMP offer a\nstandardized, reproducible basis for evaluating Scenic code generation and\nindicate that mid-size open-source models are practical, cost-effective options\nfor autonomous-driving scenario programming.", "AI": {"tldr": "NL2Scenic is a dataset and framework for converting natural language to Scenic code for autonomous driving scenarios, addressing data scarcity and evaluation issues in NL-to-Scenic generation.", "motivation": "Current NL-to-Scenic generation with LLMs suffers from scarce data, limited reproducibility, and inconsistent metrics, making it difficult to reliably test autonomous driving systems.", "method": "Created NL2Scenic dataset with 146 NL/Scenic pairs and 30-case test split, developed Example Retriever and 14 prompting variants, evaluated 13 models using text and execution metrics plus expert study.", "result": "GPT-4o performs best overall, Qwen2.5Coder-14B reaches 88% of expert score, EDIT-SIM correlates best with human judgments, and retrieval-augmented prompting boosts smaller models.", "conclusion": "NL2Scenic and EDIT-COMP provide standardized evaluation for Scenic code generation, showing mid-size open-source models are practical, cost-effective options for autonomous driving scenario programming."}}
{"id": "2510.14279", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2510.14279", "abs": "https://arxiv.org/abs/2510.14279", "authors": ["Evangelos Lamprou", "Seong-Heon Jung", "Mayank Keoliya", "Lukas Lazarek", "Konstantinos Kallas", "Michael Greenberg", "Nikos Vasilakis"], "title": "Caruca: Effective and Efficient Specification Mining for Opaque Software Components", "comment": null, "summary": "A wealth of state-of-the-art systems demonstrate impressive improvements in\nperformance, security, and reliability on programs composed of opaque\ncomponents, such as Unix shell commands. To reason about commands, these\nsystems require partial specifications. However, creating such specifications\nis a manual, laborious, and error-prone process, limiting the practicality of\nthese systems. This paper presents Caruca, a system for automatic specification\nmining for opaque commands. To overcome the challenge of language diversity\nacross commands, Caruca first instruments a large language model to translate a\ncommand's user-facing documentation into a structured invocation syntax. Using\nthis representation, Caruca explores the space of syntactically valid command\ninvocations and execution environments. Caruca concretely executes each\ncommand-environment pair, interposing at the system-call and filesystem level\nto extract key command properties such as parallelizability and filesystem pre-\nand post-conditions. These properties can be exported in multiple specification\nformats and are immediately usable by existing systems. Applying Caruca across\n60 GNU Coreutils, POSIX, and third-party commands across several\nspecification-dependent systems shows that Caruca generates correct\nspecifications for all but one case, completely eliminating manual effort from\nthe process and currently powering the full specifications for a\nstate-of-the-art static analysis tool.", "AI": {"tldr": "Caruca is a system that automatically mines specifications for opaque commands by using LLMs to translate documentation into structured syntax, exploring valid command invocations, and extracting properties through system-call interposition.", "motivation": "Manual specification creation for opaque components like Unix shell commands is laborious and error-prone, limiting the practicality of systems that rely on such specifications for performance, security, and reliability improvements.", "method": "Caruca instruments LLMs to translate command documentation into structured invocation syntax, explores syntactically valid command invocations and execution environments, and interposes at system-call/filesystem level to extract command properties like parallelizability and filesystem conditions.", "result": "Caruca generated correct specifications for 59 out of 60 GNU Coreutils, POSIX, and third-party commands, completely eliminating manual effort and currently powering specifications for a state-of-the-art static analysis tool.", "conclusion": "Caruca successfully automates specification mining for opaque commands, making specification-dependent systems more practical by removing the manual specification creation bottleneck."}}
{"id": "2510.14292", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.14292", "abs": "https://arxiv.org/abs/2510.14292", "authors": ["Haolin Pan", "Hongbin Zhang", "Mingjie Xing", "Yanjun Wu"], "title": "A Hybrid, Knowledge-Guided Evolutionary Framework for Personalized Compiler Auto-Tuning", "comment": null, "summary": "Compiler pass auto-tuning is critical for enhancing software performance, yet\nfinding the optimal pass sequence for a specific program is an NP-hard problem.\nTraditional, general-purpose optimization flags like -O3 and -Oz adopt a\none-size-fits-all approach, often failing to unlock a program's full\nperformance potential. To address this challenge, we propose a novel Hybrid,\nKnowledge-Guided Evolutionary Framework. This framework intelligently guides\nonline, personalized optimization using knowledge extracted from a large-scale\noffline analysis phase. During the offline stage, we construct a comprehensive\ncompilation knowledge base composed of four key components: (1) Pass Behavioral\nVectors to quantitatively capture the effectiveness of each optimization; (2)\nPass Groups derived from clustering these vectors based on behavior similarity;\n(3) a Synergy Pass Graph to model beneficial sequential interactions; and (4) a\nlibrary of Prototype Pass Sequences evolved for distinct program types. In the\nonline stage, a bespoke genetic algorithm leverages this rich knowledge base\nthrough specially designed, knowledge-infused genetic operators. These\noperators transform the search by performing semantically-aware recombination\nand targeted, restorative mutations. On a suite of seven public datasets, our\nframework achieves an average of 11.0% additional LLVM IR instruction reduction\nover the highly-optimized opt -Oz baseline, demonstrating its state-of-the-art\ncapability in discovering personalized, high-performance optimization\nsequences.", "AI": {"tldr": "A hybrid evolutionary framework that uses offline knowledge extraction to guide online compiler pass auto-tuning, achieving 11.0% better instruction reduction than -Oz baseline.", "motivation": "Traditional compiler optimization flags like -O3 and -Oz use one-size-fits-all approaches that fail to unlock programs' full performance potential, and finding optimal pass sequences is NP-hard.", "method": "Hybrid framework with offline knowledge base construction (pass behavioral vectors, pass groups, synergy pass graph, prototype sequences) and online genetic algorithm with knowledge-infused operators for semantically-aware recombination and targeted mutations.", "result": "Achieves average 11.0% additional LLVM IR instruction reduction over opt -Oz baseline across seven public datasets.", "conclusion": "The framework demonstrates state-of-the-art capability in discovering personalized, high-performance optimization sequences through knowledge-guided evolutionary search."}}
{"id": "2510.14339", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.14339", "abs": "https://arxiv.org/abs/2510.14339", "authors": ["Jialu Zhang", "Jialiang Gu", "Wangmeiyu Zhang", "Jos\u00e9 Pablo Cambronero", "John Kolesar", "Ruzica Piskac", "Daming Li", "Hanyuan Shi"], "title": "A Systematic Study of Time Limit Exceeded Errors in Online Programming Assignments", "comment": null, "summary": "Online programming platforms such as Codeforces and LeetCode attract millions\nof users seeking to learn to program or refine their skills for industry\ninterviews. A major challenge for these users is the Time Limit Exceeded (TLE)\nerror, triggered when a program exceeds the execution time bound. Although\ndesigned as a performance safeguard, TLE errors are difficult to resolve: error\nmessages provide no diagnostic insight, platform support is minimal, and\nexisting debugging tools offer little help. As a result, many users abandon\ntheir submissions after repeated TLE failures.\n  This paper presents the first large-scale empirical study of TLE errors in\nonline programming. We manually analyzed 1000 Codeforces submissions with TLE\nerrors, classified their root causes, and traced how users attempted to fix\nthem. Our analysis shows that TLE errors often arise not only from inefficient\nalgorithms but also from infinite loops, improper data structure use, and\ninefficient I/O, challenging the conventional view that TLEs are purely\nperformance issues.\n  Guided by these findings, we introduce Nettle, the first automated repair\ntool specifically designed for TLE errors, and Nettle-Eval, the first framework\nfor evaluating TLE repairs. Integrating LLMs with targeted automated feedback\ngenerated by the compiler and test cases, Nettle produces small, correct code\nedits that eliminate TLEs while preserving functionality. Evaluated on the same\n1000 real-world cases, Nettle achieves a 98.5% fix rate, far exceeding the\nstrongest LLM baseline, and all of its repairs pass both Nettle-Eval and the\nplatform's official checker, confirming the reliability of our framework.", "AI": {"tldr": "First large-scale study of Time Limit Exceeded (TLE) errors in online programming platforms, revealing diverse root causes beyond just inefficient algorithms. Introduces Nettle, an automated repair tool that achieves 98.5% fix rate using LLMs combined with compiler feedback and test cases.", "motivation": "TLE errors are a major challenge for users of online programming platforms like Codeforces and LeetCode, but current debugging tools offer little help and error messages provide no diagnostic insight, causing many users to abandon submissions after repeated failures.", "method": "Manually analyzed 1000 Codeforces submissions with TLE errors to classify root causes. Developed Nettle, an automated repair tool that integrates LLMs with targeted compiler feedback and test cases to produce small, correct code edits that eliminate TLEs while preserving functionality.", "result": "TLE errors arise from multiple causes including infinite loops, improper data structure use, and inefficient I/O, not just inefficient algorithms. Nettle achieved 98.5% fix rate on 1000 real-world cases, far exceeding LLM baselines, with all repairs passing both Nettle-Eval and platform's official checker.", "conclusion": "TLE errors are more complex than conventional performance issues, and automated repair tools like Nettle can effectively resolve them by combining LLMs with targeted feedback mechanisms, providing reliable solutions for online programming platforms."}}
{"id": "2510.14341", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.14341", "abs": "https://arxiv.org/abs/2510.14341", "authors": ["Xu He", "Shu Wang", "Kun Sun"], "title": "PathFix: Automated Program Repair with Expected Path", "comment": "This is the author's version of a paper accepted at SecDev 2025\n  (IEEE)", "summary": "Automated program repair (APR) techniques are effective in fixing inevitable\ndefects in software, enhancing development efficiency and software robustness.\nHowever, due to the difficulty of generating precise specifications, existing\nAPR methods face two main challenges: generating too many plausible patch\ncandidates and overfitting them to partial test cases. To tackle these\nchallenges, we introduce a new APR method named PathFix, which leverages\npath-sensitive constraints extracted from correct execution paths to generate\npatches for repairing buggy code. It is based on one observation: if a buggy\nprogram is repairable, at least one expected path is supposed to replace the\nfault path in the patched program. PathFix operates in four main steps. First,\nit traces fault paths reaching the fault output in the buggy program. Second,\nit derives expected paths by analyzing the desired correct output on the\ncontrol flow graph, where an expected path defines how a feasible patch leads\nto the correct execution. Third, PathFix generates and evaluates patches by\nsolving state constraints along the expected path. Fourth, we validate the\ncorrectness of the generated patch. To further enhance repair performance and\nmitigate scalability issues introduced by path-sensitive analysis, we integrate\na large language model (LLM) into our framework. Experimental results show that\nPathFix outperforms existing solutions, particularly in handling complex\nprogram structures such as loops and recursion.", "AI": {"tldr": "PathFix is a new automated program repair method that uses path-sensitive constraints from correct execution paths to generate patches, addressing challenges of too many plausible patches and overfitting to partial tests.", "motivation": "Existing APR methods struggle with generating too many plausible patch candidates and overfitting to partial test cases due to difficulty in generating precise specifications.", "method": "PathFix traces fault paths, derives expected paths from correct outputs on control flow graphs, generates patches by solving state constraints along expected paths, and validates patch correctness. It also integrates LLMs to enhance performance and mitigate scalability issues.", "result": "Experimental results show PathFix outperforms existing solutions, particularly in handling complex program structures like loops and recursion.", "conclusion": "PathFix effectively addresses APR challenges by leveraging path-sensitive constraints and expected execution paths, demonstrating superior performance in repairing complex software defects."}}
{"id": "2510.14465", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.14465", "abs": "https://arxiv.org/abs/2510.14465", "authors": ["Adem Ait", "Gwendal Jouneaux", "Javier Luis C\u00e1novas Izquierdo", "Jordi Cabot"], "title": "Towards Automated Governance: A DSL for Human-Agent Collaboration in Software Projects", "comment": "Accepted in the 40th IEEE/ACM International Conference on Automated\n  Software Engineering, ASE 2025", "summary": "The stakeholders involved in software development are becoming increasingly\ndiverse, with both human contributors from varied backgrounds and AI-powered\nagents collaborating together in the process. This situation presents unique\ngovernance challenges, particularly in Open-Source Software (OSS) projects,\nwhere explicit policies are often lacking or unclear. This paper presents the\nvision and foundational concepts for a novel Domain-Specific Language (DSL)\ndesigned to define and enforce rich governance policies in systems involving\ndiverse stakeholders, including agents. This DSL offers a pathway towards more\nrobust, adaptable, and ultimately automated governance, paving the way for more\neffective collaboration in software projects, especially OSS ones.", "AI": {"tldr": "A Domain-Specific Language (DSL) for defining and enforcing governance policies in software development with diverse stakeholders including AI agents.", "motivation": "Increasing diversity of stakeholders in software development (both human and AI agents) creates governance challenges, especially in Open-Source Software where policies are often unclear or missing.", "method": "Development of a novel Domain-Specific Language (DSL) designed to define and enforce rich governance policies for systems with diverse stakeholders including agents.", "result": "A DSL framework that enables robust, adaptable, and automated governance for collaborative software development environments.", "conclusion": "The proposed DSL offers a pathway toward more effective collaboration in software projects, particularly Open-Source Software, by enabling automated governance in mixed human-AI stakeholder environments."}}
{"id": "2510.14509", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.14509", "abs": "https://arxiv.org/abs/2510.14509", "authors": ["Jingyao Liu", "Chen Huang", "Zhizhao Guan", "Wenqiang Lei", "Yang Deng"], "title": "E2Edev: Benchmarking Large Language Models in End-to-End Software Development Task", "comment": null, "summary": "E2EDev comprises (i) a fine-grained set of user requirements, (ii) {multiple\nBDD test scenarios with corresponding Python step implementations for each\nrequirement}, and (iii) a fully automated testing pipeline built on the Behave\nframework. To ensure its quality while reducing the annotation effort, E2EDev\nleverages our proposed Human-in-the-Loop Multi-Agent Annotation Framework\n(HITL-MAA). {By evaluating various E2ESD frameworks and LLM backbones with\nE2EDev}, our analysis reveals a persistent struggle to effectively solve these\ntasks, underscoring the critical need for more effective and cost-efficient\nE2ESD solutions. Our codebase and benchmark are publicly available at\nhttps://github.com/SCUNLP/E2EDev.", "AI": {"tldr": "E2EDev is a comprehensive benchmark for evaluating End-to-End Software Development (E2ESD) frameworks, featuring fine-grained requirements, BDD test scenarios with Python implementations, and automated testing pipeline.", "motivation": "To address the need for more effective and cost-efficient E2ESD solutions by providing a quality benchmark that reduces annotation effort through human-in-the-loop multi-agent annotation.", "method": "Uses Human-in-the-Loop Multi-Agent Annotation Framework (HITL-MAA) to ensure quality while minimizing annotation effort. Includes fine-grained requirements, multiple BDD test scenarios with Python step implementations, and automated testing pipeline built on Behave framework.", "result": "Evaluation of various E2ESD frameworks and LLM backbones reveals persistent struggles in effectively solving these tasks, highlighting the need for better E2ESD solutions.", "conclusion": "E2EDev provides a valuable benchmark that demonstrates current E2ESD frameworks' limitations and emphasizes the need for more effective and cost-efficient development solutions."}}
{"id": "2510.14625", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.14625", "abs": "https://arxiv.org/abs/2510.14625", "authors": ["Mehrdad Saadatmand", "Abbas Khan", "Beatriz Marin", "Ana C. R Paiva", "Nele Van Asch", "Graham Moran", "Felix Cammaerts", "Monique Snoeck", "Alexandra Mendes"], "title": "Software Testing Education and Industry Needs - Report from the ENACTEST EU Project", "comment": "* The paper is going to appear in the proceedings of the 26th\n  International Conference on Product-Focused Software Process Improvement\n  (PROFES 2025). To cite the paper, please check and refer to the PROFES 2025\n  proceedings", "summary": "The evolving landscape of software development demands that software testers\ncontinuously adapt to new tools, practices, and acquire new skills. This study\ninvestigates software testing competency needs in industry, identifies\nknowledge gaps in current testing education, and highlights competencies and\ngaps not addressed in academic literature. This is done by conducting two focus\ngroup sessions and interviews with professionals across diverse domains,\nincluding railway industry, healthcare, and software consulting and performing\na curated small-scale scoping review. The study instrument, co-designed by\nmembers of the ENACTEST project consortium, was developed collaboratively and\nrefined through multiple iterations to ensure comprehensive coverage of\nindustry needs and educational gaps. In particular, by performing a thematic\nqualitative analysis, we report our findings and observations regarding:\nprofessional training methods, challenges in offering training in industry,\ndifferent ways of evaluating the quality of training, identified knowledge gaps\nwith respect to academic education and industry needs, future needs and trends\nin testing education, and knowledge transfer methods within companies. Finally,\nthe scoping review results confirm knowledge gaps in areas such as AI testing,\nsecurity testing and soft skills.", "AI": {"tldr": "This study examines software testing competency needs in industry, identifies gaps in current testing education, and highlights competencies not addressed in academic literature through focus groups, interviews, and scoping review.", "motivation": "The evolving software development landscape requires testers to continuously adapt to new tools, practices, and skills, creating a need to understand current competency gaps and educational shortcomings.", "method": "Conducted two focus group sessions and interviews with professionals across diverse domains (railway, healthcare, software consulting), performed a curated small-scale scoping review, and used thematic qualitative analysis.", "result": "Identified knowledge gaps in professional training methods, challenges in industry training, evaluation methods for training quality, gaps between academic education and industry needs, future testing education trends, and knowledge transfer methods. Scoping review confirmed gaps in AI testing, security testing, and soft skills.", "conclusion": "There are significant gaps in software testing education that need to be addressed, particularly in emerging areas like AI testing, security testing, and soft skills, requiring better alignment between academic education and industry needs."}}
{"id": "2510.14635", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.14635", "abs": "https://arxiv.org/abs/2510.14635", "authors": ["Qingyao Li", "Xinyi Dai", "Weiwen Liu", "Xiangyang Li", "Yasheng Wang", "Ruiming Tang", "Yong Yu", "Weinan Zhang"], "title": "ATGen: Adversarial Reinforcement Learning for Test Case Generation", "comment": null, "summary": "Large Language Models (LLMs) excel at code generation, yet their outputs\noften contain subtle bugs, for which effective test cases are a critical\nbottleneck. Existing test generation methods, whether based on prompting or\nsupervised fine-tuning, rely on static datasets. This imposes a\n``fixed-difficulty ceiling'', fundamentally limiting their ability to uncover\nnovel or more complex bugs beyond their training scope. To overcome this, we\nintroduce ATGen, a framework that trains a test case generator via adversarial\nreinforcement learning. ATGen pits a test generator against an adversarial code\ngenerator that continuously crafts harder bugs to evade the current policy.\nThis dynamic loop creates a curriculum of increasing difficulty challenging\ncurrent policy. The test generator is optimized via Reinforcement Learning (RL)\nto jointly maximize ``Output Accuracy'' and ``Attack Success'', enabling it to\nlearn a progressively stronger policy that breaks the fixed-difficulty ceiling\nof static training. Extensive experiments demonstrate that ATGen significantly\noutperforms state-of-the-art baselines. We further validate its practical\nutility, showing it serves as both a more effective filter for Best-of-N\ninference and a higher-quality reward source for training code generation\nmodels. Our work establishes a new, dynamic paradigm for improving the\nreliability of LLM-generated code.", "AI": {"tldr": "ATGen is an adversarial reinforcement learning framework that trains a test case generator against an adversarial code generator to create progressively harder bugs, breaking the fixed-difficulty ceiling of static training methods.", "motivation": "Existing test generation methods rely on static datasets, imposing a fixed-difficulty ceiling that limits their ability to uncover novel or more complex bugs beyond their training scope.", "method": "ATGen uses adversarial reinforcement learning where a test generator competes against an adversarial code generator that continuously crafts harder bugs. The test generator is optimized via RL to maximize both output accuracy and attack success.", "result": "ATGen significantly outperforms state-of-the-art baselines and serves as both a more effective filter for Best-of-N inference and a higher-quality reward source for training code generation models.", "conclusion": "ATGen establishes a new dynamic paradigm for improving the reliability of LLM-generated code by breaking the fixed-difficulty ceiling through adversarial training."}}
{"id": "2510.14653", "categories": ["cs.SE", "cs.RO"], "pdf": "https://arxiv.org/pdf/2510.14653", "abs": "https://arxiv.org/abs/2510.14653", "authors": ["Sven Tarlowski", "Lutz Eckstein"], "title": "Requirement Identification for Traffic Simulations in Driving Simulators", "comment": "2 Pages, 1 figure", "summary": "This paper addresses the challenge of ensuring realistic traffic conditions\nby proposing a methodology that systematically identifies traffic simulation\nrequirements. Using a structured approach based on sub-goals in each study\nphase, specific technical needs are derived for microscopic levels, agent\nmodels, and visual representation. The methodology aims to maintain a high\ndegree of fidelity, enhancing both the validity of experimental outcomes and\nparticipant engagement. By providing a clear link between study objectives and\ntraffic simulation design, this approach supports robust automotive development\nand testing.", "AI": {"tldr": "A methodology for systematically identifying traffic simulation requirements to ensure realistic traffic conditions through structured sub-goals.", "motivation": "To address the challenge of ensuring realistic traffic conditions in automotive development and testing by maintaining high fidelity in simulations.", "method": "Uses a structured approach based on sub-goals in each study phase to derive specific technical needs for microscopic levels, agent models, and visual representation.", "result": "Provides a clear link between study objectives and traffic simulation design, enhancing validity of experimental outcomes and participant engagement.", "conclusion": "This approach supports robust automotive development and testing by systematically identifying traffic simulation requirements."}}
{"id": "2510.14700", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.14700", "abs": "https://arxiv.org/abs/2510.14700", "authors": ["Bin Liu", "Yanjie Zhao", "Guoai Xu", "Haoyu Wang"], "title": "LLM Agents for Automated Web Vulnerability Reproduction: Are We There Yet?", "comment": null, "summary": "Large language model (LLM) agents have demonstrated remarkable capabilities\nin software engineering and cybersecurity tasks, including code generation,\nvulnerability discovery, and automated testing. One critical but underexplored\napplication is automated web vulnerability reproduction, which transforms\nvulnerability reports into working exploits. Although recent advances suggest\npromising potential, challenges remain in applying LLM agents to real-world web\nvulnerability reproduction scenarios. In this paper, we present the first\ncomprehensive evaluation of state-of-the-art LLM agents for automated web\nvulnerability reproduction. We systematically assess 20 agents from software\nengineering, cybersecurity, and general domains across 16 dimensions, including\ntechnical capabilities, environment adaptability, and user experience factors,\non 3 representative web vulnerabilities. Based on the results, we select three\ntop-performing agents (OpenHands, SWE-agent, and CAI) for in-depth evaluation\non our benchmark dataset of 80 real-world CVEs spanning 7 vulnerability types\nand 6 web technologies. Our results reveal that while LLM agents achieve\nreasonable success on simple library-based vulnerabilities, they consistently\nfail on complex service-based vulnerabilities requiring multi-component\nenvironments. Complex environment configurations and authentication barriers\ncreate a gap where agents can execute exploit code but fail to trigger actual\nvulnerabilities. We observe high sensitivity to input guidance, with\nperformance degrading by over 33% under incomplete authentication information.\nOur findings highlight the significant gap between current LLM agent\ncapabilities and the demands of reliable automated vulnerability reproduction,\nemphasizing the need for advances in environmental adaptation and autonomous\nproblem-solving capabilities.", "AI": {"tldr": "First comprehensive evaluation of LLM agents for automated web vulnerability reproduction, revealing significant gaps in handling complex service-based vulnerabilities and environmental adaptation.", "motivation": "To assess the potential of LLM agents in transforming vulnerability reports into working exploits for web applications, addressing an underexplored but critical application area.", "method": "Systematically evaluated 20 state-of-the-art LLM agents across 16 dimensions on 3 representative vulnerabilities, then conducted in-depth evaluation of top 3 agents on 80 real-world CVEs spanning 7 vulnerability types and 6 web technologies.", "result": "LLM agents achieve reasonable success on simple library-based vulnerabilities but consistently fail on complex service-based vulnerabilities requiring multi-component environments. Performance degrades by over 33% under incomplete authentication information.", "conclusion": "There is a significant gap between current LLM agent capabilities and reliable automated vulnerability reproduction demands, highlighting the need for advances in environmental adaptation and autonomous problem-solving capabilities."}}
{"id": "2510.14778", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.14778", "abs": "https://arxiv.org/abs/2510.14778", "authors": ["Maor Reuben", "Ido Mendel", "Or Feldman", "Moshe Kravchik", "Mordehai Guri", "Rami Puzis"], "title": "Leveraging Code Cohesion Analysis to Identify Source Code Supply Chain Attacks", "comment": null, "summary": "Supply chain attacks significantly threaten software security with malicious\ncode injections within legitimate projects. Such attacks are very rare but may\nhave a devastating impact. Detecting spurious code injections using automated\ntools is further complicated as it often requires deciphering the intention of\nboth the inserted code and its context. In this study, we propose an\nunsupervised approach for highlighting spurious code injections by quantifying\ncohesion disruptions in the source code. Using a name-prediction-based cohesion\n(NPC) metric, we analyze how function cohesion changes when malicious code is\nintroduced compared to natural cohesion fluctuations. An analysis of 54,707\nfunctions over 369 open-source C++ repositories reveals that code injection\nreduces cohesion and shifts naming patterns toward shorter, less descriptive\nnames compared to genuine function updates. Considering the sporadic nature of\nreal supply-chain attacks, we evaluate the proposed method with extreme\ntest-set imbalance and show that monitoring high-cohesion functions with NPC\ncan effectively detect functions with injected code, achieving a Precision@100\nof 36.41% at a 1:1,000 ratio and 12.47% at 1:10,000. These results suggest that\nautomated cohesion measurements, in general, and name-prediction-based\ncohesion, in particular, may help identify supply chain attacks, improving\nsource code integrity.", "AI": {"tldr": "An unsupervised approach using name-prediction-based cohesion (NPC) metric to detect supply chain attacks by identifying cohesion disruptions in source code caused by malicious code injections.", "motivation": "Supply chain attacks pose significant threats to software security through rare but devastating malicious code injections in legitimate projects, which are difficult to detect automatically due to the need to understand code intention and context.", "method": "Proposes NPC metric to quantify cohesion disruptions by analyzing how function cohesion changes when malicious code is introduced compared to natural fluctuations. Analyzed 54,707 functions across 369 open-source C++ repositories.", "result": "Code injection reduces cohesion and shifts naming patterns toward shorter, less descriptive names. Achieved Precision@100 of 36.41% at 1:1,000 ratio and 12.47% at 1:10,000 imbalance, showing effective detection of functions with injected code.", "conclusion": "Automated cohesion measurements, particularly name-prediction-based cohesion, can help identify supply chain attacks and improve source code integrity by detecting spurious code injections."}}
{"id": "2510.14928", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.14928", "abs": "https://arxiv.org/abs/2510.14928", "authors": ["Eric Christopher", "Kevin Crossan", "Wolff Dobson", "Chris Kennelly", "Drew Lewis", "Kun Lin", "Martin Maas", "Parthasarathy Ranganathan", "Emma Rapati", "Brian Yang"], "title": "Instruction Set Migration at Warehouse Scale", "comment": null, "summary": "Migrating codebases from one instruction set architecture (ISA) to another is\na major engineering challenge. A recent example is the adoption of Arm (in\naddition to x86) across the major Cloud hyperscalers. Yet, this problem has\nseen limited attention by the academic community. Most work has focused on\nstatic and dynamic binary translation, and the traditional conventional wisdom\nhas been that this is the primary challenge.\n  In this paper, we show that this is no longer the case. Modern ISA migrations\ncan often build on a robust open-source ecosystem, making it possible to\nrecompile all relevant software from scratch. This introduces a new and\nmultifaceted set of challenges, which are different from binary translation.\n  By analyzing a large-scale migration from x86 to Arm at Google, spanning\nalmost 40,000 code commits, we derive a taxonomy of tasks involved in ISA\nmigration. We show how Google automated many of the steps involved, and\ndemonstrate how AI can play a major role in automatically addressing these\ntasks. We identify tasks that remain challenging and highlight research\nchallenges that warrant further attention.", "AI": {"tldr": "This paper analyzes the challenges of ISA migration from x86 to Arm at Google, showing that modern migrations focus on recompilation rather than binary translation, and demonstrates how AI can automate many migration tasks.", "motivation": "To address the major engineering challenge of migrating codebases between instruction set architectures (ISAs), particularly the shift from x86 to Arm in cloud computing, which has received limited academic attention despite its practical importance.", "method": "Analyzed a large-scale migration at Google spanning almost 40,000 code commits, derived a taxonomy of ISA migration tasks, and demonstrated automation approaches including AI-based solutions.", "result": "Showed that modern ISA migrations can build on open-source ecosystems for recompilation rather than relying on binary translation, identified key migration tasks, and demonstrated successful automation of many steps.", "conclusion": "Modern ISA migrations present different challenges from traditional binary translation approaches, with AI playing a major role in automation, though some tasks remain challenging and warrant further research."}}
