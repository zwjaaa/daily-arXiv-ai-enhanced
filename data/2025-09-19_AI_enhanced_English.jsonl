{"id": "2509.14265", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14265", "abs": "https://arxiv.org/abs/2509.14265", "authors": ["Siyuan Chen", "Zhichao Lu", "Qingfu Zhang"], "title": "Evolution of Kernels: Automated RISC-V Kernel Optimization with Large Language Models", "comment": "Technical report", "summary": "Automated kernel design is critical for overcoming software ecosystem\nbarriers in emerging hardware platforms like RISC-V. While large language\nmodels (LLMs) have shown promise for automated kernel optimization,\ndemonstrating success in CUDA domains with comprehensive technical documents\nand mature codebases, their effectiveness remains unproven for reference-scarce\ndomains like RISC-V. We present Evolution of Kernels (EoK), a novel LLM-based\nevolutionary program search framework that automates kernel design for domains\nwith limited reference material. EoK mitigates reference scarcity by mining and\nformalizing reusable optimization ideas (general design principles + actionable\nthoughts) from established kernel libraries' development histories; it then\nguides parallel LLM explorations using these ideas, enriched via\nRetrieval-Augmented Generation (RAG) with RISC-V-specific context, prioritizing\nhistorically effective techniques. Empirically, EoK achieves a median 1.27x\nspeedup, surpassing human experts on all 80 evaluated kernel design tasks and\nimproving upon prior LLM-based automated kernel design methods by 20%. These\nresults underscore the viability of incorporating human experience into\nemerging domains and highlight the immense potential of LLM-based automated\nkernel optimization.", "AI": {"tldr": "EoK is an LLM-based evolutionary framework that automates kernel design for RISC-V by mining optimization ideas from established libraries and using RAG with domain-specific context, achieving 1.27x speedup over human experts.", "motivation": "Automated kernel design is needed for emerging hardware like RISC-V, but LLMs struggle in reference-scarce domains where comprehensive documentation and mature codebases are lacking.", "method": "Evolution of Kernels (EoK) framework mines reusable optimization ideas from kernel libraries' development histories, formalizes them as design principles, and guides parallel LLM explorations using RAG with RISC-V-specific context to prioritize historically effective techniques.", "result": "EoK achieves median 1.27x speedup, surpassing human experts on all 80 evaluated kernel design tasks and improving upon prior LLM-based methods by 20%.", "conclusion": "The approach demonstrates viability of incorporating human experience into emerging domains and highlights significant potential for LLM-based automated kernel optimization in reference-scarce environments."}}
{"id": "2509.14273", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14273", "abs": "https://arxiv.org/abs/2509.14273", "authors": ["Swapnil Sharma Sarker", "Tanzina Taher Ifty"], "title": "Automated and Context-Aware Code Documentation Leveraging Advanced LLMs", "comment": null, "summary": "Code documentation is essential to improve software maintainability and\ncomprehension. The tedious nature of manual code documentation has led to much\nresearch on automated documentation generation. Existing automated approaches\nprimarily focused on code summarization, leaving a gap in template-based\ndocumentation generation (e.g., Javadoc), particularly with publicly available\nLarge Language Models (LLMs). Furthermore, progress in this area has been\nhindered by the lack of a Javadoc-specific dataset that incorporates modern\nlanguage features, provides broad framework/library coverage, and includes\nnecessary contextual information. This study aims to address these gaps by\ndeveloping a tailored dataset and assessing the capabilities of publicly\navailable LLMs for context-aware, template-based Javadoc generation. In this\nwork, we present a novel, context-aware dataset for Javadoc generation that\nincludes critical structural and semantic information from modern Java\ncodebases. We evaluate five open-source LLMs (including LLaMA-3.1, Gemma-2,\nPhi-3, Mistral, Qwen-2.5) using zero-shot, few-shot, and fine-tuned setups and\nprovide a comparative analysis of their performance. Our results demonstrate\nthat LLaMA 3.1 performs consistently well and is a reliable candidate for\npractical, automated Javadoc generation, offering a viable alternative to\nproprietary systems.", "AI": {"tldr": "This paper addresses automated Javadoc generation using LLMs, creates a novel context-aware dataset for modern Java codebases, and evaluates five open-source LLMs, finding LLaMA 3.1 as the most reliable performer.", "motivation": "Existing automated documentation approaches focus on code summarization but lack template-based documentation generation (like Javadoc) using publicly available LLMs. Progress is hindered by the absence of Javadoc-specific datasets with modern language features and contextual information.", "method": "Developed a novel context-aware dataset for Javadoc generation incorporating structural and semantic information from modern Java codebases. Evaluated five open-source LLMs (LLaMA-3.1, Gemma-2, Phi-3, Mistral, Qwen-2.5) using zero-shot, few-shot, and fine-tuned setups.", "result": "LLaMA 3.1 performed consistently well across different evaluation setups, demonstrating reliable performance for automated Javadoc generation.", "conclusion": "LLaMA 3.1 offers a viable alternative to proprietary systems for practical, automated Javadoc generation, making it a reliable candidate for this task."}}
{"id": "2509.14279", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14279", "abs": "https://arxiv.org/abs/2509.14279", "authors": ["Robert Tjarko Lange", "Qi Sun", "Aaditya Prasad", "Maxence Faldor", "Yujin Tang", "David Ha"], "title": "Towards Robust Agentic CUDA Kernel Benchmarking, Verification, and Optimization", "comment": "62 pages, 10 figures", "summary": "Recent advances in large language models (LLMs) demonstrate their\neffectiveness in scaling test-time compute for software engineering tasks.\nHowever, these approaches often focus on high-level solutions, with limited\nattention to optimizing low-level CUDA kernel implementations. Additionally,\nexisting kernel generation benchmarks suffer from exploitable loopholes and\ninsufficient diversity in testing conditions, hindering true generalization\nassessment. To address these limitations, we introduce robust-kbench, a new\nbenchmark for rigorous evaluation of kernel performance and correctness across\nvaried scenarios. Furthermore, we present a comprehensive agentic framework\nthat automates CUDA kernel discovery, verification, and optimization. This\npipeline enables frontier LLMs to translate torch code to CUDA kernels and\niteratively improve their runtime within our robust evaluation setting. Our\nsequential workflow first translates PyTorch code into equivalent CUDA kernels.\nIt then optimizes their runtime using a novel evolutionary meta-generation\nprocedure tailored to the CUDA ecosystem, guided by LLM-based verifiers for\ncorrectness and efficient filtering. Evaluated on robust-kbench, our approach\nproduces CUDA kernels outperforming torch implementations for practical\napplications, including forward and backward passes. It can fuse operations and\ndeploy various runtime optimization strategies. The verifier workflow\naccurately classifies incorrect kernels, enhancing hardware verification\nefficiency.", "AI": {"tldr": "A new benchmark robust-kbench and agentic framework for rigorous evaluation and automated optimization of CUDA kernel generation using LLMs, outperforming torch implementations.", "motivation": "Existing LLM approaches focus on high-level software engineering solutions but neglect low-level CUDA kernel optimization, and current benchmarks have exploitable loopholes and lack diversity for proper generalization assessment.", "method": "A comprehensive agentic framework that translates PyTorch code to CUDA kernels, then uses evolutionary meta-generation with LLM-based verifiers for iterative optimization and correctness checking within the robust-kbench evaluation setting.", "result": "Produces CUDA kernels that outperform torch implementations for practical applications including forward/backward passes, enables operation fusion and various runtime optimizations, with verifiers accurately classifying incorrect kernels for efficient hardware verification.", "conclusion": "The framework successfully addresses limitations in current kernel generation approaches by providing rigorous evaluation and automated optimization, demonstrating effective translation and improvement of CUDA kernel performance using frontier LLMs."}}
{"id": "2509.14281", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14281", "abs": "https://arxiv.org/abs/2509.14281", "authors": ["Xifeng Yao", "Dongyu Lang", "Wu Zhang", "Xintong Guo", "Huarui Xie", "Yinhao Ni", "Ping Liu", "Guang Shen", "Yi Bai", "Dandan Tu", "Changzheng Zhang"], "title": "SCoGen: Scenario-Centric Graph-Based Synthesis of Real-World Code Problems", "comment": null, "summary": "Significant advancements have been made in the capabilities of code large\nlanguage models, leading to their rapid adoption and application across a wide\nrange of domains. However, their further advancements are often constrained by\nthe scarcity of real-world coding problems. To bridge this gap, we propose a\nnovel framework for synthesizing code problems that emulate authentic\nreal-world scenarios. This framework systematically integrates domain\nknowledge, domain skills, and coding skills, all of which are meticulously\nextracted from real-world programming-related datasets, including Stack\nOverflow and Kaggle. The extracted elements serve as the foundational building\nblocks for constructing code problems. To align the generated problems with\npractical applications, application scenarios are also mined from the\naforementioned datasets. These scenarios are then utilized to construct a\nscenario-centric graph that interconnects domain knowledge, domain skills, and\ncoding skills. Based on this structured representation, a sampling strategy on\nthe graph is designed, which effectively controls the generation of a code\nproblem with complexity and diversity, reflects real-world challenges.\nExperimental results demonstrate that the proposed method consistently achieves\nsuperior performance over state-of-the-art open-source large language models of\nvarying sizes and functionalities, including both coders and general-purpose\nmodels, across a diverse set of real-world benchmarks.", "AI": {"tldr": "A framework for synthesizing realistic code problems by extracting domain knowledge, skills, and coding skills from real-world datasets like Stack Overflow and Kaggle, then using a scenario-centric graph to generate diverse and complex coding challenges.", "motivation": "Advancements in code LLMs are constrained by scarcity of real-world coding problems. Need authentic problems that reflect practical challenges to further improve model capabilities.", "method": "Extract domain knowledge, domain skills, and coding skills from programming datasets. Build scenario-centric graph connecting these elements. Use sampling strategy on graph to generate code problems with controlled complexity and diversity.", "result": "Superior performance over state-of-the-art open-source LLMs of varying sizes and types (both coders and general-purpose models) across diverse real-world benchmarks.", "conclusion": "The proposed framework effectively bridges the gap in real-world coding problem availability, enabling better training and evaluation of code LLMs through authentic, diverse problem generation."}}
{"id": "2509.14294", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14294", "abs": "https://arxiv.org/abs/2509.14294", "authors": ["Hira Naveed", "Scott Barnett", "Chetan Arora", "John Grundy", "Hourieh Khalajzadeh", "Omar Haggag"], "title": "Monitoring Machine Learning Systems: A Multivocal Literature Review", "comment": null, "summary": "Context: Dynamic production environments make it challenging to maintain\nreliable machine learning (ML) systems. Runtime issues, such as changes in data\npatterns or operating contexts, that degrade model performance are a common\noccurrence in production settings. Monitoring enables early detection and\nmitigation of these runtime issues, helping maintain users' trust and prevent\nunwanted consequences for organizations. Aim: This study aims to provide a\ncomprehensive overview of the ML monitoring literature. Method: We conducted a\nmultivocal literature review (MLR) following the well established guidelines by\nGarousi to investigate various aspects of ML monitoring approaches in 136\npapers. Results: We analyzed selected studies based on four key areas: (1) the\nmotivations, goals, and context; (2) the monitored aspects, specific\ntechniques, metrics, and tools; (3) the contributions and benefits; and (4) the\ncurrent limitations. We also discuss several insights found in the studies,\ntheir implications, and recommendations for future research and practice.\nConclusion: Our MLR identifies and summarizes ML monitoring practices and gaps,\nemphasizing similarities and disconnects between formal and gray literature.\nOur study is valuable for both academics and practitioners, as it helps select\nappropriate solutions, highlights limitations in current approaches, and\nprovides future directions for research and tool development.", "AI": {"tldr": "A comprehensive multivocal literature review of 136 papers on ML monitoring practices, analyzing motivations, techniques, benefits, and limitations to help maintain reliable ML systems in production environments.", "motivation": "Dynamic production environments present challenges for maintaining reliable ML systems due to runtime issues like data pattern changes that degrade model performance, requiring monitoring to enable early detection and mitigation.", "method": "Conducted a multivocal literature review (MLR) following Garousi's guidelines to investigate ML monitoring approaches across 136 papers, analyzing four key areas: motivations/goals/context, monitored aspects/techniques/metrics/tools, contributions/benefits, and current limitations.", "result": "The review provides a comprehensive overview of ML monitoring literature, identifying and summarizing practices and gaps while emphasizing similarities and disconnects between formal and gray literature. It offers insights, implications, and recommendations for future research.", "conclusion": "The study is valuable for both academics and practitioners as it helps select appropriate monitoring solutions, highlights limitations in current approaches, and provides future directions for research and tool development in ML monitoring."}}
{"id": "2509.14347", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14347", "abs": "https://arxiv.org/abs/2509.14347", "authors": ["Henri A\u00efdasso", "Francis Bordeleau", "Ali Tizghadam"], "title": "On the Illusion of Success: An Empirical Study of Build Reruns and Silent Failures in Industrial CI", "comment": "17 pages, 7 figures", "summary": "Reliability of build outcomes is a cornerstone of effective Continuous\nIntegration (CI). Yet in practice, developers often struggle with\nnon-deterministic issues in the code or CI infrastructure, which undermine\ntrust in build results. When faced with such unexpected outcomes, developers\noften repeatedly rerun jobs hoping for true success, but this practice is known\nto increase CI costs and reduce productivity. While recent studies have focused\non intermittent job failures, no prior work has investigated silent failures,\nwhere build jobs are marked as successful but fail to complete all or part of\ntheir tasks. Such silent failures often go unnoticed, creating an illusion of\nsuccess with detrimental consequences such as bugs escaping into production.\nThis paper presents the first empirical study of silent failures through the\npractice of rerunning successful jobs. An analysis of 142,387 jobs across 81\nindustrial projects shows that 11% of successful jobs are rerun, with 35% of\nthese reruns occurring after more than 24 hours. Using mixed-effects models on\n32 independent variables (AUC of 85%), we identified key factors associated\nwith reruns of successful jobs, notably testing and static analysis tasks,\nscripting languages like Shell, and developers prior rerun tendencies. A\nfurther analysis of 92 public issues revealed 11 categories of silent failures\naligning with these factors, the most frequent being artifact operation errors,\ncaching errors, and ignored exit codes. Overall, our findings provide valuable\ninsights into the circumstances and causes of silent failures to raise\nawareness among teams, and present solutions to improve CI reliability.", "AI": {"tldr": "First empirical study of silent failures in CI where jobs succeed but fail tasks, showing 11% of successful jobs are rerun with 35% delayed by 24+ hours, identifying key factors and 11 failure categories.", "motivation": "Developers struggle with non-deterministic CI issues that undermine trust in build results. Silent failures (jobs marked successful but failing tasks) create illusion of success with detrimental consequences like production bugs.", "method": "Analyzed 142,387 jobs across 81 industrial projects, used mixed-effects models on 32 variables (AUC 85%) to identify rerun factors, and examined 92 public issues to categorize silent failures.", "result": "11% of successful jobs are rerun, 35% after 24+ hours. Key factors: testing/static analysis tasks, Shell scripting, developer rerun tendencies. Identified 11 categories including artifact operation errors, caching errors, ignored exit codes.", "conclusion": "Findings provide insights into silent failure circumstances and causes to raise team awareness, presenting solutions to improve CI reliability by addressing these hidden failure patterns."}}
{"id": "2509.14373", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14373", "abs": "https://arxiv.org/abs/2509.14373", "authors": ["Huy Le", "Phong Nguyen", "Hao Do", "Tuan Nguyen", "Thien Pham", "Anh Nguyen-Duc", "Tho Quan"], "title": "CodeLSI: Leveraging Foundation Models for Automated Code Generation with Low-Rank Optimization and Domain-Specific Instruction Tuning", "comment": null, "summary": "Context: Automated code generation using Foundation Models (FMs) offers\npromising solutions for enhancing software development efficiency. However,\nchallenges remain in ensuring domain specificity, cost-effectiveness, and\nsecurity - especially when relying on third-party APIs. This paper introduces\nCodeLSI, a framework that combines low-rank optimization and domain-specific\ninstruction tuning to address these challenges.\n  Objectives: The aim of this study is to develop and evaluate CodeLSI, a novel\napproach for generating high-quality code tailored to specific domains, using\nFMs fine-tuned on company infrastructure without dependence on external APIs.\n  Methods: CodeLSI applies low-rank adaptation techniques to reduce the\ncomputational cost of model pre-training and fine-tuning. Domain-specific\ninstruction tuning is employed to align code generation with organizational\nneeds. We implemented and tested the framework on real-world JavaScript coding\ntasks using datasets drawn from internal software projects.\n  Results: Experimental evaluations show that CodeLSI produces high-quality,\ncontext aware code. It outperforms baseline models in terms of relevance,\naccuracy, and domain fit. The use of low-rank optimization significantly\nreduced resource requirements, enabling scalable training on company-owned\ninfrastructure.\n  Conclusion: CodeLSI demonstrates that combining low-rank optimization with\ndomain specific tuning can enhance the practicality and performance of FMs for\nautomated code generation. This approach provides a secure, cost-efficient\nalternative to commercial API based solutions and supports faster, more\ntargeted innovation in software development.", "AI": {"tldr": "CodeLSI is a framework that combines low-rank optimization and domain-specific instruction tuning to generate high-quality, secure code using foundation models fine-tuned on company infrastructure without external APIs.", "motivation": "Address challenges in automated code generation including domain specificity, cost-effectiveness, and security concerns when relying on third-party APIs for foundation models.", "method": "Applies low-rank adaptation techniques to reduce computational costs and uses domain-specific instruction tuning to align code generation with organizational needs. Tested on real-world JavaScript coding tasks using internal datasets.", "result": "Outperforms baseline models in relevance, accuracy, and domain fit. Low-rank optimization significantly reduced resource requirements, enabling scalable training on company infrastructure.", "conclusion": "Combining low-rank optimization with domain-specific tuning enhances practicality and performance of foundation models for automated code generation, providing a secure and cost-efficient alternative to commercial API solutions."}}
{"id": "2509.14404", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14404", "abs": "https://arxiv.org/abs/2509.14404", "authors": ["Haoye Tian", "Chong Wang", "BoYang Yang", "Lyuye Zhang", "Yang Liu"], "title": "A Taxonomy of Prompt Defects in LLM Systems", "comment": null, "summary": "Large Language Models (LLMs) have become key components of modern software,\nwith prompts acting as their de-facto programming interface. However, prompt\ndesign remains largely empirical and small mistakes can cascade into\nunreliable, insecure, or inefficient behavior. This paper presents the first\nsystematic survey and taxonomy of prompt defects, recurring ways that prompts\nfail to elicit their intended behavior from LLMs. We organize defects along six\ndimensions: (1) Specification and Intent, (2) Input and Content, (3) Structure\nand Formatting, (4) Context and Memory, (5) Performance and Efficiency, and (6)\nMaintainability and Engineering. Each dimension is refined into fine-grained\nsubtypes, illustrated with concrete examples and root cause analysis. Grounded\nin software engineering principles, we show how these defects surface in real\ndevelopment workflows and examine their downstream effects. For every subtype,\nwe distill mitigation strategies that span emerging prompt engineering\npatterns, automated guardrails, testing harnesses, and evaluation frameworks.\nWe then summarize these strategies in a master taxonomy that links defect,\nimpact, and remedy. We conclude with open research challenges and a call for\nrigorous engineering-oriented methodologies to ensure that LLM-driven systems\nare dependable by design.", "AI": {"tldr": "Systematic survey and taxonomy of prompt defects in LLM programming, organized across 6 dimensions with mitigation strategies and engineering methodologies.", "motivation": "Prompt design for LLMs remains empirical and error-prone, with small mistakes leading to unreliable, insecure, or inefficient behavior in LLM-driven software systems.", "method": "Organizes prompt defects along six dimensions: Specification and Intent, Input and Content, Structure and Formatting, Context and Memory, Performance and Efficiency, and Maintainability and Engineering, with fine-grained subtypes, examples, and root cause analysis.", "result": "Develops a comprehensive taxonomy of prompt defects with concrete examples, impact analysis, and mitigation strategies including prompt engineering patterns, automated guardrails, testing harnesses, and evaluation frameworks.", "conclusion": "Calls for rigorous engineering-oriented methodologies to ensure LLM-driven systems are dependable by design, highlighting open research challenges in prompt reliability and security."}}
{"id": "2509.14483", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14483", "abs": "https://arxiv.org/abs/2509.14483", "authors": ["Thanh-Long Bui", "Hoa Khanh Dam", "Rashina Hoda"], "title": "An LLM-based multi-agent framework for agile effort estimation", "comment": "Submitted to ASE'25", "summary": "Effort estimation is a crucial activity in agile software development, where\nteams collaboratively review, discuss, and estimate the effort required to\ncomplete user stories in a product backlog. Current practices in agile effort\nestimation heavily rely on subjective assessments, leading to inaccuracies and\ninconsistencies in the estimates. While recent machine learning-based methods\nshow promising accuracy, they cannot explain or justify their estimates and\nlack the capability to interact with human team members. Our paper fills this\nsignificant gap by leveraging the powerful capabilities of Large Language\nModels (LLMs). We propose a novel LLM-based multi-agent framework for agile\nestimation that not only can produce estimates, but also can coordinate,\ncommunicate and discuss with human developers and other agents to reach a\nconsensus. Evaluation results on a real-life dataset show that our approach\noutperforms state-of-the-art techniques across all evaluation metrics in the\nmajority of the cases. Our human study with software development practitioners\nalso demonstrates an overwhelmingly positive experience in collaborating with\nour agents in agile effort estimation.", "AI": {"tldr": "LLM-based multi-agent framework for agile effort estimation that coordinates with human developers to reach consensus, outperforming state-of-the-art methods.", "motivation": "Current agile effort estimation practices rely on subjective assessments leading to inaccuracies, and existing ML methods lack explainability and human interaction capabilities.", "method": "Proposed a novel LLM-based multi-agent framework that can produce estimates, coordinate, communicate, and discuss with human developers and other agents to reach consensus.", "result": "Outperforms state-of-the-art techniques across all evaluation metrics on real-life dataset. Human study shows overwhelmingly positive experience from practitioners.", "conclusion": "The LLM-based multi-agent framework successfully addresses the gap in explainable and interactive agile effort estimation, demonstrating superior performance and positive human collaboration experience."}}
{"id": "2509.14623", "categories": ["cs.SE", "cs.AI", "cs.PL", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2509.14623", "abs": "https://arxiv.org/abs/2509.14623", "authors": ["Hanlong Wan", "Xing Lu", "Yan Chen", "Karthik Devaprasad", "Laura Hinkle"], "title": "Automating Modelica Module Generation Using Large Language Models: A Case Study on Building Control Description Language", "comment": "This is the pre-peer-review version of a journal paper; the repo is\n  available at: https://github.com/pnnl/prompt2control", "summary": "Dynamic energy systems and controls require advanced modeling frameworks to\ndesign and test supervisory and fault tolerant strategies. Modelica is a widely\nused equation based language, but developing control modules is labor intensive\nand requires specialized expertise. This paper examines the use of large\nlanguage models (LLMs) to automate the generation of Control Description\nLanguage modules in the Building Modelica Library as a case study. We developed\na structured workflow that combines standardized prompt scaffolds, library\naware grounding, automated compilation with OpenModelica, and human in the loop\nevaluation. Experiments were carried out on four basic logic tasks (And, Or,\nNot, and Switch) and five control modules (chiller enable/disable, bypass valve\ncontrol, cooling tower fan speed, plant requests, and relief damper control).\nThe results showed that GPT 4o failed to produce executable Modelica code in\nzero shot mode, while Claude Sonnet 4 achieved up to full success for basic\nlogic blocks with carefully engineered prompts. For control modules, success\nrates reached 83 percent, and failed outputs required medium level human repair\n(estimated one to eight hours). Retrieval augmented generation often produced\nmismatches in module selection (for example, And retrieved as Or), while a\ndeterministic hard rule search strategy avoided these errors. Human evaluation\nalso outperformed AI evaluation, since current LLMs cannot assess simulation\nresults or validate behavioral correctness. Despite these limitations, the LLM\nassisted workflow reduced the average development time from 10 to 20 hours down\nto 4 to 6 hours per module, corresponding to 40 to 60 percent time savings.\nThese results highlight both the potential and current limitations of LLM\nassisted Modelica generation, and point to future research in pre simulation\nvalidation, stronger grounding, and closed loop evaluation.", "AI": {"tldr": "LLMs can automate Modelica control module generation with 40-60% time savings, but current models struggle with zero-shot executable code and require human validation for simulation correctness.", "motivation": "Modelica control module development is labor-intensive and requires specialized expertise, creating a need for automated generation tools using large language models.", "method": "Developed a structured workflow combining standardized prompt scaffolds, library-aware grounding, automated compilation with OpenModelica, and human-in-the-loop evaluation for four basic logic tasks and five control modules.", "result": "GPT-4o failed in zero-shot mode, while Claude Sonnet 4 achieved up to 83% success for control modules. Human repair needed 1-8 hours for failed outputs. LLM-assisted workflow reduced development time from 10-20 hours to 4-6 hours per module.", "conclusion": "LLMs show potential for Modelica generation with significant time savings, but current limitations require future research in pre-simulation validation, stronger grounding, and closed-loop evaluation."}}
{"id": "2509.14626", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14626", "abs": "https://arxiv.org/abs/2509.14626", "authors": ["Feiran Qin", "M. M. Abid Naziri", "Hengyu Ai", "Saikat Dutta", "Marcelo d'Amorim"], "title": "Evaluating the Effectiveness of Coverage-Guided Fuzzing for Testing Deep Learning Library APIs", "comment": null, "summary": "Deep Learning (DL) libraries such as PyTorch provide the core components to\nbuild major AI-enabled applications. Finding bugs in these libraries is\nimportant and challenging. Prior approaches have tackled this by performing\neither API-level fuzzing or model-level fuzzing, but they do not use coverage\nguidance, which limits their effectiveness and efficiency. This raises an\nintriguing question: can coverage guided fuzzing (CGF), in particular\nframeworks like LibFuzzer, be effectively applied to DL libraries, and does it\noffer meaningful improvements in code coverage, bug detection, and scalability\ncompared to prior methods?\n  We present the first in-depth study to answer this question. A key challenge\nin applying CGF to DL libraries is the need to create a test harness for each\nAPI that can transform byte-level fuzzer inputs into valid API inputs. To\naddress this, we propose FlashFuzz, a technique that leverages Large Language\nModels (LLMs) to automatically synthesize API-level harnesses by combining\ntemplates, helper functions, and API documentation. FlashFuzz uses a feedback\ndriven strategy to iteratively synthesize and repair harnesses. With this\napproach, FlashFuzz synthesizes harnesses for 1,151 PyTorch and 662 TensorFlow\nAPIs. Compared to state-of-the-art fuzzing methods (ACETest, PathFinder, and\nTitanFuzz), FlashFuzz achieves up to 101.13 to 212.88 percent higher coverage\nand 1.0x to 5.4x higher validity rate, while also delivering 1x to 1182x\nspeedups in input generation. FlashFuzz has discovered 42 previously unknown\nbugs in PyTorch and TensorFlow, 8 of which are already fixed. Our study\nconfirms that CGF can be effectively applied to DL libraries and provides a\nstrong baseline for future testing approaches.", "AI": {"tldr": "FlashFuzz is a coverage-guided fuzzing approach that uses LLMs to automatically synthesize API-level test harnesses for DL libraries, achieving significantly higher code coverage, bug detection, and efficiency compared to prior methods.", "motivation": "Existing approaches for finding bugs in DL libraries like PyTorch and TensorFlow use API-level or model-level fuzzing without coverage guidance, limiting their effectiveness and efficiency. The paper investigates whether coverage-guided fuzzing can be effectively applied to DL libraries.", "method": "FlashFuzz leverages Large Language Models (LLMs) to automatically synthesize API-level harnesses by combining templates, helper functions, and API documentation. It uses a feedback-driven strategy to iteratively synthesize and repair harnesses for each API.", "result": "FlashFuzz synthesized harnesses for 1,151 PyTorch and 662 TensorFlow APIs. It achieved 101.13-212.88% higher coverage, 1.0x-5.4x higher validity rate, and 1x-1182x speedups compared to state-of-the-art methods. It discovered 42 previously unknown bugs, with 8 already fixed.", "conclusion": "The study confirms that coverage-guided fuzzing can be effectively applied to DL libraries and provides a strong baseline for future testing approaches, demonstrating significant improvements in coverage, bug detection, and scalability."}}
{"id": "2509.14646", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14646", "abs": "https://arxiv.org/abs/2509.14646", "authors": ["Yongpan Wang", "Xin Xu", "Xiaojie Zhu", "Xiaodong Gu", "Beijun Shen"], "title": "SALT4Decompile: Inferring Source-level Abstract Logic Tree for LLM-Based Binary Decompilation", "comment": "13 pages, 7 figures", "summary": "Decompilation is widely used in reverse engineering to recover high-level\nlanguage code from binary executables. While recent approaches leveraging Large\nLanguage Models (LLMs) have shown promising progress, they typically treat\nassembly code as a linear sequence of instructions, overlooking arbitrary jump\npatterns and isolated data segments inherent to binary files. This limitation\nsignificantly hinders their ability to correctly infer source code semantics\nfrom assembly code. To address this limitation, we propose \\saltm, a novel\nbinary decompilation method that abstracts stable logical features shared\nbetween binary and source code. The core idea of \\saltm is to abstract selected\nbinary-level operations, such as specific jumps, into a high-level logic\nframework that better guides LLMs in semantic recovery. Given a binary\nfunction, \\saltm constructs a Source-level Abstract Logic Tree (\\salt) from\nassembly code to approximate the logic structure of high-level language. It\nthen fine-tunes an LLM using the reconstructed \\salt to generate decompiled\ncode. Finally, the output is refined through error correction and symbol\nrecovery to improve readability and correctness. We compare \\saltm to three\ncategories of baselines (general-purpose LLMs, commercial decompilers, and\ndecompilation methods) using three well-known datasets (Decompile-Eval, MBPP,\nExebench). Our experimental results demonstrate that \\saltm is highly effective\nin recovering the logic of the source code, significantly outperforming\nstate-of-the-art methods (e.g., 70.4\\% TCP rate on Decompile-Eval with a 10.6\\%\nimprovement). The results further validate its robustness against four commonly\nused obfuscation techniques. Additionally, analyses of real-world software and\na user study confirm that our decompiled output offers superior assistance to\nhuman analysts in comprehending binary functions.", "AI": {"tldr": "SALTM is a novel binary decompilation method that uses Source-level Abstract Logic Trees to guide LLMs in recovering high-level source code from assembly, significantly outperforming state-of-the-art methods with 70.4% TCP rate and 10.6% improvement.", "motivation": "Current LLM-based decompilation approaches treat assembly as linear sequences, overlooking jump patterns and data segments, which hinders accurate semantic recovery from binary code.", "method": "SALTM constructs Source-level Abstract Logic Trees (SALT) from assembly to approximate high-level logic structure, fine-tunes LLMs using reconstructed SALT, and refines output through error correction and symbol recovery.", "result": "Achieves 70.4% TCP rate on Decompile-Eval with 10.6% improvement over SOTA, demonstrates robustness against obfuscation, and provides superior assistance to human analysts in real-world software.", "conclusion": "SALTM effectively bridges the semantic gap between binary and source code by abstracting stable logical features, significantly advancing binary decompilation capabilities for reverse engineering."}}
{"id": "2509.14740", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14740", "abs": "https://arxiv.org/abs/2509.14740", "authors": ["Andrei-Raoul Morariu", "Andreas Strandberg", "Bogdan Iancu", "Jerker Bjorkqvist"], "title": "Wireless Communication Performance Testing: From Laboratory Environment to Research Vessel", "comment": "5 pages, 4 figures, 2 tables", "summary": "This study investigates signal transmission within a shared spectrum,\nfocusing on measurements conducted both in laboratory and outdoor environments.\nThe objective was to demonstrate how laboratory objects obstructing the line of\nsight can attenuate the signal between a transmitter (Tx) and a receiver (Rx).\nAdditionally, we examined the impact of distance and placement in various\nlocations aboard an electric research boat on signal transmission efficiency.\nThese findings contribute to understanding whether the environmental factors\ninfluence wireless communication in dynamic and obstructed environments.", "AI": {"tldr": "Study examines signal attenuation in shared spectrum due to obstructions and distance, using lab and outdoor measurements including tests on an electric research boat.", "motivation": "To understand how environmental factors like obstructions and distance affect wireless signal transmission in dynamic and obstructed environments.", "method": "Conducted measurements in both laboratory and outdoor environments, testing signal attenuation with objects obstructing line of sight, and examining impact of distance and placement locations on an electric research boat.", "result": "Demonstrated how laboratory objects obstructing line of sight attenuate signals between transmitter and receiver, and showed the impact of distance and placement on signal transmission efficiency.", "conclusion": "Environmental factors significantly influence wireless communication performance in dynamic and obstructed environments, with obstructions and distance being key contributors to signal attenuation."}}
{"id": "2509.14744", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14744", "abs": "https://arxiv.org/abs/2509.14744", "authors": ["Worawalan Chatlatanagulchai", "Kundjanasith Thonglek", "Brittany Reid", "Yutaro Kashiwa", "Pattara Leelaprute", "Arnon Rungsawang", "Bundit Manaskasemsak", "Hajimu Iida"], "title": "On the Use of Agentic Coding Manifests: An Empirical Study of Claude Code", "comment": null, "summary": "Agentic coding tools receive goals written in natural language as input,\nbreak them down into specific tasks, and write/execute the actual code with\nminimal human intervention. Key to this process are agent manifests,\nconfiguration files (such as Claude.md) that provide agents with essential\nproject context, identity, and operational rules. However, the lack of\ncomprehensive and accessible documentation for creating these manifests\npresents a significant challenge for developers. We analyzed 253 Claude.md\nfiles from 242 repositories to identify structural patterns and common content.\nOur findings show that manifests typically have shallow hierarchies with one\nmain heading and several subsections, with content dominated by operational\ncommands, technical implementation notes, and high-level architecture.", "AI": {"tldr": "Analysis of 253 Claude.md agent manifest files reveals they typically have shallow hierarchies dominated by operational commands and technical notes, with limited comprehensive documentation available for developers.", "motivation": "Agentic coding tools use manifests (like Claude.md) to provide project context and operational rules, but developers face challenges due to lack of comprehensive documentation for creating these manifests.", "method": "Analyzed 253 Claude.md files from 242 repositories to identify structural patterns and common content in agent manifests.", "result": "Manifests typically have shallow hierarchies with one main heading and several subsections, dominated by operational commands, technical implementation notes, and high-level architecture.", "conclusion": "The study provides insights into current patterns of agent manifest structures, highlighting the need for better documentation standards to support developers in creating effective manifests for agentic coding tools."}}
{"id": "2509.14745", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14745", "abs": "https://arxiv.org/abs/2509.14745", "authors": ["Miku Watanabe", "Hao Li", "Yutaro Kashiwa", "Brittany Reid", "Hajimu Iida", "Ahmed E. Hassan"], "title": "On the Use of Agentic Coding: An Empirical Study of Pull Requests on GitHub", "comment": null, "summary": "Large language models (LLMs) are increasingly being integrated into software\ndevelopment processes. The ability to generate code and submit pull requests\nwith minimal human intervention, through the use of autonomous AI agents, is\npoised to become a standard practice. However, little is known about the\npractical usefulness of these pull requests and the extent to which their\ncontributions are accepted in real-world projects. In this paper, we\nempirically study 567 GitHub pull requests (PRs) generated using Claude Code,\nan agentic coding tool, across 157 diverse open-source projects. Our analysis\nreveals that developers tend to rely on agents for tasks such as refactoring,\ndocumentation, and testing. The results indicate that 83.8% of these\nagent-assisted PRs are eventually accepted and merged by project maintainers,\nwith 54.9% of the merged PRs are integrated without further modification. The\nremaining 45.1% require additional changes benefit from human revisions,\nespecially for bug fixes, documentation, and adherence to project-specific\nstandards. These findings suggest that while agent-assisted PRs are largely\nacceptable, they still benefit from human oversight and refinement.", "AI": {"tldr": "Study of 567 AI-generated pull requests shows 83.8% acceptance rate with over half merged without changes, but human oversight remains valuable for bug fixes and project standards.", "motivation": "As AI agents increasingly generate code and submit pull requests autonomously, there's limited understanding of their practical usefulness and acceptance rates in real-world software projects.", "method": "Empirical analysis of 567 GitHub pull requests generated using Claude Code across 157 diverse open-source projects, examining acceptance rates and modification requirements.", "result": "83.8% of agent-assisted PRs were accepted and merged, with 54.9% integrated without modification. The remaining 45.1% required human revisions, particularly for bug fixes, documentation, and project-specific standards.", "conclusion": "AI-generated pull requests are largely acceptable but still benefit from human oversight and refinement, especially for complex tasks requiring project-specific knowledge and quality assurance."}}
{"id": "2509.14829", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14829", "abs": "https://arxiv.org/abs/2509.14829", "authors": ["Shuo Jin", "Songqiang Chen", "Xiaoyuan Xie", "Shing-Chi Cheung"], "title": "RulER: Automated Rule-Based Semantic Error Localization and Repair for Code Translation", "comment": "Due to the limitation \"The abstract field cannot be longer than 1,920\n  characters\", the abstract here is shorter than that in the PDF file", "summary": "Automated code translation aims to convert programs between different\nprogramming languages while maintaining their functionality. Due to the\nimperfections of code translation models, the generated translations may\ncontain errors that compromise their reliability. Existing automated debugging\nmethods for code translation rely on code alignments and repair patch templates\nto locate and fix erroneous translations. However, existing methods lack\nreliable references to construct code alignments and design repair patch\ntemplates, which significantly impacts their localization accuracy and repair\neffectiveness. To address these limitations, we reintroduce code translation\nrules and propose a rule-based debugging method for code translation, called\nRulER. RulER automatically derives code translation rules from correct\ntranslations generated by LLMs, enabling the efficient collection of diverse\ntranslation rules. In addition, RulER dynamically combines the existing rules\non expandable nodes like expressions and tokens to further adaptively align\nmore statements. These rules capture clear and detailed structural\ncorrespondences between source and target programming languages. Therefore,\nthey can serve as reliable and reusable references for code alignment and\nrepair template design, enabling RulER to locate and fix translation errors\neffectively. Our evaluation of RulER on Java-to-C++ and Python-to-C++\ntranslations produced by four code translation models demonstrates that RulER\noutperforms state-of-the-art methods, BatFix and TransMap. Our experimental\nresults show that RulER outperformed the best baseline by 20% and 272% in terms\nof error localization rates and repair success rates, respectively. RulER\nexhibits superior repair performance compared to directly prompting LLMs for\npatch generation, demonstrating a promising methodology for extracting and\nleveraging coding knowledge from LLMs.", "AI": {"tldr": "RulER is a rule-based debugging method for code translation that automatically derives translation rules from LLM-generated correct translations to improve error localization and repair effectiveness.", "motivation": "Existing automated debugging methods for code translation lack reliable references for code alignments and repair patch templates, which limits their localization accuracy and repair effectiveness.", "method": "RulER automatically derives code translation rules from correct translations generated by LLMs, dynamically combines rules on expandable nodes, and uses these rules as reliable references for code alignment and repair template design.", "result": "RulER outperformed state-of-the-art methods (BatFix and TransMap) by 20% in error localization rates and 272% in repair success rates on Java-to-C++ and Python-to-C++ translations.", "conclusion": "RulER demonstrates superior repair performance compared to directly prompting LLMs and shows promise for extracting and leveraging coding knowledge from LLMs for code translation debugging."}}
{"id": "2509.14856", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14856", "abs": "https://arxiv.org/abs/2509.14856", "authors": ["Hanyang Guo", "Xunjin Zheng", "Zihan Liao", "Hang Yu", "Peng DI", "Ziyin Zhang", "Hong-Ning Dai"], "title": "CodeFuse-CR-Bench: A Comprehensiveness-aware Benchmark for End-to-End Code Review Evaluation in Python Projects", "comment": null, "summary": "Automated code review (CR) is a key application for Large Language Models\n(LLMs), but progress is hampered by a \"reality gap\": existing benchmarks\nevaluate models on isolated sub-tasks using simplified, context-poor data. This\nfails to reflect the holistic context-rich nature of real-world CR. To bridge\nthis gap, we introduce CodeFuse-CR-Bench, the first comprehensiveness-aware\nbenchmark for repository-level CR evaluation. CodeFuse-CR-Bench comprises 601\nhigh-quality instances from 70 Python projects covering nine Pull-Request (PR)\nproblem domains, where each instance provides rich, multi-faceted context\nincluding the associated issue, PR details, and repository state, enabling\nend-to-end evaluation. Beyond superficial metrics, we also propose a novel\nevaluation framework that combines rule-based checks for location and syntax\nwith model-based judgments of review quality. We present the first large-scale\nassessment of state-of-the-art LLMs on this comprehensive CR task. Our results\nestablish crucial baselines and reveal that (1) no single LLM dominates all\naspects of CR; (2) Gemini 2.5 Pro achieves the highest comprehensive\nperformance; and (3) different LLMs exhibit varying robustness to redundant\ncontext. These findings highlight the necessity of holistic, multi-dimensional\nevaluation and provide actionable insights for advancing truly intelligent yet\npractical CR assistants.", "AI": {"tldr": "CodeFuse-CR-Bench is the first comprehensive benchmark for repository-level automated code review evaluation, addressing the reality gap in existing benchmarks by providing rich context and holistic assessment of LLMs.", "motivation": "Existing benchmarks evaluate code review models on isolated sub-tasks with simplified, context-poor data, failing to reflect the holistic context-rich nature of real-world code review processes.", "method": "Created CodeFuse-CR-Bench with 601 high-quality instances from 70 Python projects covering 9 PR domains, each providing rich context including issues, PR details, and repository state. Proposed a novel evaluation framework combining rule-based checks for location/syntax with model-based quality judgments.", "result": "First large-scale assessment shows: (1) no single LLM dominates all CR aspects; (2) Gemini 2.5 Pro achieves highest comprehensive performance; (3) different LLMs exhibit varying robustness to redundant context.", "conclusion": "Holistic, multi-dimensional evaluation is necessary for advancing practical code review assistants, and the benchmark provides crucial baselines and actionable insights for the field."}}
{"id": "2509.14899", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14899", "abs": "https://arxiv.org/abs/2509.14899", "authors": ["Amine Barrak", "Yosr Fourati", "Michael Olchawa", "Emna Ksontini", "Khalil Zoghlami"], "title": "CARGO: A Framework for Confidence-Aware Routing of Large Language Models", "comment": null, "summary": "As large language models (LLMs) proliferate in scale, specialization, and\nlatency profiles, the challenge of routing user prompts to the most appropriate\nmodel has become increasingly critical for balancing performance and cost. We\nintroduce CARGO (Category-Aware Routing with Gap-based Optimization), a\nlightweight, confidence-aware framework for dynamic LLM selection. CARGO\nemploys a single embedding-based regressor trained on LLM-judged pairwise\ncomparisons to predict model performance, with an optional binary classifier\ninvoked when predictions are uncertain. This two-stage design enables precise,\ncost-aware routing without the need for human-annotated supervision. To capture\ndomain-specific behavior, CARGO also supports category-specific regressors\ntrained across five task groups: mathematics, coding, reasoning, summarization,\nand creative writing. Evaluated on four competitive LLMs (GPT-4o, Claude 3.5\nSonnet, DeepSeek V3, and Perplexity Sonar), CARGO achieves a top-1 routing\naccuracy of 76.4% and win rates ranging from 72% to 89% against individual\nexperts. These results demonstrate that confidence-guided, lightweight routing\ncan achieve expert-level performance with minimal overhead, offering a\npractical solution for real-world, multi-model LLM deployments.", "AI": {"tldr": "CARGO is a lightweight framework for routing user prompts to optimal LLMs using embedding-based predictions and optional binary classification for uncertain cases, achieving expert-level routing accuracy without human supervision.", "motivation": "As LLMs proliferate with varying scales, specializations, and latency profiles, there's a growing need for efficient routing systems that balance performance and cost when selecting the most appropriate model for user prompts.", "method": "CARGO employs a single embedding-based regressor trained on LLM-judged pairwise comparisons to predict model performance, with an optional binary classifier for uncertain predictions. It supports category-specific regressors across five task groups: mathematics, coding, reasoning, summarization, and creative writing.", "result": "Evaluated on four competitive LLMs (GPT-4o, Claude 3.5 Sonnet, DeepSeek V3, and Perplexity Sonar), CARGO achieves 76.4% top-1 routing accuracy and win rates ranging from 72% to 89% against individual experts.", "conclusion": "Confidence-guided, lightweight routing like CARGO can achieve expert-level performance with minimal overhead, offering a practical solution for real-world multi-model LLM deployments without requiring human-annotated supervision."}}
{"id": "2509.14931", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14931", "abs": "https://arxiv.org/abs/2509.14931", "authors": ["Stefano Fossati", "Damian Andrew Tamburri", "Massimiliano Di Penta", "Marco Tonnarelli"], "title": "\"Let it be Chaos in the Plumbing!\" Usage and Efficacy of Chaos Engineering in DevOps Pipelines", "comment": "To be published in the Proceedings of International Conference on\n  Software Maintenance and Evolution 2025", "summary": "Chaos Engineering (CE) has emerged as a proactive method to improve the\nresilience of modern distributed systems, particularly within DevOps\nenvironments. Originally pioneered by Netflix, CE simulates real-world failures\nto expose weaknesses before they impact production. In this paper, we present a\nsystematic gray literature review that investigates how industry practitioners\nhave adopted and adapted CE principles over recent years. Analyzing 50 sources\npublished between 2019 and early 2024, we developed a comprehensive\nclassification framework that extends the foundational CE principles into ten\ndistinct concepts. Our study reveals that while the core tenets of CE remain\ninfluential, practitioners increasingly emphasize controlled experimentation,\nautomation, and risk mitigation strategies to align with the demands of agile\nand continuously evolving DevOps pipelines. Our results enhance the\nunderstanding of how CE is intended and implemented in practice, and offer\nguidance for future research and industrial applications aimed at improving\nsystem robustness in dynamic production environments.", "AI": {"tldr": "Systematic review of Chaos Engineering adoption in industry, extending foundational principles into 10 concepts with emphasis on controlled experimentation, automation, and risk mitigation for DevOps environments.", "motivation": "To investigate how industry practitioners have adopted and adapted Chaos Engineering principles in recent years, particularly within DevOps environments where system resilience is critical.", "method": "Conducted a systematic gray literature review analyzing 50 sources published between 2019 and early 2024, developing a comprehensive classification framework.", "result": "Extended foundational Chaos Engineering principles into ten distinct concepts, revealing practitioners' increased emphasis on controlled experimentation, automation, and risk mitigation strategies aligned with agile DevOps pipelines.", "conclusion": "The study enhances understanding of Chaos Engineering implementation in practice and provides guidance for future research and industrial applications to improve system robustness in dynamic production environments."}}
{"id": "2509.15150", "categories": ["cs.SE", "cs.PL", "D.2.6; D.3.3; D.2.3; D.2.5; D.2.13"], "pdf": "https://arxiv.org/pdf/2509.15150", "abs": "https://arxiv.org/abs/2509.15150", "authors": ["Federico Bruzzone", "Walter Cazzola", "Luca Favalli"], "title": "Code Less to Code More: Streamlining Language Server Protocol and Type System Development for Language Families", "comment": "34 pages, 10 figures, Journal of Systems and Software, June 2025, for\n  the replication package, see https://doi.org/10.5281/zenodo.15276991", "summary": "Developing editing support for $L$ languages in $E$ editors is complex and\ntime-consuming. Some languages do not provide dedicated editors, while others\noffer a single native editor. The $\\textit{language server protocol}$ (LSP)\nreduces the language-editor combinations $L \\times E$ to $L + E$, where a\nsingle language server communicates with editors via LSP plugins. However,\noverlapping implementations of linguistic components remain an issue. Existing\nlanguage workbenches struggle with modularity, reusability, and leveraging type\nsystems for language server generation. In this work, we propose: (i) Typelang,\na family of domain-specific languages for modular, composable, and reusable\ntype system implementation, (ii) a modular language server generation process,\nproducing servers for languages built in a modular workbench, (iii) the\nvariant-oriented programming paradigm and a cross-artifact coordination layer\nto manage interdependent software variants, and (iv) an LSP plugin generator,\nreducing $E$ to $1$ by automating plugin creation for multiple editors. To\nsimplify editing support for language families, each language artifact\nintegrates its own Typelang variant, used to generate language servers. This\nreduces combinations to $T \\times 1$, where $T = L$ represents the number of\ntype systems. Further reuse of language artifacts across languages lowers this\nto $N \\times 1$, where $N << T$, representing unique type systems. We implement\nTypelang in Neverlang, generating language servers for each artifact and LSP\nplugins for three editors. Empirical evaluation shows a 93.48% reduction in\ncharacters needed for type system implementation and 100% automation of LSP\nplugin generation, significantly lowering effort for editing support in\nlanguage families, especially when artifacts are reused.", "AI": {"tldr": "Typelang framework reduces language editor support complexity from L\u00d7E to N\u00d71 through modular type systems, automated language server generation, and cross-editor plugin automation, achieving 93.48% code reduction and 100% plugin automation.", "motivation": "Existing language workbenches struggle with modularity, reusability, and type system utilization for language server generation, making editing support development complex and time-consuming for multiple languages and editors.", "method": "Proposes Typelang DSL family for modular type systems, modular language server generation process, variant-oriented programming paradigm with cross-artifact coordination, and automated LSP plugin generator for multiple editors.", "result": "93.48% reduction in characters needed for type system implementation and 100% automation of LSP plugin generation, significantly lowering effort for editing support in language families.", "conclusion": "The approach successfully reduces language-editor combinations through modular reuse and automation, making editing support development more efficient, especially when language artifacts are reused across multiple languages."}}
{"id": "2509.15195", "categories": ["cs.SE", "cs.AI", "cs.CR", "D.4.6; I.2.2; D.2.5"], "pdf": "https://arxiv.org/pdf/2509.15195", "abs": "https://arxiv.org/abs/2509.15195", "authors": ["Max Bazalii", "Marius Fleischer"], "title": "Orion: Fuzzing Workflow Automation", "comment": "11 pages, 3 figures, 3 tables", "summary": "Fuzz testing is one of the most effective techniques for finding software\nvulnerabilities. While modern fuzzers can generate inputs and monitor\nexecutions automatically, the overall workflow, from analyzing a codebase, to\nconfiguring harnesses, to triaging results, still requires substantial manual\neffort. Prior attempts focused on single stages such as harness synthesis or\ninput minimization, leaving researchers to manually connect the pieces into a\ncomplete fuzzing campaign.\n  We introduce Orion, a framework that automates the the manual bottlenecks of\nfuzzing by integrating LLM reasoning with traditional tools, allowing campaigns\nto scale to settings where human effort alone was impractical. Orion uses LLMs\nfor code reasoning and semantic guidance, while relying on deterministic tools\nfor verification, iterative refinement, and tasks that require precision.\nAcross our benchmark suite, Orion reduces human effort by 46-204x depending on\nthe workflow stage, and we demonstrate its effectiveness through the discovery\nof two previously unknown vulnerabilities in the widely used open-source clib\nlibrary.", "AI": {"tldr": "Orion is an automated fuzzing framework that uses LLMs for code reasoning and semantic guidance, combined with traditional tools for verification, reducing human effort by 46-204x and discovering new vulnerabilities.", "motivation": "Modern fuzz testing still requires substantial manual effort across workflow stages (codebase analysis, harness configuration, result triaging), with prior solutions only addressing individual stages rather than providing complete automation.", "method": "Integrates LLM reasoning with traditional tools - uses LLMs for code reasoning and semantic guidance, while relying on deterministic tools for verification, iterative refinement, and precision tasks.", "result": "Reduces human effort by 46-204x depending on workflow stage, and discovered two previously unknown vulnerabilities in the widely used open-source clib library.", "conclusion": "Orion successfully automates manual bottlenecks in fuzzing by combining LLM reasoning with traditional tools, enabling scalable fuzzing campaigns that were previously impractical with human effort alone."}}
