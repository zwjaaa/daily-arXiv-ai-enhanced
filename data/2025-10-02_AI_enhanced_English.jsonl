{"id": "2510.00002", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00002", "abs": "https://arxiv.org/abs/2510.00002", "authors": ["Dong Liu"], "title": "PBFD and PDFD: Formally Defined and Verified Methodologies and Empirical Evaluation for Scalable Full-Stack Software Engineering", "comment": "184 pages; 35 figures; A DOI-linked version of this paper and all\n  supplementary materials are available on Zenodo at\n  https://zenodo.org/records/16883985", "summary": "This paper introduces Primary Breadth-First Development (PBFD) and Primary\nDepth-First Development (PDFD), two formally defined and verified methodologies\nfor scalable, industrial-grade full-stack software engineering. These\napproaches bridge a longstanding gap between formal methods and real-world\ndevelopment practice by enforcing structural correctness through\ngraph-theoretic modeling. Unlike prior graph-based approaches, PBFD and PDFD\noperate over layered directed graphs and are formalized using unified state\nmachines and Communicating Sequential Processes (CSP) to ensure critical\nproperties, including bounded-refinement termination and structural\ncompleteness. To coordinate hierarchical data at scale, we propose Three-Level\nEncapsulation (TLE) - a novel, bitmask-based encoding scheme that delivers\nprovably constant-time updates. TLE's formal guarantees underpin PBFD's\nindustrial-scale performance and scalability. PBFD was empirically validated\nthrough an eight-year enterprise deployment, demonstrating over 20x faster\ndevelopment than Salesforce OmniScript and 7-8x faster query performance\ncompared to conventional relational models. Additionally, both methodologies\nare supported by open-source MVPs, with PDFD's implementation conclusively\ndemonstrating its correctness-first design principles. Together, PBFD and PDFD\nestablish a reproducible, transparent framework that integrates formal\nverification into practical software development. All formal specifications,\nMVPs, and datasets are publicly available to foster academic research and\nindustrial-grade adoption.", "AI": {"tldr": "PBFD and PDFD are formal methodologies for scalable full-stack software engineering that bridge formal methods with real-world practice using graph-theoretic modeling and CSP verification.", "motivation": "To bridge the gap between formal methods and real-world development practice by providing scalable, industrial-grade approaches with structural correctness guarantees.", "method": "Uses layered directed graphs formalized with unified state machines and CSP, plus Three-Level Encapsulation (TLE) for constant-time hierarchical data coordination.", "result": "Empirical validation showed 20x faster development than Salesforce OmniScript and 7-8x faster query performance than conventional relational models in an 8-year enterprise deployment.", "conclusion": "PBFD and PDFD establish a reproducible framework integrating formal verification into practical software development, with open-source implementations available for adoption."}}
{"id": "2510.00003", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00003", "abs": "https://arxiv.org/abs/2510.00003", "authors": ["Malte Hansen", "Jens Bamberg", "Noe Baumann", "Wilhelm Hasselbring"], "title": "Semantic Zoom and Mini-Maps for Software Cities", "comment": "Copyright 2025 IEEE. Personal use of this material is permitted.\n  Permission from IEEE must be obtained for all other uses, in any current or\n  future media, including reprinting/republishing this material for advertising\n  or promotional purposes, creating new collective works, for resale or\n  redistribution to servers or lists, or reuse of any copyrighted component of\n  this work in other works", "summary": "Software visualization tools can facilitate program comprehension by\nproviding visual metaphors, or abstractions that reduce the amount of textual\ndata that needs to be processed mentally. One way they do this is by enabling\ndevelopers to build an internal representation of the visualized software and\nits architecture. However, as the amount of displayed data in the visualization\nincreases, the visualization itself can become more difficult to comprehend.\nThe ability to display small and large amounts of data in visualizations is\ncalled visual scalability.\n  In this paper, we present two approaches to address the challenge of visual\nscalability in 3D software cities. First, we present an approach to semantic\nzoom, in which the graphical representation of the software landscape changes\nbased on the virtual camera's distance from visual objects. Second, we augment\nthe visualization with a miniature two-dimensional top-view projection called\nmini-map. We demonstrate our approach using an open-source implementation in\nour software visualization tool ExplorViz. ExplorViz is web-based and uses the\n3D city metaphor, focusing on live trace visualization.\n  We evaluated our approaches in two separate user studies. The results\nindicate that semantic zoom and the mini-map are both useful additions. User\nfeedback indicates that semantic zoom and mini-maps are especially useful for\nlarge software landscapes and collaborative software exploration. The studies\nindicate a good usability of our implemented approaches. However, some\nshortcomings in our implementations have also been discovered, to be addressed\nin future work.\n  Video URL: https://youtu.be/LYtUeWvizjU", "AI": {"tldr": "This paper presents semantic zoom and mini-map approaches to improve visual scalability in 3D software cities, implemented in the ExplorViz tool and evaluated through user studies.", "motivation": "Software visualizations can become difficult to comprehend as the amount of displayed data increases, creating a visual scalability problem in 3D software cities.", "method": "Two approaches: semantic zoom (changing graphical representation based on camera distance) and mini-map (2D top-view projection), implemented in the web-based ExplorViz tool for live trace visualization.", "result": "User studies showed both approaches are useful additions, especially for large software landscapes and collaborative exploration, with good usability but some implementation shortcomings identified.", "conclusion": "Semantic zoom and mini-maps effectively address visual scalability challenges in 3D software visualizations, though future work is needed to address implementation limitations."}}
{"id": "2510.00004", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00004", "abs": "https://arxiv.org/abs/2510.00004", "authors": ["Malte Hansen", "David Moreno-Lumbreras", "Wilhelm Hasselbring"], "title": "HTML Structure Exploration in 3D Software Cities", "comment": "Copyright 2025 IEEE. Personal use of this material is permitted.\n  Permission from IEEE must be obtained for all other uses, in any current or\n  future media, including reprinting/republishing this material for advertising\n  or promotional purposes, creating new collective works, for resale or\n  redistribution to servers or lists, or reuse of any copyrighted component of\n  this work in other works", "summary": "Software visualization, which uses data from dynamic program analysis, can\nhelp to explore and understand the behavior of software systems. It is common\nthat large software systems offer a web interface for user interaction.\nUsually, available web interfaces are not regarded in software visualization\ntools. This paper introduces additions to the web-based live tracing software\nvisualization tool ExplorViz: We add an embedded web view for instrumented\napplications in the 3D visualization to ease interaction with the given\napplications and enable the exploration of the thereby displayed HTML content.\nNamely, the Document Object Model (DOM) is visualized via a three-dimensional\nrepresentation of the HTML structure in same-origin contexts.\n  Our visualization approach is evaluated in a preliminary user study. The\nstudy results give insights into the potential use cases, benefits, and\nshortcomings of our implemented approach. Based on our study results, we\npropose directions for further research to support the visual exploration of\nweb interfaces and explore use cases for the combined visualization of software\ncities and HTML structure.\n  Video URL: https://youtu.be/wBWKlbvzOOE", "AI": {"tldr": "This paper introduces a web-based software visualization tool called ExplorViz that embeds web views and visualizes the Document Object Model (DOM) in 3D to help understand web interface behavior in software systems.", "motivation": "Large software systems often have web interfaces that are not adequately represented in existing software visualization tools, making it difficult to explore and understand their behavior.", "method": "The authors extended ExplorViz by adding an embedded web view for instrumented applications and created a 3D visualization of the HTML structure (DOM) in same-origin contexts.", "result": "A preliminary user study was conducted, providing insights into potential use cases, benefits, and shortcomings of the approach.", "conclusion": "The study results suggest directions for further research to support visual exploration of web interfaces and explore use cases for combined visualization of software cities and HTML structure."}}
{"id": "2510.00031", "categories": ["cs.SE", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00031", "abs": "https://arxiv.org/abs/2510.00031", "authors": ["Shun-ichiro Hayashi", "Koki Morita", "Daichi Mukunoki", "Tetsuya Hoshino", "Takahiro Katagiri"], "title": "VibeCodeHPC: An Agent-Based Iterative Prompting Auto-Tuner for HPC Code Generation Using LLMs", "comment": null, "summary": "We propose VibeCodeHPC, an automatic tuning system for HPC programs based on\nmulti-agent LLMs for code generation. VibeCodeHPC tunes programs through\nmulti-agent role allocation and iterative prompt refinement. We describe the\nsystem configuration with four roles: Project Manager (PM), System Engineer\n(SE), Programmer (PG), and Continuous Delivery (CD). We introduce dynamic agent\ndeployment and activity monitoring functions to facilitate effective\nmulti-agent collaboration. In our case study, we convert and optimize CPU-based\nmatrix-matrix multiplication code written in C to GPU code using CUDA. The\nmulti-agent configuration of VibeCodeHPC achieved higher-quality code\ngeneration per unit time compared to a solo-agent configuration. Additionally,\nthe dynamic agent deployment and activity monitoring capabilities facilitated\nmore effective identification of requirement violations and other issues.", "AI": {"tldr": "VibeCodeHPC is an automatic tuning system for HPC programs using multi-agent LLMs with role allocation and iterative prompt refinement.", "motivation": "To improve HPC program optimization through effective multi-agent collaboration and automated code generation.", "method": "Uses four agent roles (Project Manager, System Engineer, Programmer, Continuous Delivery) with dynamic deployment and activity monitoring for iterative prompt refinement.", "result": "Achieved higher-quality code generation per unit time compared to solo-agent, with better identification of requirement violations in GPU code conversion case study.", "conclusion": "Multi-agent LLM configuration with dynamic deployment and monitoring enables more effective HPC program optimization than single-agent approaches."}}
{"id": "2510.00092", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00092", "abs": "https://arxiv.org/abs/2510.00092", "authors": ["Shufeng Chen", "Mariat James Elizebeth", "Robab Aghazadeh Chakherlou", "Xingyu Zhao", "Eric Barbier", "Siddartha Khastgir", "Paul Jennings"], "title": "A Scalable Framework for Safety Assurance of Self-Driving Vehicles based on Assurance 2.0", "comment": null, "summary": "Assurance 2.0 is a modern framework developed to address the assurance\nchallenges of increasingly complex, adaptive, and autonomous systems. Building\non the traditional Claims-Argument-Evidence (CAE) model, it introduces reusable\nassurance theories and explicit counterarguments (defeaters) to enhance rigor,\ntransparency, and adaptability. It supports continuous, incremental assurance,\nenabling innovation without compromising safety. However, limitations persist\nin confidence measurement, residual doubt management, automation support, and\nthe practical handling of defeaters and confirmation bias. This paper presents\n\\textcolor{black}{a set of decomposition frameworks to identify a complete set\nof safety arguments and measure their corresponding evidence.} Grounded in the\nAssurance 2.0 paradigm, the framework is instantiated through a structured\ntemplate and employs a three-tiered decomposition strategy. \\textcolor{black}{A\ncase study regarding the application of the decomposition framework in the\nend-to-end (E2E) AI-based Self-Driving Vehicle (SDV) development is also\npresented in this paper.} At the top level, the SDV development is divided into\nthree critical phases: Requirements Engineering (RE), Verification and\nValidation (VnV), and Post-Deployment (PD). Each phase is further decomposed\naccording to its Product Development Lifecycle (PDLC). To ensure comprehensive\ncoverage, each PDLC is analyzed using an adapted 5M1E model (Man, Machine,\nMethod, Material, Measurement, and Environment). Originally developed for\nmanufacturing quality control, the 5M1E model is reinterpreted and contextually\nmapped to the assurance domain. This enables a multi-dimensional decomposition\nthat supports fine-grained traceability of safety claims, evidence, and\npotential defeaters.", "AI": {"tldr": "Assurance 2.0 framework with decomposition strategies for safety arguments in AI-based self-driving vehicles, using 5M1E model for comprehensive coverage.", "motivation": "Address limitations in confidence measurement, residual doubt management, and practical handling of defeaters in complex autonomous systems.", "method": "Three-tiered decomposition strategy: SDV development phases (RE, VnV, PD), Product Development Lifecycle, and adapted 5M1E model (Man, Machine, Method, Material, Measurement, Environment).", "result": "Framework enables fine-grained traceability of safety claims, evidence, and potential defeaters through structured decomposition.", "conclusion": "The decomposition framework provides comprehensive coverage and supports rigorous assurance for complex autonomous systems like self-driving vehicles."}}
{"id": "2510.00197", "categories": ["cs.SE", "D.2.11"], "pdf": "https://arxiv.org/pdf/2510.00197", "abs": "https://arxiv.org/abs/2510.00197", "authors": ["Diogo Maia", "Filipe Correia", "Andr\u00e9 Restivo", "Paulo Queiroz"], "title": "Container Orchestration Patterns for Optimizing Resource Use", "comment": null, "summary": "Service-based architectures provide substantial benefits, yet service\norchestration remains a challenge, particularly for newcomers. While various\nresources on orchestration techniques exist, they often lack clarity and\nstandardization, making best practices difficult to implement and limiting\ntheir adoption within the software industry.\n  To address this gap, we analyzed existing literature and tools to identify\ncommon orchestration practices. Based on our findings, we define three key\norchestration resource optimization patterns: {\\sc Preemptive Scheduling}, {\\sc\nService Balancing}, and {\\sc Garbage Collection}. {\\sc Preemptive Scheduling}\nallows the allocation of sufficient resources for services of higher priority\nin stressful situations, while {\\sc Service Balancing} enables a restructuring\nof the nodes to allow better resource usage. To end, {\\sc Garbage Collection}\ncreates cleanup mechanisms to better understand the system's resource usage and\noptimize it. These patterns serve as foundational elements for improving\norchestration practices and fostering broader adoption in service-based\narchitectures.", "AI": {"tldr": "The paper identifies three key orchestration resource optimization patterns for service-based architectures: Preemptive Scheduling, Service Balancing, and Garbage Collection to address challenges in service orchestration.", "motivation": "Service orchestration remains challenging for newcomers due to lack of clarity and standardization in existing resources, limiting adoption of best practices in the software industry.", "method": "Analyzed existing literature and tools to identify common orchestration practices and defined three optimization patterns based on findings.", "result": "Defined three key patterns: Preemptive Scheduling (priority-based resource allocation), Service Balancing (node restructuring for better resource usage), and Garbage Collection (cleanup mechanisms for resource optimization).", "conclusion": "These patterns serve as foundational elements for improving orchestration practices and fostering broader adoption in service-based architectures."}}
{"id": "2510.00324", "categories": ["cs.SE", "cs.IR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.00324", "abs": "https://arxiv.org/abs/2510.00324", "authors": ["Lucas Roberts", "Denisa Roberts"], "title": "Which Programming Language and Model Work Best With LLM-as-a-Judge For Code Retrieval?", "comment": "Accepted as a full paper at SIGIR-AP 2025", "summary": "Code search is an important information retrieval application. Benefits of\nbetter code search include faster new developer on-boarding, reduced software\nmaintenance, and ease of understanding for large repositories. Despite\nimprovements in search algorithms and search benchmarks, the domain of code\nsearch has lagged behind. One reason is the high cost of human annotation for\ncode queries and answers. While humans may annotate search results in general\ntext QA systems, code annotations require specialized knowledge of a\nprogramming language (PL), as well as domain specific software engineering\nknowledge. In this work we study the use of Large Language Models (LLMs) to\nretrieve code at the level of functions and to generate annotations for code\nsearch results. We compare the impact of the retriever representation (sparse\nvs. semantic), programming language, and LLM by comparing human annotations\nacross several popular languages (C, Java, Javascript, Go, and Python). We\nfocus on repositories that implement common data structures likely to be\nimplemented in any PLs. For the same human annotations, we compare several\nLLM-as-a-Judge models to evaluate programming language and other affinities\nbetween LLMs. We find that the chosen retriever and PL exhibit affinities that\ncan be leveraged to improve alignment of human and AI relevance determinations,\nwith significant performance implications. We also find differences in\nrepresentation (sparse vs. semantic) across PLs that impact alignment of human\nand AI relevance determinations. We propose using transpilers to bootstrap\nscalable code search benchmark datasets in other PLs and in a case study\ndemonstrate that human-AI relevance agreement rates largely match the (worst\ncase) human-human agreement under study. The application code used in this work\nis available at \\href{https://github.com/rlucas7/code-searcher/}{this github\nrepo}.", "AI": {"tldr": "This paper studies using LLMs for code search and annotation, comparing retrieval methods and programming languages to improve human-AI alignment in relevance judgments.", "motivation": "Code search lags behind text search due to high annotation costs requiring programming expertise. The research aims to leverage LLMs to overcome this limitation and improve code retrieval.", "method": "Compared sparse vs. semantic retrieval representations across multiple programming languages (C, Java, Javascript, Go, Python) using LLMs for code annotation and evaluation. Used transpilers to create scalable benchmarks and compared human-AI relevance agreement.", "result": "Found that retriever choice and programming language exhibit affinities that improve human-AI alignment. Different representations perform variably across languages. Human-AI agreement rates matched worst-case human-human agreement.", "conclusion": "LLMs can effectively retrieve and annotate code, with significant performance implications based on retriever and language selection. Transpilers enable scalable benchmark creation across programming languages."}}
{"id": "2510.00328", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00328", "abs": "https://arxiv.org/abs/2510.00328", "authors": ["Ahmed Fawzy", "Amjed Tahir", "Kelly Blincoe"], "title": "Vibe Coding in Practice: Motivations, Challenges, and a Future Outlook -- a Grey Literature Review", "comment": null, "summary": "AI code generation tools are transforming software development, especially\nfor novice and non-software developers, by enabling them to write code and\nbuild applications faster and with little to no human intervention. Vibe coding\nis the practice where users rely on AI code generation tools through intuition\nand trial-and-error without necessarily understanding the underlying code.\nDespite widespread adoption, no research has systematically investigated why\nusers engage in vibe coding, what they experience while doing so, and how they\napproach quality assurance (QA) and perceive the quality of the AI-generated\ncode. To this end, we conduct a systematic grey literature review of 101\npractitioner sources, extracting 518 firsthand behavioral accounts about vibe\ncoding practices, challenges, and limitations. Our analysis reveals a\nspeed-quality trade-off paradox, where vibe coders are motivated by speed and\naccessibility, often experiencing rapid ``instant success and flow'', yet most\nperceive the resulting code as fast but flawed. QA practices are frequently\noverlooked, with many skipping testing, relying on the models' or tools'\noutputs without modification, or delegating checks back to the AI code\ngeneration tools. This creates a new class of vulnerable software developers,\nparticularly those who build a product but are unable to debug it when issues\narise. We argue that vibe coding lowers barriers and accelerates prototyping,\nbut at the cost of reliability and maintainability. These insights carry\nimplications for tool designers and software development teams. Understanding\nhow vibe coding is practiced today is crucial for guiding its responsible use\nand preventing a broader QA crisis in AI-assisted development.", "AI": {"tldr": "Vibe coding enables rapid AI-assisted development but creates a speed-quality trade-off where users skip testing and produce vulnerable code they can't debug.", "motivation": "To systematically investigate why users engage in vibe coding, their experiences, and how they approach quality assurance with AI-generated code.", "method": "Conducted a systematic grey literature review of 101 practitioner sources, extracting 518 firsthand behavioral accounts about vibe coding practices.", "result": "Revealed a speed-quality trade-off paradox: users experience rapid success but perceive code as flawed, often skipping testing and delegating QA back to AI tools.", "conclusion": "Vibe coding lowers barriers and accelerates prototyping but creates vulnerable developers who can't debug their own code, requiring responsible use guidance to prevent QA crisis."}}
{"id": "2510.00450", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00450", "abs": "https://arxiv.org/abs/2510.00450", "authors": ["Sheikh Md. Mushfiqur Rahman", "Nasir Eisty"], "title": "Beyond Pass/Fail: The Story of Learning-Based Testing", "comment": null, "summary": "Learning-Based Testing (LBT) merges learning and testing processes to achieve\nboth testing and behavioral adequacy. LBT utilizes active learning to infer the\nmodel of the System Under Test (SUT), enabling scalability for large and\ncomplex programs by requiring only a minimal set of initial test cases. The\ncore principle of LBT is that the SUT's behavior can be thoroughly inferred by\nprogressively generating test cases and subjecting the SUT to testing, thereby\nensuring comprehensive testing. Despite being in its early stages, LBT has a\nsolid foundation of theoretical research demonstrating its efficacy in testing\nboth procedural and reactive programs. This paper provides a systematic\nliterature review of various LBT implementations across different program types\nand evaluates the current state of research in this field. We explore diverse\ntheoretical frameworks, existing tools, and libraries within the LBT domain to\nillustrate the concept's evolution and current research status. Additionally,\nwe examine case studies involving the application of LBT tools in industrial\nsettings, highlighting their potential and effectiveness in commercial software\ntesting. This systematic literature review aims to offer researchers a\ncomprehensive perspective on the inception and development of LBT, presenting\nit as a promising technique in software testing. By unveiling LBT's\nunderutilized potential, this paper seeks to significantly benefit the\npractitioners and research community.", "AI": {"tldr": "Learning-Based Testing (LBT) combines learning and testing to achieve comprehensive behavioral adequacy, using active learning to infer system models with minimal initial test cases.", "motivation": "To provide a systematic review of LBT implementations across different program types and evaluate current research status, highlighting LBT's potential for commercial software testing.", "method": "Conducted a systematic literature review of various LBT implementations, exploring theoretical frameworks, existing tools, libraries, and industrial case studies.", "result": "LBT has solid theoretical foundations demonstrating efficacy in testing both procedural and reactive programs, with successful industrial applications showing its potential in commercial settings.", "conclusion": "LBT is a promising software testing technique with significant potential that benefits both practitioners and researchers, though it remains in early stages of development."}}
{"id": "2510.00476", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.00476", "abs": "https://arxiv.org/abs/2510.00476", "authors": ["Arushi Sharma", "Vedant Pungliya", "Christopher J. Quinn", "Ali Jannesari"], "title": "Analyzing Latent Concepts in Code Language Models", "comment": null, "summary": "Interpreting the internal behavior of large language models trained on code\nremains a critical challenge, particularly for applications demanding trust,\ntransparency, and semantic robustness. We propose Code Concept Analysis\n(CoCoA): a global post-hoc interpretability framework that uncovers emergent\nlexical, syntactic, and semantic structures in a code language model's\nrepresentation space by clustering contextualized token embeddings into\nhuman-interpretable concept groups. We propose a hybrid annotation pipeline\nthat combines static analysis tool-based syntactic alignment with\nprompt-engineered large language models (LLMs), enabling scalable labeling of\nlatent concepts across abstraction levels. We analyse the distribution of\nconcepts across layers and across three finetuning tasks. Emergent concept\nclusters can help identify unexpected latent interactions and be used to\nidentify trends and biases within the model's learned representations. We\nfurther integrate LCA with local attribution methods to produce\nconcept-grounded explanations, improving the coherence and interpretability of\ntoken-level saliency. Empirical evaluations across multiple models and tasks\nshow that LCA discovers concepts that remain stable under semantic-preserving\nperturbations (average Cluster Sensitivity Index, CSI = 0.288) and evolve\npredictably with fine-tuning. In a user study, concept-augmented explanations\ndisambiguate token roles. In a user study on the programming-language\nclassification task, concept-augmented explanations disambiguated token roles\nand improved human-centric explainability by 37 percentage points compared with\ntoken-level attributions using Integrated Gradients.", "AI": {"tldr": "Code Concept Analysis (CoCoA) is a global interpretability framework that clusters token embeddings into human-interpretable concepts for code language models, improving explainability and robustness.", "motivation": "Interpreting internal behavior of code language models is challenging but critical for trust, transparency, and semantic robustness in applications.", "method": "Proposes CoCoA framework that clusters contextualized token embeddings into concept groups using hybrid annotation combining static analysis tools and LLMs for scalable labeling across abstraction levels.", "result": "CoCoA discovers stable concepts under semantic perturbations (CSI = 0.288), evolves predictably with fine-tuning, and concept-augmented explanations improve human-centric explainability by 37 percentage points compared to token-level attributions.", "conclusion": "CoCoA effectively uncovers interpretable latent structures in code models, enabling better understanding of model behavior and improving explanation quality for human users."}}
{"id": "2510.00501", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00501", "abs": "https://arxiv.org/abs/2510.00501", "authors": ["Kaixin Wang", "Tianlin Li", "Xiaoyu Zhang", "Aishan Liu", "Xianglong Liu", "Ziqi Liu", "Zhiqiang Zhang", "Jun Zhou", "and Bin Shi"], "title": "CodeChemist: Functional Knowledge Transfer for Low-Resource Code Generation via Test-Time Scaling", "comment": null, "summary": "Code Large Language Models (CodeLLMs) are increasingly used in code\ngeneration tasks across a wide range of applications. However, their\nperformance is often inconsistent across different programming languages (PLs),\nwith low-resource PLs suffering the most due to limited training data. In this\npaper, we present CodeChemist, a novel and efficient framework for test-time\nscaling that enables functional knowledge transfer from high-resource to\nlow-resource PLs using generated test cases. CodeChemist first generates and\nexecutes code in high-resource PLs to create test cases that encapsulate\nfunctional knowledge. It then uses multi-temperature hedged sampling to\ngenerate code snippets in the low-resource PL and selects the best one based on\nthe pass rate of the test cases. Our extensive experiments show that\nCodeChemist outperforms existing test-time scaling approaches, boosting the\nperformance of code generation for low-resource PLs without requiring any model\nretraining.", "AI": {"tldr": "CodeChemist is a test-time scaling framework that transfers functional knowledge from high-resource to low-resource programming languages using generated test cases and multi-temperature hedged sampling, improving code generation performance without retraining.", "motivation": "CodeLLMs perform inconsistently across programming languages, with low-resource PLs suffering most due to limited training data, creating a need for efficient knowledge transfer methods.", "method": "Generates and executes code in high-resource PLs to create test cases, then uses multi-temperature hedged sampling to generate code in low-resource PLs and selects the best one based on test case pass rates.", "result": "Outperforms existing test-time scaling approaches and boosts code generation performance for low-resource PLs without requiring model retraining.", "conclusion": "CodeChemist provides an effective framework for functional knowledge transfer between programming languages, addressing the performance gap between high-resource and low-resource PLs in code generation tasks."}}
{"id": "2510.00519", "categories": ["cs.SE", "cs.AI", "D.2.4; D.2.11"], "pdf": "https://arxiv.org/pdf/2510.00519", "abs": "https://arxiv.org/abs/2510.00519", "authors": ["Hadiza Umar Yusuf", "Khouloud Gaaloul"], "title": "Architectural Transformations and Emerging Verification Demands in AI-Enabled Cyber-Physical Systems", "comment": null, "summary": "In the world of Cyber-Physical Systems (CPS), a captivating real-time fusion\noccurs where digital technology meets the physical world. This synergy has been\nsignificantly transformed by the integration of artificial intelligence (AI), a\nmove that dramatically enhances system adaptability and introduces a layer of\ncomplexity that impacts CPS control optimization and reliability. Despite\nadvancements in AI integration, a significant gap remains in understanding how\nthis shift affects CPS architecture, operational complexity, and verification\npractices. The extended abstract addresses this gap by investigating\narchitectural distinctions between AI-driven and traditional control models\ndesigned in Simulink and their respective implications for system verification.", "AI": {"tldr": "This paper investigates architectural differences between AI-driven and traditional control models in Cyber-Physical Systems (CPS), focusing on their implications for system verification.", "motivation": "AI integration in CPS enhances adaptability but introduces complexity that affects control optimization and reliability. There's a gap in understanding how this shift impacts CPS architecture, operational complexity, and verification practices.", "method": "The study investigates architectural distinctions between AI-driven and traditional control models designed in Simulink.", "result": "The research addresses the gap in understanding how AI integration affects CPS architecture and verification practices.", "conclusion": "The paper provides insights into the architectural differences between AI-driven and traditional CPS control models and their verification implications."}}
{"id": "2510.00532", "categories": ["cs.SE", "cs.CR", "D.2.5"], "pdf": "https://arxiv.org/pdf/2510.00532", "abs": "https://arxiv.org/abs/2510.00532", "authors": ["Hengcheng Zhu", "Songqiang Chen", "Valerio Terragni", "Lili Wei", "Jiarong Wu", "Yepang Liu", "Shing-Chi Cheung"], "title": "LSPFuzz: Hunting Bugs in Language Servers", "comment": "This paper has been accepted for publication in The 40th IEEE/ACM\n  International Conference on Automated Software Engineering (ASE 2025)", "summary": "The Language Server Protocol (LSP) has revolutionized the integration of code\nintelligence in modern software development. There are approximately 300 LSP\nserver implementations for various languages and 50 editors offering LSP\nintegration. However, the reliability of LSP servers is a growing concern, as\ncrashes can disable all code intelligence features and significantly impact\nproductivity, while vulnerabilities can put developers at risk even when\nediting untrusted source code. Despite the widespread adoption of LSP, no\nexisting techniques specifically target LSP server testing. To bridge this gap,\nwe present LSPFuzz, a grey-box hybrid fuzzer for systematic LSP server testing.\nOur key insight is that effective LSP server testing requires holistic mutation\nof source code and editor operations, as bugs often manifest from their\ncombinations. To satisfy the sophisticated constraints of LSP and effectively\nexplore the input space, we employ a two-stage mutation pipeline: syntax-aware\nmutations to source code, followed by context-aware dispatching of editor\noperations. We evaluated LSPFuzz on four widely used LSP servers. LSPFuzz\ndemonstrated superior performance compared to baseline fuzzers, and uncovered\npreviously unknown bugs in real-world LSP servers. Of the 51 bugs we reported,\n42 have been confirmed, 26 have been fixed by developers, and two have been\nassigned CVE numbers. Our work advances the quality assurance of LSP servers,\nproviding both a practical tool and foundational insights for future research\nin this domain.", "AI": {"tldr": "LSPFuzz is a grey-box hybrid fuzzer designed specifically for testing Language Server Protocol (LSP) servers, addressing the gap in LSP server reliability testing.", "motivation": "LSP servers are widely used but lack dedicated testing techniques, and their crashes or vulnerabilities can significantly impact developer productivity and security.", "method": "Two-stage mutation pipeline: syntax-aware mutations to source code followed by context-aware dispatching of editor operations, using grey-box hybrid fuzzing approach.", "result": "LSPFuzz outperformed baseline fuzzers and discovered 51 bugs in real-world LSP servers, with 42 confirmed, 26 fixed, and 2 assigned CVE numbers.", "conclusion": "LSPFuzz advances LSP server quality assurance by providing an effective testing tool and foundational insights for future research in this domain."}}
{"id": "2510.00591", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.00591", "abs": "https://arxiv.org/abs/2510.00591", "authors": ["Liyi Cai", "Yijie Ren", "Yitong Zhang", "Jia Li"], "title": "AI-Driven Self-Evolving Software: A Promising Path Toward Software Automation", "comment": null, "summary": "Software automation has long been a central goal of software engineering,\nstriving for software development that proceeds without human intervention.\nRecent efforts have leveraged Artificial Intelligence (AI) to advance software\nautomation with notable progress. However, current AI functions primarily as\nassistants to human developers, leaving software development still dependent on\nexplicit human intervention. This raises a fundamental question: Can AI move\nbeyond its role as an assistant to become a core component of software, thereby\nenabling genuine software automation? To investigate this vision, we introduce\nAI-Driven Self-Evolving Software, a new form of software that evolves\ncontinuously through direct interaction with users. We demonstrate the\nfeasibility of this idea with a lightweight prototype built on a multi-agent\narchitecture that autonomously interprets user requirements, generates and\nvalidates code, and integrates new functionalities. Case studies across\nmultiple representative scenarios show that the prototype can reliably\nconstruct and reuse functionality, providing early evidence that such software\nsystems can scale to more sophisticated applications and pave the way toward\ntruly automated software development. We make code and cases in this work\npublicly available at https://anonymous.4open.science/r/live-software.", "AI": {"tldr": "AI-Driven Self-Evolving Software enables continuous software evolution through direct user interaction, moving beyond AI assistance to become a core component that autonomously interprets requirements, generates code, and integrates new functionalities.", "motivation": "Current AI in software development primarily serves as assistants to humans, requiring explicit human intervention. The goal is to move AI beyond assistance to become a core component enabling genuine software automation without human dependency.", "method": "A lightweight prototype built on multi-agent architecture that autonomously interprets user requirements, generates and validates code, and integrates new functionalities through direct interaction with users.", "result": "Case studies across multiple representative scenarios show the prototype can reliably construct and reuse functionality, providing evidence that such systems can scale to more sophisticated applications.", "conclusion": "AI-Driven Self-Evolving Software demonstrates feasibility of continuous software evolution through user interaction, paving the way toward truly automated software development where AI becomes a core component rather than just an assistant."}}
{"id": "2510.00674", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00674", "abs": "https://arxiv.org/abs/2510.00674", "authors": ["Konstantinos Karakatsanis", "Georgios Alexopoulos", "Ioannis Karyotakis", "Foivos Timotheos Proestakis", "Evangelos Talos", "Panos Louridas", "Dimitris Mitropoulos"], "title": "PyTrim: A Practical Tool for Reducing Python Dependency Bloat", "comment": "Accepted at ASE 2025 (Tool Demonstration Track)", "summary": "Dependency bloat is a persistent challenge in Python projects, which\nincreases maintenance costs and security risks. While numerous tools exist for\ndetecting unused dependencies in Python, removing these dependencies across the\nsource code and configuration files of a project requires manual effort and\nexpertise.\n  To tackle this challenge we introduce PYTRIM, an end-to-end system to\nautomate this process. PYTRIM eliminates unused imports and package\ndeclarations across a variety of file types, including Python source and\nconfiguration files such as requirements.txt and setup.py. PYTRIM's modular\ndesign makes it agnostic to the source of dependency bloat information,\nenabling integration with any detection tool. Beyond its contribution when it\ncomes to automation, PYTRIM also incorporates a novel dynamic analysis\ncomponent that improves dependency detection recall.\n  Our evaluation of PYTRIM's end-to-end effectiveness on a ground-truth dataset\nof 37 merged pull requests from prior work, shows that PYTRIM achieves 98.3%\naccuracy in replicating human-made changes. To show its practical impact, we\nrun PYTRIM on 971 open-source packages, identifying and trimming bloated\ndependencies in 39 of them. For each case, we submit a corresponding pull\nrequest, 6 of which have already been accepted and merged. PYTRIM is available\nas an open-source project, encouraging community contributions and further\ndevelopment.\n  Video demonstration: https://youtu.be/LqTEdOUbJRI\n  Code repository: https://github.com/TrimTeam/PyTrim", "AI": {"tldr": "PYTRIM is an automated system that removes unused dependencies in Python projects across source code and configuration files, achieving 98.3% accuracy in replicating human-made changes and successfully trimming dependencies in 39 open-source packages.", "motivation": "Dependency bloat in Python projects increases maintenance costs and security risks, and while detection tools exist, removing these dependencies requires manual effort and expertise.", "method": "PYTRIM is an end-to-end system that eliminates unused imports and package declarations across Python source files and configuration files. It has a modular design that works with any detection tool and includes a novel dynamic analysis component to improve dependency detection recall.", "result": "Evaluation on 37 merged pull requests showed 98.3% accuracy in replicating human-made changes. Applied to 971 open-source packages, PYTRIM identified and trimmed bloated dependencies in 39 packages, with 6 pull requests already accepted and merged.", "conclusion": "PYTRIM effectively automates the removal of unused dependencies in Python projects, demonstrating high accuracy and practical impact on real-world open-source packages."}}
{"id": "2510.00680", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00680", "abs": "https://arxiv.org/abs/2510.00680", "authors": ["Hang Cui", "Jingjing Li", "Haotian Si", "Quan Zhou", "Changhua Pei", "Gaogang Xie", "Dan Pei"], "title": "TShape: Rescuing Machine Learning Models from Complex Shapelet Anomalies", "comment": null, "summary": "Time series anomaly detection (TSAD) is critical for maintaining the\nreliability of modern IT infrastructures, where complex anomalies frequently\narise in highly dynamic environments. In this paper, we present TShape, a novel\nframework designed to address the challenges in industrial time series anomaly\ndetection. Existing methods often struggle to detect shapelet anomalies that\nmanifest as complex shape deviations, which appear obvious to human experts but\nprove challenging for machine learning algorithms. TShape introduces a\npatch-wise dual attention mechanism with multi-scale convolution to model\nintricate sub-sequence variations by balancing local, fine-grained shape\nfeatures with global contextual dependencies. Our extensive evaluation on five\ndiverse benchmarks demonstrates that TShape outperforms existing\nstate-of-the-art models, achieving an average 10\\% F1 score improvement in\nanomaly detection. Additionally, ablation studies and attention visualizations\nconfirm the essential contributions of each component, highlighting the\nrobustness and adaptability of TShape to complex shapelet shapes in time series\ndata.", "AI": {"tldr": "TShape is a novel framework for time series anomaly detection that uses patch-wise dual attention with multi-scale convolution to detect complex shapelet anomalies, achieving 10% F1 score improvement over state-of-the-art methods.", "motivation": "Existing TSAD methods struggle to detect shapelet anomalies - complex shape deviations that are obvious to humans but challenging for ML algorithms, particularly in dynamic industrial environments.", "method": "TShape introduces a patch-wise dual attention mechanism with multi-scale convolution to model sub-sequence variations by balancing local shape features with global contextual dependencies.", "result": "Extensive evaluation on five benchmarks shows TShape outperforms state-of-the-art models with average 10% F1 score improvement in anomaly detection.", "conclusion": "Ablation studies and attention visualizations confirm the robustness and adaptability of TShape for detecting complex shapelet shapes in time series data."}}
{"id": "2510.00730", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.00730", "abs": "https://arxiv.org/abs/2510.00730", "authors": ["Larissa Schmid", "Elias Lundell", "Yogya Gamage", "Benoit Baudry", "Martin Monperrus"], "title": "Maven-Lockfile: High Integrity Rebuild of Past Java Releases", "comment": null, "summary": "Modern software projects depend on many third-party libraries, complicating\nreproducible and secure builds. Several package managers address this with the\ngeneration of a lockfile that freezes dependency versions and can be used to\nverify the integrity of dependencies. Yet, Maven, one of the most important\npackage managers in the Java ecosystem, lacks native support for a lockfile. We\npresent Maven-Lockfile to generate and update lockfiles, with support for\nrebuilding projects from past versions. Our lockfiles capture all direct and\ntransitive dependencies with their checksums, enabling high integrity builds.\nOur evaluation shows that Maven-Lockfile can reproduce builds from historical\ncommits and is able to detect tampered artifacts. With minimal configuration,\nMaven-Lockfile equips Java projects with modern build integrity and build\nreproducibility, and fosters future research on software supply chain security\nin Java.", "AI": {"tldr": "Maven-Lockfile provides lockfile generation and update capabilities for Maven projects, enabling reproducible builds and dependency integrity verification in the Java ecosystem.", "motivation": "Maven lacks native lockfile support, which complicates reproducible and secure builds in Java projects that depend on many third-party libraries.", "method": "The tool generates and updates lockfiles that capture all direct and transitive dependencies with their checksums, supporting rebuilding projects from past versions.", "result": "Evaluation shows Maven-Lockfile can reproduce builds from historical commits and detect tampered artifacts with minimal configuration.", "conclusion": "Maven-Lockfile equips Java projects with modern build integrity and reproducibility, fostering future research on software supply chain security in Java."}}
{"id": "2510.00762", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.00762", "abs": "https://arxiv.org/abs/2510.00762", "authors": ["Rudrajit Choudhuri", "Carmen Badea", "Christian Bird", "Jenna Butler", "Rob DeLine", "Brian Houck"], "title": "AI Where It Matters: Where, Why, and How Developers Want AI Support in Daily Work", "comment": null, "summary": "Generative AI is reshaping software work, yet we lack clear guidance on where\ndevelopers most need and want support, and how to design it responsibly. We\nreport a large-scale, mixed-methods study of N=860 developers that examines\nwhere, why, and how they seek or limit AI help, providing the first task-aware,\nempirically validated mapping from developers' perceptions of their tasks to AI\nadoption patterns and responsible AI priorities. Using cognitive appraisal\ntheory, we show that task evaluations predict openness to and use of AI,\nrevealing distinct patterns: strong current use and a desire for improvement in\ncore work (e.g., coding, testing); high demand to reduce toil (e.g.,\ndocumentation, operations); and clear limits for identity- and\nrelationship-centric work (e.g., mentoring). Priorities for responsible AI\nsupport vary by context: reliability and security for systems-facing tasks;\ntransparency, alignment, and steerability to maintain control; and fairness and\ninclusiveness for human-facing work. Our results offer concrete, contextual\nguidance for delivering AI where it matters to developers and their work.", "AI": {"tldr": "A large-scale study of 860 developers reveals task-specific patterns in AI adoption: strong use in coding/testing, high demand for reducing documentation/operations toil, and clear limits for mentoring work. Responsible AI priorities vary by context.", "motivation": "To provide empirical guidance on where developers most need AI support and how to design it responsibly, addressing the gap in understanding AI adoption patterns in software work.", "method": "Large-scale mixed-methods study of 860 developers using cognitive appraisal theory to examine where, why, and how developers seek or limit AI help across different tasks.", "result": "Task evaluations predict AI adoption patterns: strong current use in core work (coding/testing), high demand for reducing toil (documentation/operations), and clear limits for identity/relationship work (mentoring). Responsible AI priorities vary by task context.", "conclusion": "The study provides concrete, contextual guidance for delivering AI support where it matters most to developers, with varying responsible AI priorities depending on whether tasks are systems-facing or human-facing."}}
{"id": "2510.00881", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.00881", "abs": "https://arxiv.org/abs/2510.00881", "authors": ["Patrizio Migliarini", "Mashal Afzal Memon", "Marco Autili", "Paola Inverardi"], "title": "Advancing Automated Ethical Profiling in SE: a Zero-Shot Evaluation of LLM Reasoning", "comment": "Accepted at ASE 2025", "summary": "Large Language Models (LLMs) are increasingly integrated into software\nengineering (SE) tools for tasks that extend beyond code synthesis, including\njudgment under uncertainty and reasoning in ethically significant contexts. We\npresent a fully automated framework for assessing ethical reasoning\ncapabilities across 16 LLMs in a zero-shot setting, using 30 real-world\nethically charged scenarios. Each model is prompted to identify the most\napplicable ethical theory to an action, assess its moral acceptability, and\nexplain the reasoning behind their choice. Responses are compared against\nexpert ethicists' choices using inter-model agreement metrics. Our results show\nthat LLMs achieve an average Theory Consistency Rate (TCR) of 73.3% and Binary\nAgreement Rate (BAR) on moral acceptability of 86.7%, with interpretable\ndivergences concentrated in ethically ambiguous cases. A qualitative analysis\nof free-text explanations reveals strong conceptual convergence across models\ndespite surface-level lexical diversity. These findings support the potential\nviability of LLMs as ethical inference engines within SE pipelines, enabling\nscalable, auditable, and adaptive integration of user-aligned ethical\nreasoning. Our focus is the Ethical Interpreter component of a broader\nprofiling pipeline: we evaluate whether current LLMs exhibit sufficient\ninterpretive stability and theory-consistent reasoning to support automated\nprofiling.", "AI": {"tldr": "LLMs show promising ethical reasoning capabilities with 73.3% theory consistency and 86.7% moral acceptability agreement in zero-shot testing across 30 real-world ethical scenarios.", "motivation": "To assess whether LLMs can serve as reliable ethical inference engines in software engineering tools, particularly for judgment under uncertainty and ethically significant contexts.", "method": "Fully automated framework testing 16 LLMs in zero-shot setting using 30 real-world ethically charged scenarios, comparing responses against expert ethicists using inter-model agreement metrics.", "result": "LLMs achieved 73.3% Theory Consistency Rate and 86.7% Binary Agreement Rate on moral acceptability, with interpretable divergences mainly in ethically ambiguous cases.", "conclusion": "LLMs demonstrate sufficient interpretive stability and theory-consistent reasoning to potentially serve as ethical inference engines in SE pipelines, enabling scalable and auditable ethical reasoning integration."}}
{"id": "2510.00920", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00920", "abs": "https://arxiv.org/abs/2510.00920", "authors": ["Songqiang Chen", "Congying Xu", "Jingyi Chen", "Jialun Cao", "Jiarong Wu", "Shing-Chi Cheung"], "title": "On Effective Semantic Translation for Code: A Study Based on Pseudocode", "comment": null, "summary": "Large language models (LLMs) show great potential in code translation.\nHowever, accurate translation remains challenging when using the commonly\nadopted direct code-to-code translation approach, which converts a program into\nthe target programming language (PL) in a single step. Inspired by the success\nof incorporating intermediate steps to guide LLMs in resolving challenging\ntasks, we explore pseudocode-based code translation, which emulates the human\nsemantic translation by first interpreting the program's intent and logic into\npseudocode and then implementing it in the target PL. We find that\npseudocode-based translation helps translate programs that direct translation\nstruggles to handle. Nonetheless, the effectiveness, advantages, and\nlimitations of this approach remain underexplored. To bridge this gap, we\npresent an empirical study on pseudocode-based code translation, aiming to\ninvestigate its effectiveness in enhancing the direct translation approach,\nilluminate its effective usage, and identify limitations hindering its\npotential benefits. By comparing direct and pseudocode-based translation\napproaches on 9,690 translation tasks across six PLs with five popular LLMs, we\ndemonstrate that pseudocode-based translation can effectively complement direct\ntranslation, particularly when translating from flexible to rigid PLs or\ndealing with low-resource Rust. Based on these findings, we suggest adopting\nstrategies that combine the complementary strengths of both approaches to\nenhance code translation accuracy. We also reveal the advantages of\npseudocode-based translation in disentangling translations of complicated\nprograms and mitigating distractions from detailed implementations in original\nprograms, as well as its limitations due to incorrect, incomplete, or ambiguous\npseudocode.", "AI": {"tldr": "Pseudocode-based code translation improves LLM performance by first converting code to pseudocode then to target language, complementing direct translation especially for flexible-to-rigid language pairs and low-resource scenarios.", "motivation": "Direct code-to-code translation struggles with accuracy, so researchers explore pseudocode-based approach inspired by human semantic translation to improve LLM performance in code translation.", "method": "Empirical study comparing direct and pseudocode-based translation approaches on 9,690 tasks across 6 programming languages using 5 popular LLMs.", "result": "Pseudocode-based translation effectively complements direct translation, particularly for flexible-to-rigid PL conversions and low-resource Rust scenarios, showing advantages in handling complex programs and reducing implementation distractions.", "conclusion": "Combining both approaches leverages their complementary strengths, though pseudocode limitations include incorrect, incomplete, or ambiguous pseudocode generation."}}
{"id": "2510.00946", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00946", "abs": "https://arxiv.org/abs/2510.00946", "authors": ["Shiza Andleeb", "Brandon Kantorski", "Jeffrey C. Carver"], "title": "ChatGPT in Introductory Programming: Counterbalanced Evaluation of Code Quality, Conceptual Learning, and Student Perceptions", "comment": "Accepted to SIGCITE'25", "summary": "Background: Large language models (LLMs) such as ChatGPT are increasingly\nused in introductory programming courses to provide real-time code generation,\ndebugging, and explanations. While these tools can boost productivity and code\nquality, concerns remain about over-reliance and potential impacts on\nconceptual learning. Objective: To investigate how ChatGPT access affects code\nquality, conceptual understanding, task completion times, and student\nperceptions in a CS1 course. Methods: We conducted a counterbalanced,\nquasi-experimental study in which students alternated between ChatGPT and\nnon-ChatGPT conditions across two programming assignments in C (functions and\nstructures). We evaluated their code submissions using multidimensional\nrubrics, conceptual post-surveys, and task completion time. Results: Students\nwho had access to ChatGPT produced significantly higher rubric scores for code\nquality and completed tasks in less time compared to those without access.\nHowever, gains in conceptual understanding were mixed, lower for the functions\ntopic but higher for the structures topic. Students reported positive\nexperiences with ChatGPT, citing its value for debugging and practice, while\nexpressing concerns about accuracy and long-term skill development.\nConclusions: ChatGPT can enhance code quality and efficiency for novice\nprogrammers, but may not uniformly improve conceptual understanding. Structured\nintegration and complementary instructional strategies are recommended to\nfoster independent problem-solving skills.", "AI": {"tldr": "ChatGPT improves code quality and efficiency for novice programmers but has mixed effects on conceptual understanding, requiring structured integration to support learning.", "motivation": "To investigate how ChatGPT access affects code quality, conceptual understanding, task completion times, and student perceptions in introductory programming courses.", "method": "Counterbalanced quasi-experimental study where students alternated between ChatGPT and non-ChatGPT conditions across two programming assignments in C (functions and structures), using multidimensional rubrics, conceptual post-surveys, and task completion time measurements.", "result": "Students with ChatGPT access produced significantly higher code quality scores and completed tasks faster, but conceptual understanding gains were mixed (lower for functions, higher for structures). Students reported positive experiences for debugging but concerns about accuracy and long-term skill development.", "conclusion": "ChatGPT enhances code quality and efficiency but doesn't uniformly improve conceptual understanding; structured integration and complementary instructional strategies are needed to foster independent problem-solving skills."}}
{"id": "2510.00957", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00957", "abs": "https://arxiv.org/abs/2510.00957", "authors": ["Shiza Andleeb", "Teo Mendoza", "Lucas Cordova", "Gursimran Walia", "Jeffrey C. Carver"], "title": "Enhancing Software Testing Education: Understanding Where Students Struggle", "comment": "Accepted to SIGCITE'25", "summary": "Effective software testing is critical for producing reliable and secure\nsoftware, yet many computer science students struggle to master the\nfoundational concepts required to construct comprehensive test suites. While\nautomated feedback tools are widely used to support student learning, it\nremains unclear which testing concepts are most frequently misunderstood and\nhow these misunderstandings are reflected in students' test suite revisions.\nThis study examines the specific testing concepts that lead students to make\nineffective changes, those that fail to improve code coverage, during test\nsuite development. Leveraging an automated feedback tool in a senior-level\nsoftware testing course, we analyzed student submissions from two assignments\nto identify prevalent conceptual gaps and patterns of unproductive\nmodification. Our results reveal that decision coverage and exception handling\nare persistent challenges, and that students most often make superficial or\nmethod-level changes that do not enhance coverage. These findings provide\nactionable insights for educators, researchers, and tool designers. By\npinpointing the concepts that most often contribute to poor testing outcomes,\nwe can refine feedback systems, target instruction to address persistent\nmisconceptions, and more effectively support students in developing robust,\nmaintainable test suites.", "AI": {"tldr": "Analysis of student testing misconceptions in software engineering education, revealing decision coverage and exception handling as major challenges that lead to ineffective test suite revisions.", "motivation": "To identify specific testing concepts that students struggle with and understand how these misunderstandings manifest in unproductive test suite modifications during software testing education.", "method": "Analyzed student submissions from two assignments in a senior-level software testing course using an automated feedback tool to identify conceptual gaps and patterns of ineffective modifications.", "result": "Found that decision coverage and exception handling are persistent challenges, with students making superficial or method-level changes that fail to improve code coverage.", "conclusion": "The findings provide actionable insights for improving feedback systems, targeting instruction to address persistent misconceptions, and better supporting students in developing robust test suites."}}
{"id": "2510.01002", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.01002", "abs": "https://arxiv.org/abs/2510.01002", "authors": ["Chengran Yang", "Ting Zhang", "Jinfeng Jiang", "Xin Zhou", "Haoye Tian", "Jieke Shi", "Junkai Chen", "Yikun Li", "Eng Lieh Ouh", "Lwin Khin Shar", "David Lo"], "title": "Semantics-Aligned, Curriculum-Driven, and Reasoning-Enhanced Vulnerability Repair Framework", "comment": null, "summary": "Current learning-based Automated Vulnerability Repair (AVR) approaches, while\npromising, often fail to generalize effectively in real-world scenarios. Our\ndiagnostic analysis reveals three fundamental weaknesses in state-of-the-art\nAVR approaches: (1) limited cross-repository generalization, with performance\ndrops on unseen codebases; (2) inability to capture long-range dependencies,\ncausing a performance degradation on complex, multi-hunk repairs; and (3)\nover-reliance on superficial lexical patterns, leading to significant\nperformance drops on vulnerabilities with minor syntactic variations like\nvariable renaming.\n  To address these limitations, we propose SeCuRepair, a semantics-aligned,\ncurriculum-driven, and reasoning-enhanced framework for vulnerability repair.\nAt its core, SeCuRepair adopts a reason-then-edit paradigm, requiring the model\nto articulate why and how a vulnerability should be fixed before generating the\npatch. This explicit reasoning enforces a genuine understanding of repair logic\nrather than superficial memorization of lexical patterns. SeCuRepair also moves\nbeyond traditional supervised fine-tuning and employs semantics-aware\nreinforcement learning, rewarding patches for their syntactic and semantic\nalignment with the oracle patch rather than mere token overlap. Complementing\nthis, a difficulty-aware curriculum progressively trains the model, starting\nwith simple fixes and advancing to complex, multi-hunk coordinated edits.\n  We evaluate SeCuRepair on strict, repository-level splits of BigVul and newly\ncrafted PrimeVul_AVR datasets. SeCuRepair significantly outperforms all\nbaselines, surpassing the best-performing baselines by 34.52% on BigVul and\n31.52% on PrimeVul\\textsubscript{AVR} in terms of CodeBLEU, respectively.\nComprehensive ablation studies further confirm that each component of our\nframework contributes to its final performance.", "AI": {"tldr": "SeCuRepair is a novel vulnerability repair framework that addresses limitations in current learning-based approaches by using explicit reasoning, semantics-aware reinforcement learning, and difficulty-aware curriculum training to improve generalization and handle complex repairs.", "motivation": "Current Automated Vulnerability Repair (AVR) approaches suffer from poor generalization across repositories, inability to handle long-range dependencies in multi-hunk repairs, and over-reliance on superficial lexical patterns that fail with minor syntactic variations.", "method": "SeCuRepair uses a reason-then-edit paradigm where models must articulate repair logic before generating patches. It employs semantics-aware reinforcement learning that rewards syntactic and semantic alignment rather than token overlap, and a difficulty-aware curriculum that progresses from simple to complex repairs.", "result": "SeCuRepair significantly outperforms all baselines, achieving 34.52% improvement on BigVul and 31.52% on PrimeVul_AVR in terms of CodeBLEU. Comprehensive ablation studies confirm each component contributes to the final performance.", "conclusion": "The proposed framework effectively addresses fundamental weaknesses in current AVR approaches through explicit reasoning, semantics-aligned training, and progressive curriculum learning, demonstrating substantial improvements in vulnerability repair performance and generalization."}}
{"id": "2510.01003", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.01003", "abs": "https://arxiv.org/abs/2510.01003", "authors": ["Boshi Wang", "Weijian Xu", "Yunsheng Li", "Mei Gao", "Yujia Xie", "Huan Sun", "Dongdong Chen"], "title": "Improving Code Localization with Repository Memory", "comment": "15 pages, 8 figures", "summary": "Code localization is a fundamental challenge in repository-level software\nengineering tasks such as bug fixing. While existing methods equip language\nagents with comprehensive tools/interfaces to fetch information from the\nrepository, they overlook the critical aspect of memory, where each instance is\ntypically handled from scratch assuming no prior repository knowledge. In\ncontrast, human developers naturally build long-term repository memory, such as\nthe functionality of key modules and associations between various bug types and\ntheir likely fix locations. In this work, we augment language agents with such\nmemory by leveraging a repository's commit history - a rich yet underutilized\nresource that chronicles the codebase's evolution. We introduce tools that\nallow the agent to retrieve from a non-parametric memory encompassing recent\nhistorical commits and linked issues, as well as functionality summaries of\nactively evolving parts of the codebase identified via commit patterns. We\ndemonstrate that augmenting such a memory can significantly improve LocAgent, a\nstate-of-the-art localization framework, on both SWE-bench-verified and the\nmore recent SWE-bench-live benchmarks. Our research contributes towards\ndeveloping agents that can accumulate and leverage past experience for\nlong-horizon tasks, more closely emulating the expertise of human developers.", "AI": {"tldr": "Augmenting language agents with repository memory from commit history improves code localization performance on SWE-bench benchmarks.", "motivation": "Existing methods handle code localization from scratch without prior repository knowledge, unlike human developers who build long-term memory about functionality and bug-fix associations.", "method": "Introduce tools for agents to retrieve from non-parametric memory including recent historical commits, linked issues, and functionality summaries of actively evolving code parts identified via commit patterns.", "result": "Significantly improves LocAgent (state-of-the-art localization framework) on both SWE-bench-verified and SWE-bench-live benchmarks.", "conclusion": "Repository memory augmentation enables agents to accumulate and leverage past experience for long-horizon tasks, more closely emulating human developer expertise."}}
{"id": "2510.01024", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01024", "abs": "https://arxiv.org/abs/2510.01024", "authors": ["Elvis J\u00fanior", "Alan Valejo", "Jorge Valverde-Rebaza", "V\u00e2nia de Oliveira Neves"], "title": "GenIA-E2ETest: A Generative AI-Based Approach for End-to-End Test Automation", "comment": "Preprint of a paper published at the 39th Brazilian Symposium on\n  Software Engineering (SBES 2025). Please cite the published version:\n  https://sol.sbc.org.br/index.php/sbes/article/view/37006", "summary": "Software testing is essential to ensure system quality, but it remains\ntime-consuming and error-prone when performed manually. Although recent\nadvances in Large Language Models (LLMs) have enabled automated test\ngeneration, most existing solutions focus on unit testing and do not address\nthe challenges of end-to-end (E2E) testing, which validates complete\napplication workflows from user input to final system response. This paper\nintroduces GenIA-E2ETest, which leverages generative AI to generate executable\nE2E test scripts from natural language descriptions automatically. We evaluated\nthe approach on two web applications, assessing completeness, correctness,\nadaptation effort, and robustness. Results were encouraging: the scripts\nachieved an average of 77% for both element metrics, 82% for precision of\nexecution, 85% for execution recall, required minimal manual adjustments\n(average manual modification rate of 10%), and showed consistent performance in\ntypical web scenarios. Although some sensitivity to context-dependent\nnavigation and dynamic content was observed, the findings suggest that\nGenIA-E2ETest is a practical and effective solution to accelerate E2E test\nautomation from natural language, reducing manual effort and broadening access\nto automated testing.", "AI": {"tldr": "GenIA-E2ETest uses generative AI to automatically create executable end-to-end test scripts from natural language descriptions, achieving 77% completeness/correctness, 82% precision, 85% recall with only 10% manual modification.", "motivation": "Manual software testing is time-consuming and error-prone. While LLMs enable automated test generation, existing solutions focus on unit testing and don't address the challenges of end-to-end testing that validates complete application workflows.", "method": "Leverages generative AI to automatically generate executable E2E test scripts from natural language descriptions. Evaluated on two web applications assessing completeness, correctness, adaptation effort, and robustness.", "result": "Scripts achieved 77% for both element metrics, 82% precision of execution, 85% execution recall, required only 10% manual modification, and showed consistent performance in typical web scenarios. Some sensitivity to context-dependent navigation and dynamic content was observed.", "conclusion": "GenIA-E2ETest is a practical and effective solution to accelerate E2E test automation from natural language, reducing manual effort and broadening access to automated testing."}}
{"id": "2510.01077", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.01077", "abs": "https://arxiv.org/abs/2510.01077", "authors": ["Daniele Bifolco", "Guido Annicchiarico", "Pierluigi Barbiero", "Massimiliano Di Penta", "Fiorella Zampetti"], "title": "CodeGenLink: A Tool to Find the Likely Origin and License of Automatically Generated Code", "comment": "Proceedings of the 40th IEEE/ACM International Conference on\n  Automated Software Engineering (ASE 2025), November 16-20 2025, Seoul, South\n  Korea", "summary": "Large Language Models (LLMs) are widely used in software development tasks\nnowadays. Unlike reusing code taken from the Web, for LLMs' generated code,\ndevelopers are concerned about its lack of trustworthiness and possible\ncopyright or licensing violations, due to the lack of code provenance\ninformation. This paper proposes CodeGenLink, a GitHub CoPilot extension for\nVisual Studio Code aimed at (i) suggesting links containing code very similar\nto automatically generated code, and (ii) whenever possible, indicating the\nlicense of the likely origin of the code. CodeGenLink retrieves candidate links\nby combining LLMs with their web search features and then performs similarity\nanalysis between the generated and retrieved code. Preliminary results show\nthat CodeGenLink effectively filters unrelated links via similarity analysis\nand provides licensing information when available. Tool URL:\nhttps://github.com/danielebifolco/CodeGenLink Tool Video:\nhttps://youtu.be/M6nqjBf9_pw", "AI": {"tldr": "CodeGenLink is a GitHub CoPilot extension that helps identify code provenance and licensing information for LLM-generated code by finding similar code snippets online and analyzing their licenses.", "motivation": "Developers are concerned about trustworthiness and potential copyright/licensing violations when using LLM-generated code due to lack of provenance information.", "method": "Combines LLMs with web search features to retrieve candidate code links, then performs similarity analysis between generated and retrieved code to filter unrelated links and identify licensing information.", "result": "Preliminary results show CodeGenLink effectively filters unrelated links via similarity analysis and provides licensing information when available.", "conclusion": "CodeGenLink addresses the trustworthiness and licensing concerns of LLM-generated code by providing provenance information and license identification capabilities."}}
{"id": "2510.01096", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01096", "abs": "https://arxiv.org/abs/2510.01096", "authors": ["Nathan Wintersgill", "Trevor Stalnaker", "Daniel Otten", "Laura A. Heymann", "Oscar Chaparro", "Massimiliano Di Penta", "Daniel M. German", "Denys Poshyvanyk"], "title": "Developers' Perspectives on Software Licensing: Current Practices, Challenges, and Tools", "comment": null, "summary": "Most modern software products incorporate open-source components, requiring\ndevelopment teams to maintain compliance with each component's licenses.\nNoncompliance can lead to significant financial, legal, and reputational\nrepercussions. While some organizations may seek advice from legal\npractitioners to assist with licensing tasks, developers still play a key role\nin such a process. To this end, it is essential to understand how developers\napproach license compliance tasks, the challenges they encounter, and the tools\nthat they use. This work studies these aspects of software licensing practices\nthrough a study - conducted by a joint team of software engineering and legal\nresearchers - consisting of a survey with 58 software developers and seven\nfollow-up interviews. The study resulted in 15 key findings regarding the\ncurrent state of practice. We discuss the implications of our findings and\noffer directions for future research as well as actionable recommendations for\nlicensing tools.", "AI": {"tldr": "Study examines how developers handle open-source license compliance, identifying challenges and tool usage through surveys and interviews.", "motivation": "Understanding developer approaches to license compliance is crucial due to financial, legal, and reputational risks of noncompliance with open-source components.", "method": "Mixed-methods study with 58 developer surveys and 7 follow-up interviews conducted by software engineering and legal researchers.", "result": "Generated 15 key findings about current licensing practices, challenges, and tool usage in software development.", "conclusion": "Provides implications for future research and actionable recommendations for improving licensing tools to support developers."}}
{"id": "2510.01182", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01182", "abs": "https://arxiv.org/abs/2510.01182", "authors": ["Shuqing Li", "Chenran Zhang", "Binchang Li", "Cuiyun Gao", "Michael R. Lyu"], "title": "When Shared Worlds Break: Demystifying Defects in Multi-User Extended Reality Software Systems", "comment": null, "summary": "Multi-user Extended Reality (XR) systems enable transformative shared\nexperiences but introduce unique software defects that compromise user\nexperience. Understanding software defects in multi-user XR systems is crucial\nfor enhancing system reliability, yet remains underexplored. To fill the gap,\nthis paper presents the first large-scale empirical study of multi-user XR\ndefects, analyzing 2,649 real-world bug reports from diverse sources, including\ndeveloper forums, GitHub repositories, and app reviews on mainstream XR app\nstores. Through rigorous qualitative analysis using iterative open coding, we\ndevelop a comprehensive taxonomy that classifies multi-user XR bugs along three\ndimensions: Symptom Manifestation, Root Cause Origin, and Consequence Severity.\nOur findings reveal that synchronization inconsistencies and avatar-related\nanomalies are the most prevalent symptoms, while network/synchronization logic\ndefects and session management flaws emerge as dominant root causes.\nCritically, over 34% of analyzed bugs lead to severe consequences that\nfundamentally break the shared experience, including system crashes, persistent\ndisconnections, and complete interaction breakdowns, etc. We also identify\nconcerning privacy and health implications unique to multi-user XR contexts.\nBased on our findings of defect analysis, we provide actionable recommendations\nfor developers, platform vendors, and researchers. Our results demonstrate that\nmulti-user XR systems face distinct challenges at the intersection of\ndistributed systems, real-time 3D interaction, and immersive experiences,\nnecessitating specialized approaches to testing, debugging, and quality\nassurance.", "AI": {"tldr": "First large-scale empirical study of multi-user XR defects analyzing 2,649 real-world bug reports, revealing synchronization and avatar issues as most prevalent problems with severe consequences affecting shared experiences.", "motivation": "Multi-user XR systems introduce unique software defects that compromise user experience, but understanding these defects remains underexplored despite being crucial for enhancing system reliability.", "method": "Analyzed 2,649 real-world bug reports from diverse sources (developer forums, GitHub repositories, app reviews) using rigorous qualitative analysis with iterative open coding to develop a comprehensive taxonomy.", "result": "Synchronization inconsistencies and avatar-related anomalies are most prevalent symptoms; network/synchronization logic defects and session management flaws are dominant root causes; over 34% of bugs lead to severe consequences that break shared experiences.", "conclusion": "Multi-user XR systems face distinct challenges at intersection of distributed systems, real-time 3D interaction, and immersive experiences, requiring specialized approaches to testing, debugging, and quality assurance."}}
