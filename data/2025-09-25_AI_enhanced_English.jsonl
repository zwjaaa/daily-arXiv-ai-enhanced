{"id": "2509.19459", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.19459", "abs": "https://arxiv.org/abs/2509.19459", "authors": ["Yutong Guo", "Weiyu Luo", "Brian Demsky"], "title": "Automated Insertion of Flushes and Fences for Persistency", "comment": null, "summary": "CXL shared memory and persistent memory allow the contents of memory to\npersist beyond crashes. Stores to persistent or CXL memory are typically not\nimmediately made persistent; developers must manually flush the corresponding\ncache lines to force the data to be written to the underlying storage.\nCorrectly using flush and fence operations is known to be challenging. While\nstate-of-the-art tools can find missing flush instructions, they often require\nbug-revealing test cases. No existing tools can ensure the absence of missing\nflush bugs.\n  In this paper, we present PMRobust, a compiler that automatically inserts\nflush and fence operations to ensure that code using persistent memory is free\nfrom missing flush and fence bugs. PMRobust employs a novel static analysis\nwith optimizations that target newly allocated objects. We have evaluated\nPMRobust on persistent memory libraries and several persistent memory data\nstructures and measured a geometric mean overhead of 0.26% relative to the\noriginal benchmarks with hand-placed flush and fence operations.", "AI": {"tldr": "PMRobust is a compiler that automatically inserts flush and fence operations to eliminate missing flush bugs in persistent memory code, achieving minimal performance overhead.", "motivation": "Manual flush operations for persistent memory are error-prone and challenging for developers, while existing tools require bug-revealing test cases and cannot guarantee absence of missing flush bugs.", "method": "PMRobust employs a novel static analysis with optimizations targeting newly allocated objects to automatically insert necessary flush and fence operations during compilation.", "result": "Evaluation on persistent memory libraries and data structures showed a geometric mean overhead of only 0.26% compared to hand-placed flush operations.", "conclusion": "PMRobust effectively eliminates missing flush bugs in persistent memory code with negligible performance impact, providing automated correctness guarantees."}}
{"id": "2509.19533", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.19533", "abs": "https://arxiv.org/abs/2509.19533", "authors": ["Mengdi Lu", "Steven Ding", "Furkan Alaca", "Philippe Charland"], "title": "Semantic-Aware Fuzzing: An Empirical Framework for LLM-Guided, Reasoning-Driven Input Mutation", "comment": null, "summary": "Security vulnerabilities in Internet-of-Things devices, mobile platforms, and\nautonomous systems remain critical. Traditional mutation-based fuzzers -- while\neffectively explore code paths -- primarily perform byte- or bit-level edits\nwithout semantic reasoning. Coverage-guided tools such as AFL++ use\ndictionaries, grammars, and splicing heuristics to impose shallow structural\nconstraints, leaving deeper protocol logic, inter-field dependencies, and\ndomain-specific semantics unaddressed. Conversely, reasoning-capable large\nlanguage models (LLMs) can leverage pretraining knowledge to understand input\nformats, respect complex constraints, and propose targeted mutations, much like\nan experienced reverse engineer or testing expert. However, lacking ground\ntruth for \"correct\" mutation reasoning makes supervised fine-tuning\nimpractical, motivating explorations of off-the-shelf LLMs via prompt-based\nfew-shot learning. To bridge this gap, we present an open-source microservices\nframework that integrates reasoning LLMs with AFL++ on Google's FuzzBench,\ntackling asynchronous execution and divergent hardware demands (GPU- vs.\nCPU-intensive) of LLMs and fuzzers. We evaluate four research questions: (R1)\nHow can reasoning LLMs be integrated into the fuzzing mutation loop? (R2) Do\nfew-shot prompts yield higher-quality mutations than zero-shot? (R3) Can prompt\nengineering with off-the-shelf models improve fuzzing directly? and (R4) Which\nopen-source reasoning LLMs perform best under prompt-only conditions?\nExperiments with Llama3.3, Deepseek-r1-Distill-Llama-70B, QwQ-32B, and Gemma3\nhighlight Deepseek as the most promising. Mutation effectiveness depends more\non prompt complexity and model choice than shot count. Response latency and\nthroughput bottlenecks remain key obstacles, offering directions for future\nwork.", "AI": {"tldr": "A framework integrating reasoning LLMs with AFL++ fuzzer to address semantic limitations of traditional mutation-based fuzzing through prompt-based few-shot learning.", "motivation": "Traditional fuzzers lack semantic reasoning for complex protocol logic and domain-specific constraints, while LLMs can understand input formats and perform targeted mutations like human experts, but supervised fine-tuning is impractical without ground truth.", "method": "Open-source microservices framework integrating reasoning LLMs with AFL++ on Google's FuzzBench, addressing asynchronous execution and hardware divergence between GPU-intensive LLMs and CPU-intensive fuzzers.", "result": "Deepseek-r1-Distill-Llama-70B performed best among tested models. Mutation effectiveness depends more on prompt complexity and model choice than shot count. Response latency and throughput are key bottlenecks.", "conclusion": "Reasoning LLMs show promise for improving fuzzing quality through semantic mutations, but performance depends on model selection and prompt engineering, with latency/throughput challenges requiring future optimization."}}
{"id": "2509.19587", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.19587", "abs": "https://arxiv.org/abs/2509.19587", "authors": ["Mohamed Ouf", "Haoyu Li", "Michael Zhang", "Mariam Guizani"], "title": "Reverse Engineering User Stories from Code using Large Language Models", "comment": null, "summary": "User stories are essential in agile development, yet often missing or\noutdated in legacy and poorly documented systems. We investigate whether large\nlanguage models (LLMs) can automatically recover user stories directly from\nsource code and how prompt design impacts output quality. Using 1,750 annotated\nC++ snippets of varying complexity, we evaluate five state-of-the-art LLMs\nacross six prompting strategies. Results show that all models achieve, on\naverage, an F1 score of 0.8 for code up to 200 NLOC. Our findings show that a\nsingle illustrative example enables the smallest model (8B) to match the\nperformance of a much larger 70B model. In contrast, structured reasoning via\nChain-of-Thought offers only marginal gains, primarily for larger models.", "AI": {"tldr": "LLMs can effectively recover user stories from source code with F1 scores around 0.8 for code up to 200 lines, and smaller models can match larger ones when given a single example.", "motivation": "User stories are often missing in legacy systems, and this research explores whether LLMs can automatically generate them from source code to improve documentation.", "method": "Evaluated 5 state-of-the-art LLMs across 6 prompting strategies using 1,750 annotated C++ code snippets of varying complexity.", "result": "All models achieved average F1 score of 0.8 for code up to 200 NLOC. Single example enabled 8B model to match 70B model performance. Chain-of-Thought provided only marginal gains for larger models.", "conclusion": "LLMs are effective for user story recovery from code, with smaller models performing well when properly prompted, making this approach practical for real-world applications."}}
{"id": "2509.19673", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.19673", "abs": "https://arxiv.org/abs/2509.19673", "authors": ["Ahmed Aljohani", "Anamul Haque Mollah", "Hyunsook Do"], "title": "Assertion Messages with Large Language Models (LLMs) for Code", "comment": "Accepted at Proceedings of the 2025 Evaluation and Assessment in\n  Software Engineering (EASE '25)", "summary": "Assertion messages significantly enhance unit tests by clearly explaining the\nreasons behind test failures, yet they are frequently omitted by developers and\nautomated test-generation tools. Despite recent advancements, Large Language\nModels (LLMs) have not been systematically evaluated for their ability to\ngenerate informative assertion messages. In this paper, we introduce an\nevaluation of four state-of-the-art Fill-in-the-Middle (FIM) LLMs -\nQwen2.5-Coder-32B, Codestral-22B, CodeLlama-13B, and StarCoder - on a dataset\nof 216 Java test methods containing developer-written assertion messages. We\nfind that Codestral-22B achieves the highest quality score of 2.76 out of 5\nusing a human-like evaluation approach, compared to 3.24 for manually written\nmessages. Our ablation study shows that including descriptive test comments\nfurther improves Codestral's performance to 2.97, highlighting the critical\nrole of context in generating clear assertion messages. Structural analysis\ndemonstrates that all models frequently replicate developers' preferred\nlinguistic patterns. We discuss the limitations of the selected models and\nconventional text evaluation metrics in capturing diverse assertion message\nstructures. Our benchmark, evaluation results, and discussions provide an\nessential foundation for advancing automated, context-aware generation of\nassertion messages in test code. A replication package is available at\nhttps://doi.org/10.5281/zenodo.15293133", "AI": {"tldr": "Evaluation of four FIM LLMs (Qwen2.5-Coder-32B, Codestral-22B, CodeLlama-13B, StarCoder) for generating assertion messages in Java unit tests, with Codestral-22B achieving the best performance but still below human-written quality.", "motivation": "Assertion messages are crucial for understanding test failures but are often omitted by developers and automated tools. LLMs have not been systematically evaluated for generating informative assertion messages.", "method": "Evaluated four state-of-the-art FIM LLMs on 216 Java test methods containing developer-written assertion messages using human-like evaluation approach. Conducted ablation study on the impact of descriptive test comments.", "result": "Codestral-22B achieved highest quality score of 2.76/5 (vs 3.24 for manual messages). Including test comments improved Codestral's performance to 2.97. Models frequently replicated developers' linguistic patterns.", "conclusion": "Context is critical for generating clear assertion messages. Current models and conventional metrics have limitations in capturing diverse assertion message structures. The study provides foundation for advancing automated, context-aware assertion message generation."}}
{"id": "2509.19708", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.19708", "abs": "https://arxiv.org/abs/2509.19708", "authors": ["Anand Kumar", "Vishal Khare", "Deepak Sharma", "Satyam Kumar", "Vijay Saini", "Anshul Yadav", "Sachendra Jain", "Ankit Rana", "Pratham Verma", "Vaibhav Meena", "Avinash Edubilli"], "title": "Intuition to Evidence: Measuring AI's True Impact on Developer Productivity", "comment": "16 pages, 10 figures, 5 tables", "summary": "We present a comprehensive real-world evaluation of AI-assisted software\ndevelopment tools deployed at enterprise scale. Over one year, 300 engineers\nacross multiple teams integrated an in-house AI platform (DeputyDev) that\ncombines code generation and automated review capabilities into their daily\nworkflows. Through rigorous cohort analysis, our study demonstrates\nstatistically significant productivity improvements, including an overall 31.8%\nreduction in PR review cycle time.\n  Developer adoption was strong, with 85% satisfaction for code review features\nand 93% expressing a desire to continue using the platform. Adoption patterns\nshowed systematic scaling from 4% engagement in month 1 to 83% peak usage by\nmonth 6, stabilizing at 60% active engagement. Top adopters achieved a 61%\nincrease in code volume pushed to production, contributing to approximately 30\nto 40% of code shipped to production through this tool, accounting for an\noverall 28% increase in code shipment volume.\n  Unlike controlled benchmark evaluations, our longitudinal analysis provides\nempirical evidence from production environments, revealing both the\ntransformative potential and practical deployment challenges of integrating AI\ninto enterprise software development workflows.", "AI": {"tldr": "Real-world evaluation of AI-assisted software development tools at enterprise scale shows significant productivity improvements, including 31.8% reduction in PR review cycle time and strong developer adoption with 85% satisfaction.", "motivation": "To provide empirical evidence from production environments about the transformative potential and practical deployment challenges of integrating AI into enterprise software development workflows, moving beyond controlled benchmark evaluations.", "method": "Longitudinal study over one year with 300 engineers across multiple teams using an in-house AI platform (DeputyDev) that combines code generation and automated review capabilities. Used rigorous cohort analysis to track adoption patterns and productivity metrics.", "result": "Statistically significant productivity improvements: 31.8% reduction in PR review cycle time, 61% increase in code volume for top adopters, with 30-40% of production code shipped through the tool. Strong adoption scaling from 4% to 83% peak usage, stabilizing at 60% active engagement with 85% satisfaction for code review features.", "conclusion": "AI-assisted development tools demonstrate transformative potential in enterprise settings, with substantial productivity gains and high developer satisfaction, though practical deployment challenges exist that differ from controlled benchmark evaluations."}}
{"id": "2509.19918", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.19918", "abs": "https://arxiv.org/abs/2509.19918", "authors": ["Micheline B\u00e9n\u00e9dicte Moumoula", "Serge Lionel Nikiema", "Alb\u00e9rick Euraste Djire", "Abdoul Kader Kabore", "Jacques Klein", "Tegawend\u00e9 F. Bissyande"], "title": "Beyond Language Barriers: Multi-Agent Coordination for Multi-Language Code Generation", "comment": null, "summary": "Producing high-quality code across multiple programming languages is\nincreasingly important as today's software systems are built on heterogeneous\nstacks. Large language models (LLMs) have advanced the state of automated\nprogramming, yet their proficiency varies sharply between languages, especially\nthose with limited training data such as Rust, Perl, OCaml, and Erlang. Many\ncurrent solutions including language-specific fine-tuning, multi-agent\norchestration, transfer learning, and intermediate-representation pipelines\nstill approach each target language in isolation, missing opportunities to\nshare knowledge or exploit recurring cross-language patterns.\n  XL-CoGen tackles this challenge with a coordinated multi-agent architecture\nthat integrates intermediate representation, code generation, translation, and\nautomated repair. Its distinguishing feature is a data-driven mechanism for\nselecting bridging languages: empirically derived transfer matrices identify\nthe best intermediate languages based on demonstrated translation success\nrather than raw generation accuracy. The system performs early output\nvalidation, iteratively corrects errors, and reuses intermediate artifacts as\ncontextual scaffolds for subsequent translations.\n  Extensive experiments show that XL-CoGen yields notable improvements with 13\npercentage-point gains over the strongest fine-tuned baseline and as much as 30\npercentage points over existing single-language multi-agent methods. Ablation\nstudies further demonstrate that compatibility-guided bridging significantly\noutperforms LLM-based heuristics, confirming the value of cumulative\ncross-language knowledge transfer.", "AI": {"tldr": "XL-CoGen is a multi-agent system that improves code generation across multiple programming languages by using data-driven bridging languages and iterative error correction.", "motivation": "Current LLMs have varying proficiency across programming languages, especially for less common languages like Rust, Perl, OCaml, and Erlang. Existing approaches treat each language in isolation, missing opportunities for cross-language knowledge sharing.", "method": "Uses a coordinated multi-agent architecture with intermediate representation, code generation, translation, and automated repair. Features data-driven bridging language selection based on transfer matrices that identify optimal intermediate languages through demonstrated translation success rather than raw generation accuracy.", "result": "Achieves 13 percentage-point gains over the strongest fine-tuned baseline and up to 30 percentage points over existing single-language multi-agent methods. Ablation studies show compatibility-guided bridging significantly outperforms LLM-based heuristics.", "conclusion": "The approach demonstrates the value of cumulative cross-language knowledge transfer, with data-driven bridging language selection proving more effective than heuristic methods."}}
{"id": "2509.20010", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20010", "abs": "https://arxiv.org/abs/2509.20010", "authors": ["Xiaoning Ren", "Yuhang Ye", "Xiongfei Wu", "Yueming Wu", "Yinxing Xue"], "title": "Demystifying the Evolution of Neural Networks with BOM Analysis: Insights from a Large-Scale Study of 55,997 GitHub Repositories", "comment": "11pages,8figures", "summary": "Neural networks have become integral to many fields due to their exceptional\nperformance. The open-source community has witnessed a rapid influx of neural\nnetwork (NN) repositories with fast-paced iterations, making it crucial for\npractitioners to analyze their evolution to guide development and stay ahead of\ntrends. While extensive research has explored traditional software evolution\nusing Software Bill of Materials (SBOMs), these are ill-suited for NN software,\nwhich relies on pre-defined modules and pre-trained models (PTMs) with distinct\ncomponent structures and reuse patterns. Conceptual AI Bills of Materials\n(AIBOMs) also lack practical implementations for large-scale evolutionary\nanalysis. To fill this gap, we introduce the Neural Network Bill of Material\n(NNBOM), a comprehensive dataset construct tailored for NN software. We create\na large-scale NNBOM database from 55,997 curated PyTorch GitHub repositories,\ncataloging their TPLs, PTMs, and modules. Leveraging this database, we conduct\na comprehensive empirical study of neural network software evolution across\nsoftware scale, component reuse, and inter-domain dependency, providing\nmaintainers and developers with a holistic view of its long-term trends.\nBuilding on these findings, we develop two prototype applications,\n\\textit{Multi repository Evolution Analyzer} and \\textit{Single repository\nComponent Assessor and Recommender}, to demonstrate the practical value of our\nanalysis.", "AI": {"tldr": "The paper introduces Neural Network Bill of Material (NNBOM) as a specialized dataset construct for analyzing neural network software evolution, addressing limitations of traditional SBOMs and conceptual AIBOMs for NN repositories.", "motivation": "Existing Software Bill of Materials (SBOMs) are ill-suited for neural network software due to distinct component structures and reuse patterns involving pre-trained models and modules. Conceptual AIBOMs lack practical implementations for large-scale evolutionary analysis.", "method": "Created a large-scale NNBOM database from 55,997 curated PyTorch GitHub repositories, cataloging their third-party libraries (TPLs), pre-trained models (PTMs), and modules. Conducted comprehensive empirical study of NN software evolution across software scale, component reuse, and inter-domain dependency.", "result": "Developed a comprehensive NNBOM dataset enabling evolutionary analysis of neural network software. Built two prototype applications: Multi repository Evolution Analyzer and Single repository Component Assessor and Recommender to demonstrate practical value.", "conclusion": "NNBOM provides a tailored solution for analyzing neural network software evolution, offering maintainers and developers a holistic view of long-term trends in NN repository development and component reuse patterns."}}
{"id": "2509.20136", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20136", "abs": "https://arxiv.org/abs/2509.20136", "authors": ["Wei Zhang", "Jack Yang", "Renshuai Tao", "Lingzheng Chai", "Shawn Guo", "Jiajun Wu", "Xiaoming Chen", "Ganqu Cui", "Ning Ding", "Xander Xu", "Hu Wei", "Bowen Zhou"], "title": "V-GameGym: Visual Game Generation for Code Large Language Models", "comment": null, "summary": "Code large language models have demonstrated remarkable capabilities in\nprogramming tasks, yet current benchmarks primarily focus on single modality\nrather than visual game development. Most existing code-related benchmarks\nevaluate syntax correctness and execution accuracy, overlooking critical\ngame-specific metrics such as playability, visual aesthetics, and user\nengagement that are essential for real-world deployment. To address the gap\nbetween current LLM capabilities in algorithmic problem-solving and competitive\nprogramming versus the comprehensive requirements of practical game\ndevelopment, we present V-GameGym, a comprehensive benchmark comprising 2,219\nhigh-quality samples across 100 thematic clusters derived from real-world\nrepositories, adopting a novel clustering-based curation methodology to ensure\nboth diversity and structural completeness. Further, we introduce a multimodal\nevaluation framework with an automated LLM-driven pipeline for visual code\nsynthesis using complete UI sandbox environments. Our extensive analysis\nreveals that V-GameGym effectively bridges the gap between code generation\naccuracy and practical game development workflows, providing quantifiable\nquality metrics for visual programming and interactive element generation.", "AI": {"tldr": "V-GameGym is a comprehensive benchmark for evaluating code LLMs in visual game development, addressing the gap between current code generation metrics and practical game development requirements.", "motivation": "Current code LLM benchmarks focus on syntax correctness and execution accuracy but overlook critical game-specific metrics like playability, visual aesthetics, and user engagement needed for real-world game development.", "method": "Created a benchmark with 2,219 samples across 100 thematic clusters from real-world repositories using clustering-based curation. Introduced a multimodal evaluation framework with automated LLM-driven pipeline for visual code synthesis in UI sandbox environments.", "result": "V-GameGym effectively bridges the gap between code generation accuracy and practical game development workflows, providing quantifiable quality metrics for visual programming and interactive element generation.", "conclusion": "The benchmark addresses the limitations of current code evaluation methods by incorporating comprehensive game development metrics, making it suitable for assessing LLMs' capabilities in practical visual game development scenarios."}}
{"id": "2509.20149", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20149", "abs": "https://arxiv.org/abs/2509.20149", "authors": ["Jianzhang Zhang", "Jialong Zhou", "Nan Niu", "Chuang Liu"], "title": "Enhancing Requirement Traceability through Data Augmentation Using Large Language Models", "comment": null, "summary": "Requirements traceability is crucial in software engineering to ensure\nconsistency between requirements and code. However, existing automated\ntraceability methods are constrained by the scarcity of training data and\nchallenges in bridging the semantic gap between artifacts. This study aims to\naddress the data scarcity problem in requirements traceability by employing\nlarge language models (LLMs) for data augmentation. We propose a novel approach\nthat utilizes prompt-based techniques with LLMs to generate augmented\nrequirement-to-code trace links, thereby enhancing the training dataset. Four\nLLMs (Gemini 1.5 Pro, Claude 3, GPT-3.5, and GPT-4) were used, employing both\nzero-shot and few-shot templates. Moreover, we optimized the encoder component\nof the tracing model to improve its efficiency and adaptability to augmented\ndata. The key contributions of this paper are: (1) proposing and evaluating\nfour prompt templates for data augmentation; (2) providing a comparative\nanalysis of four LLMs for generating trace links; (3) enhancing the model's\nencoder for improved adaptability to augmented datasets. Experimental results\nshow that our approach significantly enhances model performance, achieving an\nF1 score improvement of up to 28.59%, thus demonstrating its effectiveness and\npotential for practical application.", "AI": {"tldr": "This paper proposes using LLMs for data augmentation in requirements traceability to address training data scarcity, achieving up to 28.59% F1 score improvement.", "motivation": "Existing automated traceability methods are limited by scarce training data and semantic gaps between requirements and code artifacts.", "method": "Uses prompt-based techniques with four LLMs (Gemini 1.5 Pro, Claude 3, GPT-3.5, GPT-4) for data augmentation, employing zero-shot and few-shot templates, and optimizes the encoder component of the tracing model.", "result": "Experimental results show significant performance enhancement with up to 28.59% improvement in F1 score.", "conclusion": "The approach effectively addresses data scarcity in requirements traceability and demonstrates practical application potential."}}
{"id": "2509.20172", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.20172", "abs": "https://arxiv.org/abs/2509.20172", "authors": ["Daniel Maninger", "Leon Chemnitz", "Amir Molzam Sharifloo", "Jannis Brugger", "Mira Mezini"], "title": "Benchmarking Web API Integration Code Generation", "comment": "To be published in Proceedings of 2nd ACM International Conference on\n  AI-powered Software, Benchmark & Dataset Track (AIware '25)", "summary": "API integration is a cornerstone of our digital infrastructure, enabling\nsoftware systems to connect and interact. However, as shown by many studies,\nwriting or generating correct code to invoke APIs, particularly web APIs, is\nchallenging. Although large language models~(LLMs) have become popular in\nsoftware development, their effectiveness in automating the generation of web\nAPI integration code remains unexplored. In order to address this, we present a\ndataset and evaluation pipeline designed to assess the ability of LLMs to\ngenerate web API invocation code. Our experiments with several open-source LLMs\nreveal that generating API invocations poses a significant challenge, resulting\nin hallucinated endpoints, incorrect argument usage, and other errors. None of\nthe evaluated open-source models were able to solve more than 40% of the tasks.", "AI": {"tldr": "Evaluation of LLMs for generating web API integration code reveals significant challenges with hallucinated endpoints and incorrect arguments, with open-source models solving less than 40% of tasks.", "motivation": "API integration is crucial but challenging, and while LLMs are popular in software development, their effectiveness in generating web API invocation code remains unexplored.", "method": "Created a dataset and evaluation pipeline to assess LLMs' ability to generate web API integration code, testing several open-source models.", "result": "Generating API invocations proved highly challenging - models produced hallucinated endpoints, incorrect argument usage, and other errors. No open-source model solved more than 40% of tasks.", "conclusion": "Current open-source LLMs struggle significantly with web API integration code generation, indicating this remains a difficult problem requiring further research."}}
{"id": "2509.20215", "categories": ["cs.SE", "cs.AI", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.20215", "abs": "https://arxiv.org/abs/2509.20215", "authors": ["Guang Yang", "Wei Zheng", "Xiang Chen", "Yifan Sun", "Fengji Zhang", "Terry Yue Zhuo"], "title": "The Cream Rises to the Top: Efficient Reranking Method for Verilog Code Generation", "comment": "Under review ICASSP 2026", "summary": "LLMs face significant challenges in Verilog generation due to limited\ndomain-specific knowledge. While sampling techniques improve pass@k metrics,\nhardware engineers need one trustworthy solution rather than uncertain\ncandidates. To bridge this gap, we formulate it as a semantic alignment problem\nbetween requirements and Verilog implementations, and propose VCD-RNK, a\ndiscriminator model tailored for efficient Verilog code reranking.\nSpecifically, VCD-RNKincorporates Verilog-specific reasoning by distilling\nexpert knowledge across three dimensions: code semantic analysis, test case\ngeneration, and functional correctness assessment. By explicitly simulating the\nabove reasoning processes during inference, VCD-RNK effectively avoids\ncomputationally intensive test execution in existing methods.", "AI": {"tldr": "VCD-RNK is a discriminator model for Verilog code reranking that addresses LLMs' limitations in Verilog generation by formulating it as a semantic alignment problem between requirements and implementations.", "motivation": "LLMs struggle with Verilog generation due to limited domain knowledge, and while sampling improves pass@k metrics, hardware engineers need one trustworthy solution rather than multiple uncertain candidates.", "method": "VCD-RNK incorporates Verilog-specific reasoning by distilling expert knowledge across three dimensions: code semantic analysis, test case generation, and functional correctness assessment, simulating these reasoning processes during inference to avoid computationally intensive test execution.", "result": "The proposed method effectively avoids computationally intensive test execution used in existing methods while providing reliable Verilog code ranking.", "conclusion": "VCD-RNK bridges the gap between sampling-based approaches and hardware engineers' need for trustworthy single solutions by providing efficient semantic alignment between requirements and Verilog implementations."}}
{"id": "2509.20300", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20300", "abs": "https://arxiv.org/abs/2509.20300", "authors": ["Jannis Kiesel", "Jonathan Heiss"], "title": "Confidentiality-Preserving Verifiable Business Processes through Zero-Knowledge Proofs", "comment": null, "summary": "Ensuring the integrity of business processes without disclosing confidential\nbusiness information is a major challenge in inter-organizational processes.\nThis paper introduces a zero-knowledge proof (ZKP)-based approach for the\nverifiable execution of business processes while preserving confidentiality. We\nintegrate ZK virtual machines (zkVMs) into business process management engines\nthrough a comprehensive system architecture and a prototypical implementation.\nOur approach supports chained verifiable computations through proof\ncompositions. On the example of product carbon footprinting, we model\nsequential footprinting activities and demonstrate how organizations can prove\nand verify the integrity of verifiable processes without exposing sensitive\ninformation. We assess different ZKP proving variants within process models for\ntheir efficiency in proving and verifying, and discuss the practical\nintegration of ZKPs throughout the Business Process Management (BPM) lifecycle.\nOur experiment-driven evaluation demonstrates the automation of process\nverification under given confidentiality constraints.", "AI": {"tldr": "A zero-knowledge proof (ZKP)-based approach for verifiable execution of business processes while preserving confidentiality, using zkVMs integrated into BPM engines.", "motivation": "Ensuring business process integrity without disclosing confidential information in inter-organizational processes is a major challenge.", "method": "Integrate ZK virtual machines (zkVMs) into business process management engines through system architecture and implementation, supporting chained verifiable computations via proof compositions.", "result": "Demonstrated on product carbon footprinting example, showing organizations can prove and verify process integrity without exposing sensitive information. Evaluated different ZKP proving variants for efficiency.", "conclusion": "Experiment-driven evaluation demonstrates automation of process verification under confidentiality constraints, enabling practical integration of ZKPs throughout the BPM lifecycle."}}
{"id": "2509.20308", "categories": ["cs.SE", "68M15 (Primary), 68M12, 68Q42 (Secondary)", "D.2.5; C.2.2; F.4.2"], "pdf": "https://arxiv.org/pdf/2509.20308", "abs": "https://arxiv.org/abs/2509.20308", "authors": ["Alexander Liggesmeyer", "Jos\u00e9 Antonio Zamudio Amaya", "Andreas Zeller"], "title": "Protocol Testing with I/O Grammars", "comment": "20 pages", "summary": "Generating software tests faces two fundamental problems. First, one needs to\n_generate inputs_ that are syntactically and semantically correct, yet\nsufficiently diverse to cover behavior. Second, one needs an _oracle_ to _check\noutputs_ whether a test case is correct or not. Both problems become apparent\nin _protocol testing_, where inputs are messages exchanged between parties, and\noutputs are the responses of these parties.\n  In this paper, we propose a novel approach to protocol testing that combines\ninput generation and output checking in a single framework. We introduce _I/O\ngrammars_ as the first means to _completely_ specify the syntax and semantics\nof protocols, including messages, states, and interactions. Our implementation,\nbased on the FANDANGO framework, takes a single I/O grammar, and can act as a\n_test generator_, as a _mock object_, and as an _oracle_ for a _client_, a\n_server_, or both (or actually any number of parties), a versatility not found\nin any existing tool or formalism. User-defined _constraints}_can have the\ngenerator focus on arbitrary protocol features; $k$-path guidance\nsystematically covers states, messages, responses, and value alternatives in a\nunified fashion.\n  We evaluate the effectiveness of our approach by applying it to several\nprotocols, including DNS, FTP, and SMTP. We demonstrate that I/O grammars can\nspecify advanced protocol features correctly and completely, while also\nenabling output validation of the programs under test. In its evaluation, we\nfind that systematic coverage of the I/O grammar results in much quicker\ncoverage of the input and response spaces (and thus functionality) compared to\nthe random-based state-of-the-art approaches.", "AI": {"tldr": "A novel protocol testing approach using I/O grammars that combines input generation and output checking in a single framework, enabling complete specification of protocol syntax and semantics.", "motivation": "Address two fundamental problems in software testing: generating diverse, correct inputs and having an oracle to check outputs, particularly challenging in protocol testing where inputs are messages and outputs are responses.", "method": "Introduces I/O grammars to completely specify protocol syntax/semantics (messages, states, interactions). Implementation uses FANDANGO framework with user-defined constraints and k-path guidance for systematic coverage.", "result": "Applied to DNS, FTP, and SMTP protocols, demonstrating correct specification of advanced features and enabling output validation. Systematic coverage achieves faster coverage of input/response spaces compared to random-based approaches.", "conclusion": "I/O grammars provide a versatile framework that can act as test generator, mock object, and oracle, offering unified systematic coverage superior to existing random-based methods."}}
{"id": "2509.20353", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20353", "abs": "https://arxiv.org/abs/2509.20353", "authors": ["Viktoria Stray", "Elias Goldmann Brandtz\u00e6g", "Viggo Tellefsen Wivestad", "Astri Barbala", "Nils Brede Moe"], "title": "Developer Productivity With and Without GitHub Copilot: A Longitudinal Mixed-Methods Case Study", "comment": "Accepted for publication in the Proceedings of the 59th Hawaii\n  International Conference on System Sciences (HICSS 2026)", "summary": "This study investigates the real-world impact of the generative AI (GenAI)\ntool GitHub Copilot on developer activity and perceived productivity. We\nconducted a mixed-methods case study in NAV IT, a large public sector agile\norganization. We analyzed 26,317 unique non-merge commits from 703 of NAV IT's\nGitHub repositories over a two-year period, focusing on commit-based activity\nmetrics from 25 Copilot users and 14 non-users. The analysis was complemented\nby survey responses on their roles and perceived productivity, as well as 13\ninterviews. Our analysis of activity metrics revealed that individuals who used\nCopilot were consistently more active than non-users, even prior to Copilot's\nintroduction. We did not find any statistically significant changes in\ncommit-based activity for Copilot users after they adopted the tool, although\nminor increases were observed. This suggests a discrepancy between changes in\ncommit-based metrics and the subjective experience of productivity.", "AI": {"tldr": "This study examines GitHub Copilot's impact on developer productivity using mixed-methods analysis of 26,317 commits from 703 repositories over two years, comparing 25 Copilot users with 14 non-users.", "motivation": "To understand the real-world effects of generative AI tools like GitHub Copilot on developer activity and perceived productivity in an agile public sector organization.", "method": "Mixed-methods case study analyzing commit-based activity metrics from GitHub repositories, supplemented by surveys on roles/perceived productivity and 13 interviews with developers.", "result": "Copilot users were consistently more active than non-users even before adoption. No statistically significant changes in commit-based activity were found after Copilot adoption, though minor increases were observed, indicating a discrepancy between objective metrics and subjective productivity perceptions.", "conclusion": "GitHub Copilot adoption did not produce statistically significant changes in measurable developer activity metrics, despite users' subjective perceptions of increased productivity, suggesting the need for better productivity measurement tools that capture AI tool benefits."}}
