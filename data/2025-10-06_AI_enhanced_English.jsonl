{"id": "2510.02387", "categories": ["cs.SE", "cs.AI", "cs.LG", "68T07", "I.2.7"], "pdf": "https://arxiv.org/pdf/2510.02387", "abs": "https://arxiv.org/abs/2510.02387", "authors": ["FAIR CodeGen team", "Quentin Carbonneaux", "Gal Cohen", "Jonas Gehring", "Jacob Kahn", "Jannik Kossen", "Felix Kreuk", "Emily McMilin", "Michel Meyer", "Yuxiang Wei", "David Zhang", "Kunhao Zheng", "Jordi Armengol-Estap\u00e9", "Pedram Bashiri", "Maximilian Beck", "Pierre Chambon", "Abhishek Charnalia", "Chris Cummins", "Juliette Decugis", "Zacharias V. Fisches", "Fran\u00e7ois Fleuret", "Fabian Gloeckle", "Alex Gu", "Michael Hassid", "Daniel Haziza", "Badr Youbi Idrissi", "Christian Keller", "Rahul Kindi", "Hugh Leather", "Gallil Maimon", "Aram Markosyan", "Francisco Massa", "Pierre-Emmanuel Mazar\u00e9", "Vegard Mella", "Naila Murray", "Keyur Muzumdar", "Peter O'Hearn", "Matteo Pagliardini", "Dmitrii Pedchenko", "Tal Remez", "Volker Seeker", "Marco Selvi", "Oren Sultan", "Sida Wang", "Luca Wehrstedt", "Ori Yoran", "Lingming Zhang", "Taco Cohen", "Yossi Adi", "Gabriel Synnaeve"], "title": "CWM: An Open-Weights LLM for Research on Code Generation with World Models", "comment": "58 pages", "summary": "We release Code World Model (CWM), a 32-billion-parameter open-weights LLM,\nto advance research on code generation with world models. To improve code\nunderstanding beyond what can be learned from training on static code alone, we\nmid-train CWM on a large amount of observation-action trajectories from Python\ninterpreter and agentic Docker environments, and perform extensive multi-task\nreasoning RL in verifiable coding, math, and multi-turn software engineering\nenvironments. With CWM, we provide a strong testbed for researchers to explore\nthe opportunities world modeling affords for improving code generation with\nreasoning and planning in computational environments. We present first steps of\nhow world models can benefit agentic coding, enable step-by-step simulation of\nPython code execution, and show early results of how reasoning can benefit from\nthe latter. CWM is a dense, decoder-only LLM trained with a context size of up\nto 131k tokens. Independent of its world modeling capabilities, CWM offers\nstrong performance on general coding and math tasks: it reaches pass@1 scores\nof 65.8% on SWE-bench Verified (with test-time scaling), 68.6% on\nLiveCodeBench, 96.6% on Math-500, and 76.0% on AIME 2024. To support further\nresearch on code world modeling, we release model checkpoints after\nmid-training, SFT, and RL.", "AI": {"tldr": "Code World Model (CWM) is a 32B-parameter LLM trained on code execution trajectories and multi-task reasoning to improve code generation through world modeling capabilities.", "motivation": "To advance code generation research by improving code understanding beyond static code training through world modeling with observation-action trajectories from computational environments.", "method": "Mid-training on Python interpreter and Docker environment trajectories, followed by multi-task reasoning RL in verifiable coding, math, and software engineering environments. Uses dense decoder-only architecture with 131k token context.", "result": "Achieves strong performance: 65.8% on SWE-bench Verified, 68.6% on LiveCodeBench, 96.6% on Math-500, and 76.0% on AIME 2024. Enables Python code execution simulation and benefits agentic coding.", "conclusion": "CWM provides a strong foundation for exploring world modeling in code generation, demonstrating benefits for reasoning and planning in computational environments, with released checkpoints for further research."}}
{"id": "2510.02389", "categories": ["cs.SE", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.02389", "abs": "https://arxiv.org/abs/2510.02389", "authors": ["Haoran Xi", "Minghao Shao", "Brendan Dolan-Gavitt", "Muhammad Shafique", "Ramesh Karri"], "title": "From Trace to Line: LLM Agent for Real-World OSS Vulnerability Localization", "comment": null, "summary": "Large language models show promise for vulnerability discovery, yet\nprevailing methods inspect code in isolation, struggle with long contexts, and\nfocus on coarse function- or file-level detections - offering limited\nactionable guidance to engineers who need precise line-level localization and\ntargeted patches in real-world software development. We present T2L-Agent\n(Trace-to-Line Agent), a project-level, end-to-end framework that plans its own\nanalysis and progressively narrows scope from modules to exact vulnerable\nlines. T2L-Agent couples multi-round feedback with an Agentic Trace Analyzer\n(ATA) that fuses runtime evidence - crash points, stack traces, and coverage\ndeltas - with AST-based code chunking, enabling iterative refinement beyond\nsingle pass predictions and translating symptoms into actionable, line-level\ndiagnoses. To benchmark line-level vulnerability discovery, we introduce\nT2L-ARVO, a diverse, expert-verified 50-case benchmark spanning five crash\nfamilies and real-world projects. T2L-ARVO is specifically designed to support\nboth coarse-grained detection and fine-grained localization, enabling rigorous\nevaluation of systems that aim to move beyond file-level predictions. On\nT2L-ARVO, T2L-Agent achieves up to 58.0% detection and 54.8% line-level\nlocalization, substantially outperforming baselines. Together, the framework\nand benchmark push LLM-based vulnerability detection from coarse identification\ntoward deployable, robust, precision diagnostics that reduce noise and\naccelerate patching in open-source software workflows.", "AI": {"tldr": "T2L-Agent is an end-to-end framework that enables precise line-level vulnerability localization in software by progressively narrowing scope from modules to exact vulnerable lines, using multi-round feedback and runtime evidence fusion.", "motivation": "Current LLM-based vulnerability detection methods inspect code in isolation, struggle with long contexts, and only provide coarse function- or file-level detections, offering limited actionable guidance for real-world software development.", "method": "T2L-Agent uses an Agentic Trace Analyzer (ATA) that fuses runtime evidence (crash points, stack traces, coverage deltas) with AST-based code chunking, enabling iterative refinement through multi-round feedback to translate symptoms into line-level diagnoses.", "result": "On the T2L-ARVO benchmark (50 expert-verified cases across 5 crash families), T2L-Agent achieves up to 58.0% detection and 54.8% line-level localization, substantially outperforming baseline methods.", "conclusion": "The framework and benchmark push LLM-based vulnerability detection from coarse identification toward deployable, robust precision diagnostics that reduce noise and accelerate patching in open-source software workflows."}}
{"id": "2510.02393", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02393", "abs": "https://arxiv.org/abs/2510.02393", "authors": ["Jianqing Zhang", "Wei Xia", "Hande Dong", "Qiang Lin", "Jian Cao"], "title": "AP2O: Correcting LLM-Generated Code Errors Type by Type Like Humans via Adaptive Progressive Preference Optimization", "comment": null, "summary": "LLMs' code generation capabilities have yielded substantial improvements in\nthe effectiveness of programming tasks. However, LLM-generated code still\nsuffers from compilation and runtime errors. Existing offline preference\noptimization methods primarily focus on enhancing LLMs' coding abilities using\npass/fail signals in the preference data, overlooking the deep-level error\ntypes in the failed codes. To address this, we propose Adaptively Progressive\nPreference Optimization (AP2O) for coding (i.e., AP2O-Coder), a method that\nguides LLMs adaptively and methodically to reduce code errors for code\ngeneration. Specifically, we construct an error notebook from failed codes and\nprogressively optimize the LLM to correct errors type by type. Furthermore, we\nadaptively replay error types to tailor to the LLM's changing weaknesses\nthroughout the training process. Through extensive experiments on both code and\ngeneral LLMs (Llama, Qwen, and DeepSeek series) with parameters ranging from\n0.5B to 34B, our AP2O-Coder improves code generation performance by up to 3% in\npass@k while using less preference data. Code: https://github.com/TsingZ0/AP2O", "AI": {"tldr": "AP2O-Coder is a preference optimization method that progressively guides LLMs to correct code errors by type, using an error notebook and adaptive replay of error types during training.", "motivation": "Existing offline preference optimization methods for code generation focus only on pass/fail signals and overlook the specific error types in failed codes, limiting their effectiveness in reducing compilation and runtime errors.", "method": "Construct an error notebook from failed codes and progressively optimize the LLM to correct errors type by type. Adaptively replay error types throughout training to address the LLM's changing weaknesses.", "result": "AP2O-Coder improves code generation performance by up to 3% in pass@k while using less preference data, tested on LLMs from 0.5B to 34B parameters (Llama, Qwen, DeepSeek series).", "conclusion": "The proposed AP2O-Coder method effectively enhances LLM code generation by systematically addressing specific error types through progressive and adaptive optimization."}}
{"id": "2510.02404", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02404", "abs": "https://arxiv.org/abs/2510.02404", "authors": ["Siddharth Agarwal", "Maria A. Rodriguez", "Rajkumar Buyya"], "title": "Dynamic Function Configuration and its Management in Serverless Computing: A Taxonomy and Future Directions", "comment": "34 pages, 2 figures, 2 tables, journal", "summary": "The serverless cloud computing model offers a framework where the service\nprovider abstracts the underlying infrastructure management from developers. In\nthis serverless model, FaaS provides an event-driven, function-oriented\ncomputing service characterised by fine-grained, usage-based pricing that\neliminates cost for idle resources. Platforms like AWS Lambda, Azure Functions,\nand Cloud Run Functions require developers to configure their function(s) with\nminimum operational resources for its successful execution. This resource\nallocation influences both the operational expense and the performance quality\nof these functions. However, a noticeable lack of platform transparency forces\ndevelopers to rely on expert knowledge or experience-based ad-hoc decisions to\nrequest desired function resources. This makes optimal resource configuration a\nnon-trivial task while adhering to performance constraints. Furthermore, while\ncommercial platforms often scale resources like CPU and network bandwidth\nproportional to memory, open-source frameworks permit independent configuration\nof function resources, introducing additional complexity for developers aiming\nto optimise their functions. These complexities have directed researchers to\nresolve developer challenges and advance towards an efficient server-less\nexecution model. In this article, we identify different aspects of resource\nconfiguration techniques in FaaS settings and propose a taxonomy of factors\nthat influence function design, configuration, run-time cost, and performance\nguarantees. We conduct an analysis of existing literature on resource\nconfiguration to present a comprehensive review of current studies on function\nconfiguration. We also identify existing research gaps and suggest future\nresearch directions to enhance function configuration and strengthen the\ncapabilities of serverless computing environments to drive its broader\nadoption.", "AI": {"tldr": "This paper analyzes resource configuration challenges in serverless/FaaS platforms and proposes a taxonomy for function configuration factors, reviewing existing literature and identifying research gaps.", "motivation": "Serverless platforms lack transparency in resource management, forcing developers to rely on ad-hoc decisions for function configuration, which affects both cost and performance. The complexity increases with open-source frameworks allowing independent resource configuration.", "method": "The authors identify different aspects of resource configuration techniques in FaaS settings, propose a taxonomy of influencing factors, and conduct a comprehensive literature review of existing studies on function configuration.", "result": "The paper presents a taxonomy of factors that influence function design, configuration, runtime cost, and performance guarantees in serverless environments.", "conclusion": "The research identifies existing gaps in function configuration and suggests future directions to enhance serverless computing capabilities and drive broader adoption."}}
{"id": "2510.02504", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02504", "abs": "https://arxiv.org/abs/2510.02504", "authors": ["Mara Ulloa", "Jenna L. Butler", "Sankeerti Haniyur", "Courtney Miller", "Barrett Amos", "Advait Sarkar", "Margaret-Anne Storey"], "title": "Product Manager Practices for Delegating Work to Generative AI: \"Accountability must not be delegated to non-human actors\"", "comment": "12 pages, 4 figures, 1 table", "summary": "Generative AI (GenAI) is changing the nature of knowledge work, particularly\nfor Product Managers (PMs) in software development teams. While much software\nengineering research has focused on developers' interactions with GenAI, there\nis less understanding of how the work of PMs is evolving due to GenAI. To\naddress this gap, we conducted a mixed-methods study at Microsoft, a large,\nmultinational software company: surveying 885 PMs, analyzing telemetry data for\na subset of PMs (N=731), and interviewing a subset of 15 PMs. We contribute:\n(1) PMs' current GenAI adoption rates, uses cases, and perceived benefits and\nbarriers and; (2) a framework capturing how PMs assess which tasks to delegate\nto GenAI; (3) PMs adaptation practices for integrating GenAI into their roles\nand perceptions of how their role is evolving. We end by discussing\nimplications on the broader GenAI workflow adoption process and software\ndevelopment roles.", "AI": {"tldr": "Study examines how Generative AI is transforming Product Managers' work at Microsoft, revealing adoption patterns, task delegation frameworks, and role evolution.", "motivation": "While much research focuses on developers using GenAI, there's limited understanding of how Product Managers' work is evolving with GenAI adoption in software development.", "method": "Mixed-methods study at Microsoft: surveyed 885 PMs, analyzed telemetry data for 731 PMs, and conducted 15 interviews.", "result": "Identified PMs' GenAI adoption rates, use cases, benefits/barriers; developed framework for task delegation to GenAI; documented adaptation practices and role evolution perceptions.", "conclusion": "GenAI is significantly transforming PM roles, with implications for broader GenAI workflow adoption and software development team structures."}}
{"id": "2510.02534", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02534", "abs": "https://arxiv.org/abs/2510.02534", "authors": ["Mohsen Iranmanesh", "Sina Moradi Sabet", "Sina Marefat", "Ali Javidi Ghasr", "Allison Wilson", "Iman Sharafaldin", "Mohammad A. Tayebi"], "title": "ZeroFalse: Improving Precision in Static Analysis with LLMs", "comment": null, "summary": "Static Application Security Testing (SAST) tools are integral to modern\nsoftware development, yet their adoption is undermined by excessive false\npositives that weaken developer trust and demand costly manual triage. We\npresent ZeroFalse, a framework that integrates static analysis with large\nlanguage models (LLMs) to reduce false positives while preserving coverage.\nZeroFalse treats static analyzer outputs as structured contracts, enriching\nthem with flow-sensitive traces, contextual evidence, and CWE-specific\nknowledge before adjudication by an LLM. This design preserves the systematic\nreach of static analysis while leveraging the reasoning capabilities of LLMs.\nWe evaluate ZeroFalse across both benchmarks and real-world projects using ten\nstate-of-the-art LLMs. Our best-performing models achieve F1-scores of 0.912 on\nthe OWASP Java Benchmark and 0.955 on the OpenVuln dataset, maintaining recall\nand precision above 90%. Results further show that CWE-specialized prompting\nconsistently outperforms generic prompts, and reasoning-oriented LLMs provide\nthe most reliable precision-recall balance. These findings position ZeroFalse\nas a practical and scalable approach for enhancing the reliability of SAST and\nsupporting its integration into real-world CI/CD pipelines.", "AI": {"tldr": "ZeroFalse integrates static analysis with LLMs to reduce false positives in SAST tools while maintaining coverage, achieving F1-scores up to 0.955.", "motivation": "SAST tools suffer from excessive false positives that undermine developer trust and require costly manual triage.", "method": "Treats static analyzer outputs as structured contracts, enriches them with flow-sensitive traces, contextual evidence, and CWE-specific knowledge before LLM adjudication.", "result": "Achieves F1-scores of 0.912 on OWASP Java Benchmark and 0.955 on OpenVuln dataset, with recall and precision above 90%. CWE-specialized prompting and reasoning-oriented LLMs perform best.", "conclusion": "ZeroFalse provides a practical and scalable approach to enhance SAST reliability for real-world CI/CD integration."}}
{"id": "2510.02585", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02585", "abs": "https://arxiv.org/abs/2510.02585", "authors": ["Majid Dashtbani", "Ladan Tahvildari"], "title": "Key Considerations for Auto-Scaling: Lessons from Benchmark Microservices", "comment": null, "summary": "Microservices have become the dominant architectural paradigm for building\nscalable and modular cloud-native systems. However, achieving effective\nauto-scaling in such systems remains a non-trivial challenge, as it depends not\nonly on advanced scaling techniques but also on sound design, implementation,\nand deployment practices. Yet, these foundational aspects are often overlooked\nin existing benchmarks, making it difficult to evaluate autoscaling methods\nunder realistic conditions. In this paper, we identify a set of practical\nauto-scaling considerations by applying several state-of-the-art autoscaling\nmethods to widely used microservice benchmarks. To structure these findings, we\nclassify the issues based on when they arise during the software lifecycle:\nArchitecture, Implementation, and Deployment. The Architecture phase covers\nhigh-level decisions such as service decomposition and inter-service\ndependencies. The Implementation phase includes aspects like initialization\noverhead, metrics instrumentation, and error propagation. The Deployment phase\nfocuses on runtime configurations such as resource limits and health checks. We\nvalidate these considerations using the Sock-Shop benchmark and evaluate\ndiverse auto-scaling strategies, including threshold-based, control-theoretic,\nlearning-based, black-box optimization, and dependency-aware approaches. Our\nfindings show that overlooking key lifecycle concerns can degrade autoscaler\nperformance, while addressing them leads to more stable and efficient scaling.\nThese results underscore the importance of lifecycle-aware engineering for\nunlocking the full potential of auto-scaling in microservice-based systems.", "AI": {"tldr": "The paper identifies practical auto-scaling considerations for microservices by applying state-of-the-art methods to benchmarks, classifying issues across Architecture, Implementation, and Deployment phases, and showing that addressing lifecycle concerns improves scaling performance.", "motivation": "Achieving effective auto-scaling in microservices is challenging and depends on sound design, implementation, and deployment practices, which are often overlooked in existing benchmarks, making it difficult to evaluate autoscaling methods under realistic conditions.", "method": "Applied several state-of-the-art autoscaling methods to widely used microservice benchmarks, classified issues based on software lifecycle phases (Architecture, Implementation, Deployment), and validated using the Sock-Shop benchmark with diverse scaling strategies.", "result": "Findings show that overlooking key lifecycle concerns degrades autoscaler performance, while addressing them leads to more stable and efficient scaling.", "conclusion": "Lifecycle-aware engineering is crucial for unlocking the full potential of auto-scaling in microservice-based systems."}}
{"id": "2510.02609", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02609", "abs": "https://arxiv.org/abs/2510.02609", "authors": ["Chengquan Guo", "Chulin Xie", "Yu Yang", "Zhaorun Chen", "Zinan Lin", "Xander Davies", "Yarin Gal", "Dawn Song", "Bo Li"], "title": "RedCodeAgent: Automatic Red-teaming Agent against Diverse Code Agents", "comment": null, "summary": "Code agents have gained widespread adoption due to their strong code\ngeneration capabilities and integration with code interpreters, enabling\ndynamic execution, debugging, and interactive programming capabilities. While\nthese advancements have streamlined complex workflows, they have also\nintroduced critical safety and security risks. Current static safety benchmarks\nand red-teaming tools are inadequate for identifying emerging real-world risky\nscenarios, as they fail to cover certain boundary conditions, such as the\ncombined effects of different jailbreak tools. In this work, we propose\nRedCodeAgent, the first automated red-teaming agent designed to systematically\nuncover vulnerabilities in diverse code agents. With an adaptive memory module,\nRedCodeAgent can leverage existing jailbreak knowledge, dynamically select the\nmost effective red-teaming tools and tool combinations in a tailored toolbox\nfor a given input query, thus identifying vulnerabilities that might otherwise\nbe overlooked. For reliable evaluation, we develop simulated sandbox\nenvironments to additionally evaluate the execution results of code agents,\nmitigating potential biases of LLM-based judges that only rely on static code.\nThrough extensive evaluations across multiple state-of-the-art code agents,\ndiverse risky scenarios, and various programming languages, RedCodeAgent\nconsistently outperforms existing red-teaming methods, achieving higher attack\nsuccess rates and lower rejection rates with high efficiency. We further\nvalidate RedCodeAgent on real-world code assistants, e.g., Cursor and Codeium,\nexposing previously unidentified security risks. By automating and optimizing\nred-teaming processes, RedCodeAgent enables scalable, adaptive, and effective\nsafety assessments of code agents.", "AI": {"tldr": "RedCodeAgent is an automated red-teaming agent that systematically uncovers vulnerabilities in code agents by leveraging adaptive memory, dynamic tool selection, and simulated sandbox environments for reliable evaluation.", "motivation": "Current static safety benchmarks and red-teaming tools are inadequate for identifying emerging real-world risky scenarios in code agents, particularly boundary conditions like combined effects of different jailbreak tools.", "method": "Uses an adaptive memory module to leverage existing jailbreak knowledge, dynamically selects effective red-teaming tools and combinations from a tailored toolbox, and employs simulated sandbox environments to evaluate execution results.", "result": "Outperforms existing red-teaming methods across multiple code agents, achieving higher attack success rates and lower rejection rates with high efficiency. Successfully exposed previously unidentified security risks in real-world code assistants like Cursor and Codeium.", "conclusion": "RedCodeAgent enables scalable, adaptive, and effective safety assessments of code agents by automating and optimizing red-teaming processes."}}
{"id": "2510.02634", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.02634", "abs": "https://arxiv.org/abs/2510.02634", "authors": ["Hanlong Wan", "Weili Xu", "Michael Rosenberg", "Jian Zhang", "Aysha Siddika"], "title": "Automatic Building Code Review: A Case Study", "comment": null, "summary": "Building officials, particularly those in resource-constrained or rural\njurisdictions, face labor-intensive, error-prone, and costly manual reviews of\ndesign documents as projects increase in size and complexity. The growing\nadoption of Building Information Modeling (BIM) and Large Language Models\n(LLMs) presents opportunities for automated code review (ACR) solutions. This\nstudy introduces a novel agent-driven framework that integrates BIM-based data\nextraction with automated verification using both retrieval-augmented\ngeneration (RAG) and Model Context Protocol (MCP) agent pipelines. The\nframework employs LLM-enabled agents to extract geometry, schedules, and system\nattributes from heterogeneous file types, which are then processed for building\ncode checking through two complementary mechanisms: (1) direct API calls to the\nUS Department of Energy COMcheck engine, providing deterministic and\naudit-ready outputs, and (2) RAG-based reasoning over rule provisions, enabling\nflexible interpretation where coverage is incomplete or ambiguous.\n  The framework was evaluated through case demonstrations, including automated\nextraction of geometric attributes (such as surface area, tilt, and insulation\nvalues), parsing of operational schedules, and validation of lighting\nallowances under ASHRAE Standard 90.1-2022. Comparative performance tests\nacross multiple LLMs showed that GPT-4o achieved the best balance of efficiency\nand stability, while smaller models exhibited inconsistencies or failures.\nResults confirm that MCP agent pipelines outperform RAG reasoning pipelines in\nrigor and reliability. This work advances ACR research by demonstrating a\nscalable, interoperable, and production-ready approach that bridges BIM with\nauthoritative code review tools.", "AI": {"tldr": "A novel agent-driven framework that integrates BIM data extraction with automated building code verification using RAG and MCP agent pipelines, enabling scalable and reliable automated code review.", "motivation": "Manual building code reviews are labor-intensive, error-prone, and costly, especially for resource-constrained jurisdictions, while BIM adoption and LLMs present opportunities for automated solutions.", "method": "Uses LLM-enabled agents to extract geometry, schedules, and system attributes from BIM files, then processes them through two mechanisms: direct API calls to COMcheck engine for deterministic outputs, and RAG-based reasoning for flexible interpretation of ambiguous rules.", "result": "GPT-4o achieved the best balance of efficiency and stability; MCP agent pipelines outperformed RAG reasoning pipelines in rigor and reliability; successfully demonstrated automated extraction of geometric attributes, operational schedules, and lighting allowances validation.", "conclusion": "The framework advances automated code review research by providing a scalable, interoperable, and production-ready approach that bridges BIM with authoritative code review tools."}}
{"id": "2510.02718", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02718", "abs": "https://arxiv.org/abs/2510.02718", "authors": ["Ali Ghanbari", "Sasan Tavakkol"], "title": "Using Fourier Analysis and Mutant Clustering to Accelerate DNN Mutation Testing", "comment": "2025 40th IEEE/ACM International Conference on Automated Software\n  Engineering (ASE)", "summary": "Deep neural network (DNN) mutation analysis is a promising approach to\nevaluating test set adequacy. Due to the large number of generated mutants that\nmust be tested on large datasets, mutation analysis is costly. In this paper,\nwe present a technique, named DM#, for accelerating DNN mutation testing using\nFourier analysis. The key insight is that DNN outputs are real-valued functions\nsuitable for Fourier analysis that can be leveraged to quantify mutant behavior\nusing only a few data points. DM# uses the quantified mutant behavior to\ncluster the mutants so that the ones with similar behavior fall into the same\ngroup. A representative from each group is then selected for testing, and the\nresult of the test, e.g., whether the mutant is killed or survived, is reused\nfor all other mutants represented by the selected mutant, obviating the need\nfor testing other mutants. 14 DNN models of sizes ranging from thousands to\nmillions of parameters, trained on different datasets, are used to evaluate DM#\nand compare it to several baseline techniques. Our results provide empirical\nevidence on the effectiveness of DM# in accelerating mutation testing by\n28.38%, on average, at the average cost of only 0.72% error in mutation score.\nMoreover, on average, DM# incurs 11.78, 15.16, and 114.36 times less mutation\nscore error compared to random mutant selection, boundary sample selection, and\nrandom sample selection techniques, respectively, while generally offering\ncomparable speed-up.", "AI": {"tldr": "DM# accelerates DNN mutation testing using Fourier analysis to cluster mutants by behavior, enabling representative testing that reduces computational costs while maintaining accuracy.", "motivation": "DNN mutation analysis is computationally expensive due to the large number of mutants and datasets, requiring an efficient acceleration technique.", "method": "Uses Fourier analysis to quantify mutant behavior with few data points, clusters mutants by similarity, and tests only representatives from each cluster.", "result": "Accelerates mutation testing by 28.38% on average with only 0.72% error in mutation score, outperforming baseline techniques by significant margins.", "conclusion": "DM# effectively reduces computational costs of DNN mutation testing while maintaining high accuracy through intelligent mutant clustering and representative testing."}}
{"id": "2510.02773", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.02773", "abs": "https://arxiv.org/abs/2510.02773", "authors": ["Tamjid Al Rahat", "Yanju Chen", "Yu Feng", "Yuan Tian"], "title": "Automated Repair of OpenID Connect Programs (Extended Version)", "comment": "This is an extended version. The original paper is accepted to ASE\n  2025", "summary": "OpenID Connect has revolutionized online authentication based on single\nsign-on (SSO) by providing a secure and convenient method for accessing\nmultiple services with a single set of credentials. Despite its widespread\nadoption, critical security bugs in OpenID Connect have resulted in significant\nfinancial losses and security breaches, highlighting the need for robust\nmitigation strategies. Automated program repair presents a promising solution\nfor generating candidate patches for OpenID implementations. However,\nchallenges such as domain-specific complexities and the necessity for precise\nfault localization and patch verification must be addressed. We propose\nAuthFix, a counterexample-guided repair engine leveraging LLMs for automated\nOpenID bug fixing. AuthFix integrates three key components: fault localization,\npatch synthesis, and patch verification. By employing a novel Petri-net-based\nmodel checker, AuthFix ensures the correctness of patches by effectively\nmodeling interactions. Our evaluation on a dataset of OpenID bugs demonstrates\nthat AuthFix successfully generated correct patches for 17 out of 23 bugs\n(74%), with a high proportion of patches semantically equivalent to\ndeveloper-written fixes.", "AI": {"tldr": "AuthFix is an automated program repair system using LLMs and counterexample-guided synthesis to fix OpenID Connect security bugs, achieving 74% success rate on real-world vulnerabilities.", "motivation": "OpenID Connect has critical security bugs causing financial losses and breaches, but automated repair faces challenges with domain complexity and precise fault localization.", "method": "AuthFix uses LLMs for counterexample-guided repair with three components: fault localization, patch synthesis, and patch verification using a Petri-net-based model checker.", "result": "AuthFix successfully generated correct patches for 17 out of 23 OpenID bugs (74%), with many patches semantically equivalent to developer-written fixes.", "conclusion": "AuthFix effectively automates OpenID bug fixing, demonstrating high success rates and semantic equivalence to manual fixes, addressing critical security vulnerabilities."}}
{"id": "2510.02854", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02854", "abs": "https://arxiv.org/abs/2510.02854", "authors": ["Boshuai Ye", "Arif Ali Khan", "Teemu Pihkakoski", "Peng Liang", "Muhammad Azeem Akbar", "Matti Silveri", "Lauri Malmi"], "title": "C2|Q>: A Robust Framework for Bridging Classical and Quantum Software Development", "comment": "46 pages, 8 images, 14 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "Quantum Software Engineering (QSE) is emerging as a critical discipline to\nmake quantum computing accessible to a broader developer community; however,\nmost quantum development environments still require developers to engage with\nlow-level details across the software stack - including problem encoding,\ncircuit construction, algorithm configuration, hardware selection, and result\ninterpretation - making them difficult for classical software engineers to use.\nTo bridge this gap, we present C2|Q>: a hardware-agnostic quantum software\ndevelopment framework that translates classical specifications (code) into\nquantum-executable programs while preserving methodological rigor. The\nframework applies modular software engineering principles by classifying the\nworkflow into three core modules: an encoder that classifies problems, produces\nQuantum-Compatible Formats (QCFs), and constructs quantum circuits, a\ndeployment module that generates circuits and recommends hardware based on\nfidelity, runtime, and cost, and a decoder that interprets quantum outputs into\nclassical solutions. In evaluation, the encoder module achieved a 93.8%\ncompletion rate, the hardware recommendation module consistently selected the\nappropriate quantum devices for workloads scaling up to 56 qubits, and the full\nC2|Q>: workflow successfully processed classical specifications (434 Python\nsnippets and 100 JSON inputs) with completion rates of 93.8% and 100%,\nrespectively. For case study problems executed on publicly available NISQ\nhardware, C2|Q>: reduced the required implementation effort by nearly 40X\ncompared to manual implementations using low-level quantum software development\nkits (SDKs), with empirical runs limited to small- and medium-sized instances\nconsistent with current NISQ capabilities. The open-source implementation of\nC2|Q>: is available at https://github.com/C2-Q/C2Q", "AI": {"tldr": "C2|Q>: is a quantum software development framework that translates classical code into quantum programs, reducing implementation effort by 40X compared to manual quantum SDKs.", "motivation": "To make quantum computing accessible to classical software engineers by bridging the gap between classical specifications and quantum execution, eliminating the need for low-level quantum details.", "method": "Uses a modular three-component workflow: encoder (problem classification, QCF generation, circuit construction), deployment module (circuit generation, hardware recommendation), and decoder (quantum output interpretation).", "result": "Encoder achieved 93.8% completion rate, hardware recommendation worked for up to 56 qubits, full workflow processed 434 Python snippets (93.8% completion) and 100 JSON inputs (100% completion), with 40X reduction in implementation effort.", "conclusion": "C2|Q>: successfully demonstrates that quantum software development can be made accessible to classical developers through automated translation frameworks, significantly reducing implementation complexity."}}
{"id": "2510.02887", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02887", "abs": "https://arxiv.org/abs/2510.02887", "authors": ["Zhao Zhang", "Qingyuan Liang", "Zeyu Sun", "Yizhou Chen", "Guoqing Wang", "Yican Sun", "Lu Zhang", "Ge Li", "Yingfei Xiong"], "title": "GramTrans: A Better Code Representation Approach in Code Generation", "comment": null, "summary": "Code generation has shown great promise in assisting software development. A\nfundamental yet underexplored question is how the choice of code representation\naffects model performance. While existing studies employ various\nrepresentations, such as treating code as plain text, grammar rule sequences,\nor syntax tree sequences, they lack a principled understanding of the\nrelationship between parsing difficulty and model effectiveness. This paper\nproposes a conjecture: the easier a representation is to parse, the better\nperformance the model achieves. We formalize this idea using grammar classes,\nwhere representations in simpler classes (e.g., LL(1)) are easier to parse.\nThrough a controlled experiment on a Python-based DSL, we show that parsing\ndifficulty strongly correlates with model performance. Motivated by this\nfinding, we present GramTrans, a general approach that automatically transforms\na context-free language into a representation within the LL(1) class. GramTrans\nintroduces a novel hierarchical conflict elimination algorithm, enabling a\nflexible trade-off between syntactic simplicity and token efficiency. We\nevaluate GramTrans on both Python and Java using three code generation models:\nStarCoder 1B, DeepSeek-Coder 1.3B, and Qwen2.5 1.5B. Across multiple\nbenchmarks, GramTrans consistently delivers significant improvements over\nbaseline representations. Furthermore, our analysis of existing representations\nreconfirms the strong alignment between parsing difficulty and model\nperformance, providing additional support for the conjecture.", "AI": {"tldr": "The paper shows that code representations that are easier to parse (using simpler grammar classes like LL(1)) lead to better model performance in code generation. They introduce GramTrans to automatically transform context-free languages into LL(1) representations.", "motivation": "Existing studies use various code representations but lack understanding of how parsing difficulty affects model performance. The paper aims to establish that simpler parsing leads to better model results.", "method": "Propose the conjecture that easier-to-parse representations improve model performance. Introduce GramTrans with hierarchical conflict elimination to transform context-free languages into LL(1) grammar class representations.", "result": "Parsing difficulty strongly correlates with model performance. GramTrans consistently improves performance across Python and Java using three code generation models (StarCoder, DeepSeek-Coder, Qwen2.5) on multiple benchmarks.", "conclusion": "The conjecture is supported - simpler parsing representations lead to better model performance. GramTrans provides an effective approach to achieve this transformation while balancing syntactic simplicity and token efficiency."}}
{"id": "2510.02917", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.02917", "abs": "https://arxiv.org/abs/2510.02917", "authors": ["Kriz Tahimic", "Charibeth Cheng"], "title": "Mechanistic Interpretability of Code Correctness in LLMs via Sparse Autoencoders", "comment": null, "summary": "As Large Language Models become integral to software development, with\nsubstantial portions of AI-suggested code entering production, understanding\ntheir internal correctness mechanisms becomes critical for safe deployment. We\napply sparse autoencoders to decompose LLM representations, identifying\ndirections that correspond to code correctness. We select predictor directions\nusing t-statistics and steering directions through separation scores from base\nmodel representations, then analyze their mechanistic properties through\nsteering, attention analysis, and weight orthogonalization. We find that code\ncorrectness directions in LLMs reliably predict incorrect code, while\ncorrection capabilities, though statistically significant, involve tradeoffs\nbetween fixing errors and preserving correct code. Mechanistically, successful\ncode generation depends on attending to test cases rather than problem\ndescriptions. Moreover, directions identified in base models retain their\neffectiveness after instruction-tuning, suggesting code correctness mechanisms\nlearned during pre-training are repurposed during fine-tuning. Our mechanistic\ninsights suggest three practical applications: prompting strategies should\nprioritize test examples over elaborate problem descriptions, predictor\ndirections can serve as error alarms for developer review, and these same\npredictors can guide selective steering, intervening only when errors are\nanticipated to prevent the code corruption from constant steering.", "AI": {"tldr": "The paper analyzes LLM code correctness mechanisms using sparse autoencoders, identifying directions that predict incorrect code and enable selective steering interventions.", "motivation": "Understanding LLM internal correctness mechanisms is critical for safe deployment as AI-suggested code enters production systems.", "method": "Apply sparse autoencoders to decompose LLM representations, identify code correctness directions using t-statistics and separation scores, then analyze through steering, attention analysis, and weight orthogonalization.", "result": "Code correctness directions reliably predict incorrect code, while correction involves tradeoffs between fixing errors and preserving correct code. Successful code generation depends on attending to test cases rather than problem descriptions.", "conclusion": "Code correctness mechanisms learned during pre-training are repurposed during fine-tuning. Practical applications include prioritizing test examples in prompts, using predictor directions as error alarms, and selective steering to prevent code corruption."}}
{"id": "2510.02934", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02934", "abs": "https://arxiv.org/abs/2510.02934", "authors": ["Thanh Trong Vu", "Tuan-Dung Bui", "Thu-Trang Nguyen", "Son Nguyen", "Hieu Dinh Vo"], "title": "Model-Agnostic Correctness Assessment for LLM-Generated Code via Dynamic Internal Representation Selection", "comment": null, "summary": "Large Language Models (LLMs) have demonstrated impressive capabilities in\ncode generation and are increasingly integrated into the software development\nprocess. However, ensuring the correctness of LLM-generated code remains a\ncritical concern. Prior work has shown that the internal representations of\nLLMs encode meaningful signals for assessing code correctness. Nevertheless,\nthe existing methods rely on representations from pre-selected/fixed layers and\ntoken positions, which could limit its generalizability across diverse model\narchitectures and tasks. In this work, we introduce AUTOPROBE, a novel\nmodel-agnostic approach that dynamically selects the most informative internal\nrepresentations for code correctness assessment. AUTOPROBE employs an\nattention-based mechanism to learn importance scores for hidden states,\nenabling it to focus on the most relevant features. These weighted\nrepresentations are then aggregated and passed to a probing classifier to\npredict code correctness across multiple dimensions, including compilability,\nfunctionality, and security. To evaluate the performance of AUTOPROBE, we\nconduct extensive experiments across multiple benchmarks and code LLMs. Our\nexperimental results show that AUTOPROBE consistently outperforms the\nbaselines. For security assessment, AUTOPROBE surpasses the state-of-the-art\nwhite-box approach by 18%. For compilability and functionality assessment,\nAUTOPROBE demonstrates its highest robustness to code complexity, with the\nperformance higher than the other approaches by up to 19% and 111%,\nrespectively. These findings highlight that dynamically selecting important\ninternal signals enables AUTOPROBE to serve as a robust and generalizable\nsolution for assessing the correctness of code generated by various LLMs.", "AI": {"tldr": "AUTOPROBE is a model-agnostic approach that dynamically selects the most informative internal representations from LLMs for code correctness assessment, outperforming existing methods across compilability, functionality, and security dimensions.", "motivation": "Existing methods for assessing LLM-generated code correctness rely on fixed layer and token positions, limiting generalizability across different model architectures and tasks.", "method": "AUTOPROBE uses an attention-based mechanism to learn importance scores for hidden states, aggregates weighted representations, and passes them to a probing classifier to predict code correctness across multiple dimensions.", "result": "AUTOPROBE consistently outperforms baselines, achieving 18% improvement in security assessment and up to 19% and 111% improvements in compilability and functionality assessment respectively, showing highest robustness to code complexity.", "conclusion": "Dynamically selecting important internal signals enables AUTOPROBE to serve as a robust and generalizable solution for assessing code correctness across various LLMs."}}
{"id": "2510.02991", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.02991", "abs": "https://arxiv.org/abs/2510.02991", "authors": ["Carlos Albuquerque", "Filipe F. Correia"], "title": "Tracing and Metrics Design Patterns for Monitoring Cloud-native Applications", "comment": "Accepted for publication in the EuroPLoP 2025 proceedings", "summary": "Observability helps ensure the reliability and maintainability of\ncloud-native applications. As software architectures become increasingly\ndistributed and subject to change, it becomes a greater challenge to diagnose\nsystem issues effectively, often having to deal with fragmented observability\nand more difficult root cause analysis. This paper builds upon our previous\nwork and introduces three design patterns that address key challenges in\nmonitoring cloud-native applications. Distributed Tracing improves visibility\ninto request flows across services, aiding in latency analysis and root cause\ndetection, Application Metrics provides a structured approach to instrumenting\napplications with meaningful performance indicators, enabling real-time\nmonitoring and anomaly detection, and Infrastructure Metrics focuses on\nmonitoring the environment in which the system is operated, helping teams\nassess resource utilization, scalability, and operational health. These\npatterns are derived from industry practices and observability frameworks and\naim to offer guidance for software practitioners.", "AI": {"tldr": "This paper introduces three observability design patterns for cloud-native applications: Distributed Tracing, Application Metrics, and Infrastructure Metrics to improve system reliability and maintainability.", "motivation": "As software architectures become increasingly distributed and subject to change, diagnosing system issues becomes more challenging due to fragmented observability and difficult root cause analysis.", "method": "The paper builds on previous work and introduces three design patterns derived from industry practices and observability frameworks: Distributed Tracing for request flow visibility, Application Metrics for structured performance monitoring, and Infrastructure Metrics for environment monitoring.", "result": "The patterns provide guidance for improving visibility into request flows across services, enabling real-time monitoring and anomaly detection, and helping teams assess resource utilization, scalability, and operational health.", "conclusion": "These three observability design patterns aim to offer practical guidance for software practitioners to address key challenges in monitoring cloud-native applications and improve system reliability."}}
{"id": "2510.03005", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03005", "abs": "https://arxiv.org/abs/2510.03005", "authors": ["Daniel Pinho", "Petr P\u00edcha", "Filipe Correia", "P\u0159emek Brada"], "title": "Patterns for Teaching Agile with Student Projects -- Team and Project Setup", "comment": "Accepted for publication in the EuroPLoP 2025 proceedings", "summary": "Higher education courses teaching about agile software development (ASD) have\nincreased in commonality as the ideas behind the Agile Manifesto became more\ncommonplace in the industry. However, a lot of the literature on how ASD is\napplied in the classroom does not provide much actionable advice, focusing on\nframeworks or even moving beyond the software development area into teaching in\nan agile way. We, therefore, showcase early work on a pattern language that\nfocuses on teaching ASD practices to university students, which stems from our\nown experiences as educators in higher education contexts. We present five\npatterns, specifically focused on team and project setup phase: Capping Team\nSize, Smaller Project Scope, Business Non-Critical Project, Self-assembling\nTeams, and Team Chooses Topic as a starting point for developing the overall\npattern language.", "AI": {"tldr": "A pattern language for teaching agile software development practices to university students, focusing on team and project setup with five initial patterns.", "motivation": "Existing literature on teaching ASD lacks actionable advice, often focusing on frameworks or moving beyond software development into agile teaching methods.", "method": "Developed a pattern language based on educators' experiences in higher education, presenting five initial patterns for team and project setup phase.", "result": "Created five patterns: Capping Team Size, Smaller Project Scope, Business Non-Critical Project, Self-assembling Teams, and Team Chooses Topic as a starting point.", "conclusion": "This early work provides a foundation for developing a comprehensive pattern language to effectively teach agile software development practices in university settings."}}
{"id": "2510.03029", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03029", "abs": "https://arxiv.org/abs/2510.03029", "authors": ["Debalina Ghosh Paul", "Hong Zhu", "Ian Bayley"], "title": "Investigating The Smells of LLM Generated Code", "comment": null, "summary": "Context: Large Language Models (LLMs) are increasingly being used to generate\nprogram code. Much research has been reported on the functional correctness of\ngenerated code, but there is far less on code quality.\n  Objectives: In this study, we propose a scenario-based method of evaluating\nthe quality of LLM-generated code to identify the weakest scenarios in which\nthe quality of LLM generated code should be improved.\n  Methods: The method measures code smells, an important indicator of code\nquality, and compares them with a baseline formed from reference solutions of\nprofessionally written code. The test dataset is divided into various subsets\naccording to the topics of the code and complexity of the coding tasks to\nrepresent different scenarios of using LLMs for code generation. We will also\npresent an automated test system for this purpose and report experiments with\nthe Java programs generated in response to prompts given to four\nstate-of-the-art LLMs: Gemini Pro, ChatGPT, Codex, and Falcon.\n  Results: We find that LLM-generated code has a higher incidence of code\nsmells compared to reference solutions. Falcon performed the least badly, with\na smell increase of 42.28%, followed by Gemini Pro (62.07%), ChatGPT (65.05%)\nand finally Codex (84.97%). The average smell increase across all LLMs was\n63.34%, comprising 73.35% for implementation smells and 21.42% for design\nsmells. We also found that the increase in code smells is greater for more\ncomplex coding tasks and for more advanced topics, such as those involving\nobject-orientated concepts.\n  Conclusion: In terms of code smells, LLM's performances on various coding\ntask complexities and topics are highly correlated to the quality of human\nwritten code in the corresponding scenarios. However, the quality of LLM\ngenerated code is noticeably poorer than human written code.", "AI": {"tldr": "This study evaluates code quality (specifically code smells) in LLM-generated Java programs compared to professionally written reference solutions, finding LLM code has significantly more smells (63.34% average increase) with performance varying by task complexity and topic.", "motivation": "While much research focuses on functional correctness of LLM-generated code, there is limited investigation into code quality aspects like code smells, which are important indicators of maintainability and software quality.", "method": "Scenario-based evaluation measuring code smells in Java programs generated by four LLMs (Gemini Pro, ChatGPT, Codex, Falcon), comparing against baseline reference solutions, with analysis across different coding topics and task complexities.", "result": "LLM-generated code has 63.34% more code smells on average than reference solutions, with Codex performing worst (84.97% increase) and Falcon best (42.28% increase). More complex tasks and object-oriented topics showed greater smell increases.", "conclusion": "LLM performance on code quality correlates with human code quality patterns across scenarios, but LLM-generated code quality is noticeably poorer than human-written code, especially for complex tasks and advanced programming concepts."}}
{"id": "2510.03050", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03050", "abs": "https://arxiv.org/abs/2510.03050", "authors": ["Rita Peixoto", "Filipe F. Correia", "Thatiane Rosa", "Eduardo Guerra", "Alfredo Goldman"], "title": "Refactoring Towards Microservices: Preparing the Ground for Service Extraction", "comment": "Accepted for publication in the EuroPLoP 2025 proceedings", "summary": "As organizations increasingly transition from monolithic systems to\nmicroservices, they aim to achieve higher availability, automatic scaling,\nsimplified infrastructure management, enhanced collaboration, and streamlined\ndeployments. However, this migration process remains largely manual and\nlabour-intensive. While existing literature offers various strategies for\ndecomposing monoliths, these approaches primarily focus on architecture-level\nguidance, often overlooking the code-level challenges and dependencies that\ndevelopers must address during the migration. This article introduces a\ncatalogue of seven refactorings specifically designed to support the transition\nto a microservices architecture with a focus on handling dependencies. The\ncatalogue provides developers with a systematic guide that consolidates\nrefactorings identified in the literature and addresses the critical gap in\nsystematizing the process at the code level. By offering a structured,\nstep-by-step approach, this work simplifies the migration process and lays the\ngroundwork for its potential automation, empowering developers to implement\nthese changes efficiently and effectively.", "AI": {"tldr": "A catalogue of seven refactorings for transitioning from monoliths to microservices, focusing on code-level dependencies and providing a systematic guide for developers.", "motivation": "Current migration from monoliths to microservices is manual and labor-intensive, with existing approaches focusing on architecture-level guidance while overlooking code-level challenges and dependencies.", "method": "Introduces a catalogue of seven refactorings specifically designed to handle dependencies during microservices migration, consolidating refactorings from literature and providing a structured, step-by-step approach.", "result": "Provides developers with a systematic guide that addresses the critical gap in systematizing the migration process at the code level, simplifying the migration process.", "conclusion": "The catalogue lays the groundwork for potential automation of microservices migration, empowering developers to implement changes efficiently and effectively."}}
{"id": "2510.03071", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.03071", "abs": "https://arxiv.org/abs/2510.03071", "authors": ["Facundo Molina", "Nazareno Aguirre", "Alessandra Gorla"], "title": "State Field Coverage: A Metric for Oracle Quality", "comment": null, "summary": "The effectiveness of testing in uncovering software defects depends not only\non the characteristics of the test inputs and how thoroughly they exercise the\nsoftware, but also on the quality of the oracles used to determine whether the\nsoftware behaves as expected. Therefore, assessing the quality of oracles is\ncrucial to improve the overall effectiveness of the testing process. Existing\nmetrics have been used for this purpose, but they either fail to provide a\ncomprehensive basis for guiding oracle improvement, or they are tailored to\nspecific types of oracles, thus limiting their generality.\n  In this paper, we introduce state field coverage, a novel metric for\nassessing oracle quality. This metric measures the proportion of an object's\nstate, as statically defined by its class fields, that an oracle may access\nduring test execution. The main intuition of our metric is that oracles with a\nhigher state field coverage are more likely to detect faults in the software\nunder analysis, as they inspect a larger portion of the object states to\ndetermine whether tests pass or not.\n  We implement a mechanism to statically compute the state field coverage\nmetric. Being statically computed, the metric is efficient and provides direct\nguidance for improving test oracles by identifying state fields that remain\nunexamined. We evaluate state field coverage through experiments involving 273\nrepresentation invariants and 249,027 test assertions. The results show that\nstate field coverage is a well-suited metric for assessing oracle quality, as\nit strongly correlates with the oracles' fault-detection ability, measured by\nmutation score.", "AI": {"tldr": "The paper introduces state field coverage, a novel metric for assessing oracle quality by measuring the proportion of an object's state fields that an oracle accesses during test execution.", "motivation": "Existing oracle quality metrics are either not comprehensive enough to guide oracle improvement or too specific to certain oracle types, limiting their general applicability.", "method": "The authors implement a static analysis mechanism to compute state field coverage, which identifies which class fields an oracle may access during test execution without requiring dynamic execution.", "result": "Evaluation with 273 representation invariants and 249,027 test assertions shows state field coverage strongly correlates with mutation score, indicating it effectively measures oracle fault-detection ability.", "conclusion": "State field coverage is an effective metric for assessing oracle quality that provides direct guidance for improving test oracles by identifying unexamined state fields."}}
{"id": "2510.03178", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.03178", "abs": "https://arxiv.org/abs/2510.03178", "authors": ["Cuong Chi Le", "Minh V. T. Pham", "Cuong Duc Van", "Hoang N. Phan", "Huy N. Phan", "Tien N. Nguyen"], "title": "When Names Disappear: Revealing What LLMs Actually Understand About Code", "comment": null, "summary": "Large Language Models (LLMs) achieve strong results on code tasks, but how\nthey derive program meaning remains unclear. We argue that code communicates\nthrough two channels: structural semantics, which define formal behavior, and\nhuman-interpretable naming, which conveys intent. Removing the naming channel\nseverely degrades intent-level tasks such as summarization, where models\nregress to line-by-line descriptions. Surprisingly, we also observe consistent\nreductions on execution tasks that should depend only on structure, revealing\nthat current benchmarks reward memorization of naming patterns rather than\ngenuine semantic reasoning. To disentangle these effects, we introduce a suite\nof semantics-preserving obfuscations and show that they expose identifier\nleakage across both summarization and execution. Building on these insights, we\nrelease ClassEval-Obf, an obfuscation-enhanced benchmark that systematically\nsuppresses naming cues while preserving behavior. Our results demonstrate that\nClassEval-Obf reduces inflated performance gaps, weakens memorization\nshortcuts, and provides a more reliable basis for assessing LLMs' code\nunderstanding and generalization.", "AI": {"tldr": "LLMs rely on naming patterns rather than structural semantics for code understanding, as shown through obfuscation experiments that reveal performance drops on both intent-level and execution tasks.", "motivation": "To understand how LLMs derive program meaning and determine whether they rely on structural semantics or human-interpretable naming patterns.", "method": "Introduced semantics-preserving obfuscations to remove naming cues while preserving code behavior, and created ClassEval-Obf benchmark to systematically test LLMs.", "result": "Removing naming channels degrades performance on intent-level tasks and surprisingly also reduces performance on execution tasks, revealing that current benchmarks reward memorization of naming patterns rather than genuine semantic reasoning.", "conclusion": "ClassEval-Obf provides a more reliable basis for assessing LLMs' code understanding by reducing inflated performance gaps and weakening memorization shortcuts."}}
{"id": "2510.03217", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.03217", "abs": "https://arxiv.org/abs/2510.03217", "authors": ["Jos\u00e9 Cambronero", "Michele Tufano", "Sherry Shi", "Renyao Wei", "Grant Uy", "Runxiang Cheng", "Chin-Jung Liu", "Shiying Pan", "Satish Chandra", "Pat Rondon"], "title": "Abstain and Validate: A Dual-LLM Policy for Reducing Noise in Agentic Program Repair", "comment": null, "summary": "Agentic Automated Program Repair (APR) is increasingly tackling complex,\nrepository-level bugs in industry, but ultimately agent-generated patches still\nneed to be reviewed by a human before committing them to ensure they address\nthe bug. Showing unlikely patches to developers can lead to substantial noise,\nwasting valuable developer time and eroding trust in automated code changes. We\nintroduce two complementary LLM-based policies to reduce such noise: bug\nabstention and patch validation policies. Bug abstention excludes bugs that the\nagentic APR system is unlikely to fix. Patch validation rejects patches that\nare unlikely to be a good fix for the given bug. We evaluate both policies on\nthree sets of bugs from Google's codebase, and their candidate patches\ngenerated by an internal agentic APR system. On a set of 174 human-reported\nbugs, removing bugs and patch trajectories rejected by our policies can raise\nsuccess rates by up to 13 percentage points and 15 percentage points,\nrespectively, and by up to 39 percentage points in combination. On null pointer\nexceptions and sanitizer-reported bugs with machine-generated bug reports,\npatch validation also improves average single-sample success rates. This\ntwo-policy approach provides a practical path to the reliable, industrial-scale\ndeployment of agentic APR systems.", "AI": {"tldr": "Introduces two LLM-based policies (bug abstention and patch validation) to reduce noise in agentic automated program repair by filtering out unlikely fixes before human review.", "motivation": "Agentic APR systems generate patches for complex bugs but show many unlikely patches to developers, wasting time and eroding trust in automated code changes.", "method": "Two complementary LLM-based policies: bug abstention (excludes bugs the system is unlikely to fix) and patch validation (rejects patches unlikely to be good fixes).", "result": "On 174 human-reported bugs, policies raised success rates by up to 13pp (bug abstention), 15pp (patch validation), and 39pp combined. Also improved success rates for null pointer exceptions and sanitizer-reported bugs.", "conclusion": "The two-policy approach provides a practical path for reliable, industrial-scale deployment of agentic APR systems by reducing noise and improving patch quality."}}
