{"id": "2510.21031", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.21031", "abs": "https://arxiv.org/abs/2510.21031", "authors": ["Qinghua Lu", "Dehai Zhao", "Yue Liu", "Hao Zhang", "Liming Zhu", "Xiwei Xu", "Angela Shi", "Tristan Tan", "Rick Kazman"], "title": "AgentArcEval: An Architecture Evaluation Method for Foundation Model based Agents", "comment": null, "summary": "The emergence of foundation models (FMs) has enabled the development of\nhighly capable and autonomous agents, unlocking new application opportunities\nacross a wide range of domains. Evaluating the architecture of agents is\nparticularly important as the architectural decisions significantly impact the\nquality attributes of agents given their unique characteristics, including\ncompound architecture, autonomous and non-deterministic behaviour, and\ncontinuous evolution. However, these traditional methods fall short in\naddressing the evaluation needs of agent architecture due to the unique\ncharacteristics of these agents. Therefore, in this paper, we present\nAgentArcEval, a novel agent architecture evaluation method designed specially\nto address the complexities of FM-based agent architecture and its evaluation.\nMoreover, we present a catalogue of agent-specific general scenarios, which\nserves as a guide for generating concrete scenarios to design and evaluate the\nagent architecture. We demonstrate the usefulness of AgentArcEval and the\ncatalogue through a case study on the architecture evaluation of a real-world\ntax copilot, named Luna.", "AI": {"tldr": "AgentArcEval is a novel method for evaluating foundation model-based agent architectures, addressing their unique characteristics like compound structure and autonomous behavior, with a case study on a tax copilot system.", "motivation": "Traditional evaluation methods are insufficient for FM-based agent architectures due to their unique characteristics including compound architecture, autonomous/non-deterministic behavior, and continuous evolution.", "method": "Proposes AgentArcEval, a specialized evaluation method for FM-based agent architectures, along with a catalogue of agent-specific general scenarios to guide concrete scenario generation.", "result": "Demonstrated through a case study on Luna, a real-world tax copilot system, showing the method's usefulness in evaluating agent architecture.", "conclusion": "AgentArcEval effectively addresses the evaluation needs of foundation model-based agent architectures, providing a specialized approach that traditional methods cannot handle."}}
{"id": "2510.21094", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.21094", "abs": "https://arxiv.org/abs/2510.21094", "authors": ["Yao Lu", "Wanwei Liu", "Tanghaoran Zhang", "Kang Yang", "Yang Zhang", "Wenyu Xu", "Longfei Sun", "Xinjun Mao", "Shuzheng Gao", "Michael R. Lyu"], "title": "BDiff: Block-aware and Accurate Text-based Code Differencing", "comment": null, "summary": "Code differencing is a fundamental technique in software engineering practice\nand research. While researchers have proposed text-based differencing\ntechniques capable of identifying line changes over the past decade, existing\nmethods exhibit a notable limitation in identifying edit actions (EAs) that\noperate on text blocks spanning multiple lines. Such EAs are common in\ndevelopers' practice, such as moving a code block for conditional branching or\nduplicating a method definition block for overloading. Existing tools represent\nsuch block-level operations as discrete sequences of line-level EAs, compelling\ndevelopers to manually correlate them and thereby substantially impeding the\nefficiency of change comprehension. To address this issue, we propose BDiff, a\ntext-based differencing algorithm capable of identifying two types of\nblock-level EAs and five types of line-level EAs. Building on traditional\ndifferencing algorithms, we first construct a candidate set containing all\npossible line mappings and block mappings. Leveraging the Kuhn-Munkres\nalgorithm, we then compute the optimal mapping set that can minimize the size\nof the edit script (ES) while closely aligning with the original developer's\nintent. To validate the effectiveness of BDiff, we selected five\nstate-of-the-art tools, including large language models (LLMs), as baselines\nand adopted a combined qualitative and quantitative approach to evaluate their\nperformance in terms of ES size, result quality, and running time. Experimental\nresults show that BDiff produces higher-quality differencing results than\nbaseline tools while maintaining competitive runtime performance. Our\nexperiments also show the unreliability of LLMs in code differencing tasks\nregarding result quality and their infeasibility in terms of runtime\nefficiency. We have implemented a web-based visual differencing tool.", "AI": {"tldr": "BDiff is a text-based code differencing algorithm that identifies block-level and line-level edit actions, outperforming existing tools including LLMs in result quality while maintaining competitive runtime.", "motivation": "Existing code differencing tools fail to properly identify block-level edit actions (like moving or duplicating multi-line code blocks), representing them as discrete line-level changes that developers must manually correlate, which hinders change comprehension efficiency.", "method": "BDiff builds on traditional differencing algorithms by constructing candidate sets of line and block mappings, then uses the Kuhn-Munkres algorithm to compute optimal mappings that minimize edit script size while aligning with developer intent.", "result": "BDiff produces higher-quality differencing results than five state-of-the-art baseline tools (including LLMs), maintaining competitive runtime performance. LLMs proved unreliable in result quality and infeasible in runtime efficiency.", "conclusion": "BDiff effectively addresses the limitation of existing tools in identifying block-level edit actions, providing more accurate and developer-friendly code differencing results, with a web-based visual tool implementation available."}}
{"id": "2510.21106", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.21106", "abs": "https://arxiv.org/abs/2510.21106", "authors": ["Zhen Yang", "Hongyi Lin", "Xiao Yu", "Jacky Wai Keung", "Shuo Liu", "Pak Yuen Patrick Chan", "Yicheng Sun", "Fengji Zhang"], "title": "R2ComSync: Improving Code-Comment Synchronization with In-Context Learning and Reranking", "comment": null, "summary": "Code-Comment Synchronization (CCS) aims to synchronize the comments with code\nchanges in an automated fashion, thereby significantly reducing the workload of\ndevelopers during software maintenance and evolution. While previous studies\nhave proposed various solutions that have shown success, they often exhibit\nlimitations, such as a lack of generalization ability or the need for extensive\ntask-specific learning resources. This motivates us to investigate the\npotential of Large Language Models (LLMs) in this area. However, a pilot\nanalysis proves that LLMs fall short of State-Of-The-Art (SOTA) CCS approaches\nbecause (1) they lack instructive demonstrations for In-Context Learning (ICL)\nand (2) many correct-prone candidates are not prioritized.To tackle the above\nchallenges, we propose R2ComSync, an ICL-based code-Comment Synchronization\napproach enhanced with Retrieval and Re-ranking. Specifically, R2ComSync\ncarries corresponding two novelties: (1) Ensemble hybrid retrieval. It equally\nconsiders the similarity in both code-comment semantics and change patterns\nwhen retrieval, thereby creating ICL prompts with effective examples. (2)\nMulti-turn re-ranking strategy. We derived three significant rules through\nlarge-scale CCS sample analysis. Given the inference results of LLMs, it\nprogressively exploits three re-ranking rules to prioritize relatively\ncorrect-prone candidates. We evaluate R2ComSync using five recent LLMs on three\nCCS datasets covering both Java and Python programming languages, and make\ncomparisons with five SOTA approaches. Extensive experiments demonstrate the\nsuperior performance of R2ComSync against other approaches. Moreover, both\nquantitative and qualitative analyses provide compelling evidence that the\ncomments synchronized by our proposal exhibit significantly higher quality.}", "AI": {"tldr": "R2ComSync is a novel code-comment synchronization approach that uses retrieval-augmented in-context learning and multi-turn re-ranking to improve LLM performance in synchronizing comments with code changes.", "motivation": "Previous code-comment synchronization approaches lack generalization ability and require extensive task-specific resources. LLMs show potential but underperform SOTA methods due to lack of instructive demonstrations and poor candidate prioritization.", "method": "R2ComSync uses ensemble hybrid retrieval (considering both code-comment semantics and change patterns) to create effective ICL prompts, and a multi-turn re-ranking strategy with three derived rules to prioritize correct-prone candidates from LLM outputs.", "result": "Evaluation on three datasets covering Java and Python shows R2ComSync outperforms five SOTA approaches. Both quantitative and qualitative analyses demonstrate significantly higher quality synchronized comments.", "conclusion": "R2ComSync successfully addresses LLM limitations in code-comment synchronization through retrieval-augmented ICL and intelligent re-ranking, achieving superior performance over existing methods."}}
{"id": "2510.21405", "categories": ["cs.SE", "cs.AR", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.21405", "abs": "https://arxiv.org/abs/2510.21405", "authors": ["Aidan Dakhama", "W. B. Langdon", "Hector D. Menendez", "Karine Even-Mendoza"], "title": "GreenMalloc: Allocator Optimisation for Industrial Workloads", "comment": null, "summary": "We present GreenMalloc, a multi objective search-based framework for\nautomatically configuring memory allocators. Our approach uses NSGA II and\nrand_malloc as a lightweight proxy benchmarking tool. We efficiently explore\nallocator parameters from execution traces and transfer the best configurations\nto gem5, a large system simulator, in a case study on two allocators: the GNU\nC/CPP compiler's glibc malloc and Google's TCMalloc. Across diverse workloads,\nour empirical results show up to 4.1 percantage reduction in average heap usage\nwithout loss of runtime efficiency; indeed, we get a 0.25 percantage reduction.", "AI": {"tldr": "GreenMalloc is a search-based framework that automatically configures memory allocators using NSGA-II and rand_malloc to optimize heap usage while maintaining runtime efficiency.", "motivation": "To automatically optimize memory allocator configurations for reduced heap usage without sacrificing performance, addressing the complexity of manual tuning.", "method": "Uses NSGA-II multi-objective search algorithm with rand_malloc as a lightweight proxy benchmark, analyzes execution traces, and transfers best configurations to gem5 simulator for validation on glibc malloc and TCMalloc.", "result": "Achieved up to 4.1% reduction in average heap usage with no runtime efficiency loss; actually achieved 0.25% improvement in runtime efficiency.", "conclusion": "GreenMalloc successfully demonstrates automated memory allocator configuration can significantly reduce heap usage while maintaining or slightly improving runtime performance across diverse workloads."}}
{"id": "2510.21413", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.21413", "abs": "https://arxiv.org/abs/2510.21413", "authors": ["Seyedmoein Mohsenimofidi", "Matthias Galster", "Christoph Treude", "Sebastian Baltes"], "title": "Context Engineering for AI Agents in Open-Source Software", "comment": "6 pages, 1 figure, 2 tables", "summary": "GenAI-based coding assistants have disrupted software development. Their next\ngeneration is agent-based, operating with more autonomy and potentially without\nhuman oversight. One challenge is to provide AI agents with sufficient context\nabout the software projects they operate in. Like humans, AI agents require\ncontextual information to develop solutions that are in line with the target\narchitecture, interface specifications, coding guidelines, standard workflows,\nand other project-specific policies. Popular AI agents for software development\n(e.g., Claude Code) advocate for maintaining tool-specific version-controlled\nMarkdown files that cover aspects such as the project structure, building and\ntesting, or code style. The content of these files is automatically added to\neach prompt. AGENTS.md has emerged as a potential standard that consolidates\ntool-specific formats. However, little is known about whether and how\ndevelopers adopt this format. Therefore, in this paper, we present the results\nof a preliminary study investigating the adoption of AI configuration files in\n466 open-source software projects, what information developers provide in these\nfiles, how they present that information, and how they evolve over time. Our\nfindings indicate that there is no established structure yet, and that there is\na lot of variation in terms of how context is provided (descriptive,\nprescriptive, prohibitive, explanatory, conditional). We see great potential in\nstudying which modifications in structure or presentation can positively affect\nthe quality of the generated content. Finally, our analysis of commits that\nhave modified AGENTS.md files provides first insights into how projects\ncontinuously extend and maintain these files. We conclude the paper by\noutlining how the adoption of AI configuration files in provides a unique\nopportunity to study real-world prompt and context engineering.", "AI": {"tldr": "This paper analyzes the adoption and evolution of AGENTS.md files in 466 open-source projects, finding no established structure yet and significant variation in how context is provided to AI coding assistants.", "motivation": "As AI agents become more autonomous in software development, they need contextual information about projects. AGENTS.md has emerged as a potential standard for providing this context, but little is known about actual developer adoption patterns.", "method": "Conducted a preliminary study analyzing 466 open-source software projects to investigate adoption of AI configuration files, examining what information developers provide, how they present it, and how these files evolve over time.", "result": "Findings show no established structure for AGENTS.md files yet, with significant variation in how context is provided (descriptive, prescriptive, prohibitive, explanatory, conditional). Analysis of commit history reveals how projects continuously extend and maintain these files.", "conclusion": "The adoption of AI configuration files provides a unique opportunity to study real-world prompt and context engineering, with potential to investigate how modifications in structure or presentation affect the quality of AI-generated content."}}
{"id": "2510.21443", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.21443", "abs": "https://arxiv.org/abs/2510.21443", "authors": ["Mohammad Amin Zadenoori", "Vincenzo De Martino", "Jacek Dabrowski", "Xavier Franch", "Alessio Ferrari"], "title": "Does Model Size Matter? A Comparison of Small and Large Language Models for Requirements Classification", "comment": null, "summary": "[Context and motivation] Large language models (LLMs) show notable results in\nnatural language processing (NLP) tasks for requirements engineering (RE).\nHowever, their use is compromised by high computational cost, data sharing\nrisks, and dependence on external services. In contrast, small language models\n(SLMs) offer a lightweight, locally deployable alternative. [Question/problem]\nIt remains unclear how well SLMs perform compared to LLMs in RE tasks in terms\nof accuracy. [Results] Our preliminary study compares eight models, including\nthree LLMs and five SLMs, on requirements classification tasks using the\nPROMISE, PROMISE Reclass, and SecReq datasets. Our results show that although\nLLMs achieve an average F1 score of 2% higher than SLMs, this difference is not\nstatistically significant. SLMs almost reach LLMs performance across all\ndatasets and even outperform them in recall on the PROMISE Reclass dataset,\ndespite being up to 300 times smaller. We also found that dataset\ncharacteristics play a more significant role in performance than model size.\n[Contribution] Our study contributes with evidence that SLMs are a valid\nalternative to LLMs for requirements classification, offering advantages in\nprivacy, cost, and local deployability.", "AI": {"tldr": "SLMs perform nearly as well as LLMs in requirements classification tasks despite being much smaller, with no statistically significant performance difference.", "motivation": "LLMs have computational costs, data sharing risks, and external service dependencies, while SLMs offer lightweight, locally deployable alternatives.", "method": "Compared 8 models (3 LLMs, 5 SLMs) on requirements classification using PROMISE, PROMISE Reclass, and SecReq datasets.", "result": "LLMs achieved only 2% higher average F1 score than SLMs (not statistically significant). SLMs even outperformed LLMs in recall on PROMISE Reclass dataset despite being up to 300x smaller.", "conclusion": "SLMs are a valid alternative to LLMs for requirements classification, offering advantages in privacy, cost, and local deployability."}}
{"id": "2510.21451", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.21451", "abs": "https://arxiv.org/abs/2510.21451", "authors": ["Yinglong Zou", "Juan Zhai", "Chunrong Fang", "An Guo", "Jiawei Liu", "Zhenyu Chen"], "title": "Scalpel: Automotive Deep Learning Framework Testing via Assembling Model Components", "comment": null, "summary": "Deep learning (DL) plays a key role in autonomous driving systems. DL models\nsupport perception modules, equipped with tasks such as object detection and\nsensor fusion. These DL models enable vehicles to process multi-sensor inputs\nto understand complex surroundings. Deploying DL models in autonomous driving\nsystems faces stringent challenges, including real-time processing, limited\ncomputational resources, and strict power constraints. To address these\nchallenges, automotive DL frameworks (e.g., PaddleInference) have emerged to\noptimize inference efficiency. However, these frameworks encounter unique\nquality issues due to their more complex deployment environments, such as\ncrashes stemming from limited scheduled memory and incorrect memory allocation.\nUnfortunately, existing DL framework testing methods fail to detect these\nquality issues due to the failure in deploying generated test input models, as\nthese models lack three essential capabilities: (1) multi-input/output tensor\nprocessing, (2) multi-modal data processing, and (3) multi-level data feature\nextraction. These capabilities necessitate specialized model components, which\nexisting testing methods neglect during model generation. To bridge this gap,\nwe propose Scalpel, an automotive DL frameworks testing method that generates\ntest input models at the model component level. Scalpel generates models by\nassembling model components (heads, necks, backbones) to support capabilities\nrequired by autonomous driving systems. Specifically, Scalpel maintains and\nupdates a repository of model components, generating test inputs by selecting,\nmutating, and assembling them. Successfully generated models are added back to\nenrich the repository. Newly generated models are then deployed within the\nautonomous driving system to test automotive DL frameworks via differential\ntesting.", "AI": {"tldr": "Scalpel is a testing method for automotive DL frameworks that generates test models by assembling components (heads, necks, backbones) to address unique quality issues in autonomous driving systems.", "motivation": "Existing DL framework testing methods fail to detect quality issues in automotive systems due to inability to generate models with essential capabilities: multi-input/output tensor processing, multi-modal data processing, and multi-level data feature extraction.", "method": "Scalpel generates test models at component level by maintaining a repository of model components, selecting, mutating, and assembling them to create models with required capabilities, then using differential testing.", "result": "The method successfully generates deployable test models that can detect quality issues in automotive DL frameworks that existing methods miss.", "conclusion": "Scalpel bridges the gap in automotive DL framework testing by generating specialized test models through component assembly, enabling detection of unique quality issues in autonomous driving deployment environments."}}
{"id": "2510.21452", "categories": ["cs.SE", "cs.CR", "cs.SI", "J.4; K.4.2; K.6.5; D.2.9; D.4.6"], "pdf": "https://arxiv.org/pdf/2510.21452", "abs": "https://arxiv.org/abs/2510.21452", "authors": ["Thomas Welsh", "Krist\u00f3fer Finnsson", "Brynj\u00f3lfur Stef\u00e1nsson", "Helmut Neukirchen"], "title": "Towards Socio-Technical Topology-Aware Adaptive Threat Detection in Software Supply Chains", "comment": "to be published in: The 12th International Conference on Social\n  Networks Analysis, Management and Security (SNAMS), IEEE", "summary": "Software supply chains (SSCs) are complex systems composed of dynamic,\nheterogeneous technical and social components which collectively achieve the\nproduction and maintenance of software artefacts. Attacks on SSCs are\nincreasing, yet pervasive vulnerability analysis is challenging due to their\ncomplexity. Therefore, threat detection must be targeted, to account for the\nlarge and dynamic structure, and adaptive, to account for its change and\ndiversity. While current work focuses on technical approaches for monitoring\nsupply chain dependencies and establishing component controls, approaches which\ninform threat detection through understanding the socio-technical dynamics are\nlacking. We outline a position and research vision to develop and investigate\nthe use of socio-technical models to support adaptive threat detection of SSCs.\nWe motivate this approach through an analysis of the XZ Utils attack whereby\nmalicious actors undermined the maintainers' trust via the project's GitHub and\nmailing lists. We highlight that monitoring technical and social data can\nidentify trends which indicate suspicious behaviour to then inform targeted and\nintensive vulnerability assessment. We identify challenges and research\ndirections to achieve this vision considering techniques for developer and\nsoftware analysis, decentralised adaptation and the need for a test bed for\nsoftware supply chain security research.", "AI": {"tldr": "The paper proposes using socio-technical models for adaptive threat detection in software supply chains, motivated by the XZ Utils attack, and identifies research challenges.", "motivation": "Software supply chains are complex and vulnerable to attacks, but current approaches focus mainly on technical monitoring without considering socio-technical dynamics, as demonstrated by the XZ Utils attack where malicious actors exploited social trust mechanisms.", "method": "The paper outlines a research vision to develop socio-technical models that monitor both technical and social data to identify suspicious behavior patterns, enabling targeted vulnerability assessment.", "result": "The analysis shows that monitoring socio-technical dynamics can reveal trends indicating malicious activity, allowing for more effective threat detection in complex software supply chains.", "conclusion": "There is a need for research into socio-technical modeling for adaptive threat detection, with key challenges including developer/software analysis techniques, decentralized adaptation, and creating testbeds for supply chain security research."}}
{"id": "2510.21460", "categories": ["cs.SE", "cs.CY", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.21460", "abs": "https://arxiv.org/abs/2510.21460", "authors": ["Sean McGregor", "Victor Lu", "Vassil Tashev", "Armstrong Foundjem", "Aishwarya Ramasethu", "Sadegh AlMahdi Kazemi Zarkouei", "Chris Knotz", "Kongtao Chen", "Alicia Parrish", "Anka Reuel", "Heather Frase"], "title": "Risk Management for Mitigating Benchmark Failure Modes: BenchRisk", "comment": "19 pages, 7 figures, to be published in the 39th Conference on Neural\n  Information Processing Systems (NeurIPS 2025)", "summary": "Large language model (LLM) benchmarks inform LLM use decisions (e.g., \"is\nthis LLM safe to deploy for my use case and context?\"). However, benchmarks may\nbe rendered unreliable by various failure modes that impact benchmark bias,\nvariance, coverage, or people's capacity to understand benchmark evidence.\nUsing the National Institute of Standards and Technology's risk management\nprocess as a foundation, this research iteratively analyzed 26 popular\nbenchmarks, identifying 57 potential failure modes and 196 corresponding\nmitigation strategies. The mitigations reduce failure likelihood and/or\nseverity, providing a frame for evaluating \"benchmark risk,\" which is scored to\nprovide a metaevaluation benchmark: BenchRisk. Higher scores indicate that\nbenchmark users are less likely to reach an incorrect or unsupported conclusion\nabout an LLM. All 26 scored benchmarks present significant risk within one or\nmore of the five scored dimensions (comprehensiveness, intelligibility,\nconsistency, correctness, and longevity), which points to important open\nresearch directions for the field of LLM benchmarking. The BenchRisk workflow\nallows for comparison between benchmarks; as an open-source tool, it also\nfacilitates the identification and sharing of risks and their mitigations.", "AI": {"tldr": "This paper introduces BenchRisk, a metaevaluation framework that identifies 57 potential failure modes in LLM benchmarks and provides 196 mitigation strategies to assess benchmark reliability and reduce the risk of incorrect conclusions about LLMs.", "motivation": "LLM benchmarks are crucial for deployment decisions but can be unreliable due to various failure modes affecting bias, variance, coverage, and interpretability, potentially leading to incorrect conclusions about LLM safety and capabilities.", "method": "Used NIST's risk management process to analyze 26 popular benchmarks, identifying failure modes and mitigation strategies. Developed BenchRisk scoring system across five dimensions: comprehensiveness, intelligibility, consistency, correctness, and longevity.", "result": "All 26 benchmarks showed significant risk in at least one dimension. BenchRisk provides a systematic way to compare benchmarks and identify areas needing improvement in LLM benchmarking practices.", "conclusion": "Current LLM benchmarks have substantial reliability issues across multiple dimensions. BenchRisk offers a practical framework for evaluating benchmark quality and highlights important research directions for improving LLM benchmarking standards."}}
{"id": "2510.21513", "categories": ["cs.SE", "cs.CL", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.21513", "abs": "https://arxiv.org/abs/2510.21513", "authors": ["Fernando Vallecillos Ruiz", "Max Hort", "Leon Moonen"], "title": "Wisdom and Delusion of LLM Ensembles for Code Generation and Repair", "comment": null, "summary": "Today's pursuit of a single Large Language Model (LMM) for all software\nengineering tasks is resource-intensive and overlooks the potential benefits of\ncomplementarity, where different models contribute unique strengths. However,\nthe degree to which coding LLMs complement each other and the best strategy for\nmaximizing an ensemble's potential are unclear, leaving practitioners without a\nclear path to move beyond single-model systems.\n  To address this gap, we empirically compare ten individual LLMs from five\nfamilies, and three ensembles of these LLMs across three software engineering\nbenchmarks covering code generation and program repair. We assess the\ncomplementarity between models and the performance gap between the best\nindividual model and the ensembles. Next, we evaluate various selection\nheuristics to identify correct solutions from an ensemble's candidate pool.\n  We find that the theoretical upperbound for an ensemble's performance can be\n83% above the best single model. Our results show that consensus-based\nstrategies for selecting solutions fall into a \"popularity trap,\" amplifying\ncommon but incorrect outputs. In contrast, a diversity-based strategy realizes\nup to 95% of this theoretical potential, and proves effective even in small\ntwo-model ensembles, enabling a cost-efficient way to enhance performance by\nleveraging multiple LLMs.", "AI": {"tldr": "Ensembles of coding LLMs can achieve 83% higher performance than single models, but consensus-based strategies fall into 'popularity traps' while diversity-based strategies realize up to 95% of this potential.", "motivation": "Current pursuit of single Large Language Models for software engineering is resource-intensive and overlooks complementarity benefits between different models, but the best ensemble strategies remain unclear.", "method": "Empirically compared 10 individual LLMs from 5 families and 3 ensembles across 3 software engineering benchmarks covering code generation and program repair, evaluating complementarity and solution selection heuristics.", "result": "Theoretical upperbound for ensemble performance is 83% above best single model. Diversity-based strategies achieve up to 95% of this potential, while consensus-based strategies amplify common but incorrect outputs.", "conclusion": "Diversity-based ensemble strategies enable cost-efficient performance enhancement by leveraging multiple LLMs, proving effective even in small two-model ensembles."}}
{"id": "2510.21516", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.21516", "abs": "https://arxiv.org/abs/2510.21516", "authors": ["Marvin B\u00f6cker", "Ralph Biggins", "Michael Schmeing"], "title": "Lights-Out: An Automated Ground Segment for unstaffed Satellite Operations", "comment": null, "summary": "We present our approach for a periodically unstaffed, fully automated ground\nsegment. The concept is in use for the first time on the German satellite\ncommunications mission Heinrich Hertz on behalf of the German Space Agency at\nDLR. Heinrich Hertz was launched in July 2023 and offers access to scientific\nand technical experiments to its users. The mission utilizes major automation\nconcepts for the satellite platform operations, allowing fully automated\noperations outside of office hours. The concept includes tracking, telemetry\nand commanding (TTC) of the satellite. Pre-planned and automatically executed\nschedules enable commanding without human interaction. The user mission\nschedule is planned separately from the main mission schedule and is\nautomatically de-conflicted. The automatic monitoring concept monitors the\nsystems of the satellite and all assets in the ground segment and triggers\nreactions in operator-configurable ways depending on the mission needs, for\nexample emergency notifications or automated execution of flight operation\nprocedures. Additionally, the concept also puts special emphasis on a\nself-service user portal that provides flexible access 24/7, even when the\ncontrol center is not staffed. The portal allows external users of the payload\nto schedule pre-defined experiments, monitor the live execution of the\nexperiment with browser-based displays and access ground station telemetry and\ndedicated RF test equipment during the time of their scheduled experiment.\nTasks can be planned long in advance as well as with a short reaction time\n(less than 1 minute), which allows, for example, the reconfiguration of the\npayload during a running experiment.", "AI": {"tldr": "A fully automated ground segment system for the Heinrich Hertz satellite mission that enables unstaffed operations through automated scheduling, monitoring, and user self-service capabilities.", "motivation": "To enable periodically unstaffed, fully automated satellite operations for the Heinrich Hertz mission, allowing flexible 24/7 access for users while reducing human intervention requirements.", "method": "Implemented major automation concepts including automated TTC (tracking, telemetry, commanding), pre-planned schedules, automatic monitoring with configurable reactions, and a self-service user portal for experiment scheduling and monitoring.", "result": "Successfully deployed for the Heinrich Hertz satellite launched in July 2023, enabling fully automated operations outside office hours with flexible user access and rapid reconfiguration capabilities (less than 1 minute reaction time).", "conclusion": "The automated ground segment concept successfully demonstrates that satellite operations can be conducted with minimal human intervention while providing flexible 24/7 access to users through self-service capabilities and rapid response mechanisms."}}
{"id": "2510.21591", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.21591", "abs": "https://arxiv.org/abs/2510.21591", "authors": ["Oleksandr Kosenkov", "Ehsan Zabardast", "Davide Fucci", "Daniel Mendez", "Michael Unterkalmsteiner"], "title": "Privacy by Design: Aligning GDPR and Software Engineering Specifications with a Requirements Engineering Approach", "comment": null, "summary": "Context: Consistent requirements and system specifications are essential for\nthe compliance of software systems towards the General Data Protection\nRegulation (GDPR). Both artefacts need to be grounded in the original text and\nconjointly assure the achievement of privacy by design (PbD). Objectives: There\nis little understanding of the perspectives of practitioners on specification\nobjectives and goals to address PbD. Existing approaches do not account for the\ncomplex intersection between problem and solution space expressed in GDPR. In\nthis study we explore the demand for conjoint requirements and system\nspecification for PbD and suggest an approach to address this demand. Methods:\nWe reviewed secondary and related primary studies and conducted interviews with\npractitioners to (1) investigate the state-of-practice and (2) understand the\nunderlying specification objectives and goals (e.g., traceability). We\ndeveloped and evaluated an approach for requirements and systems specification\nfor PbD, and evaluated it against the specification objectives. Results: The\nrelationship between problem and solution space, as expressed in GDPR, is\ninstrumental in supporting PbD. We demonstrate how our approach, based on the\nmodeling GDPR content with original legal concepts, contributes to\nspecification objectives of capturing legal knowledge, supporting specification\ntransparency, and traceability. Conclusion: GDPR demands need to be addressed\nthroughout different levels of abstraction in the engineering lifecycle to\nachieve PbD. Legal knowledge specified in the GDPR text should be captured in\nspecifications to address the demands of different stakeholders and ensure\ncompliance. While our results confirm the suitability of our approach to\naddress practical needs, we also revealed specific needs for the future\neffective operationalization of the approach.", "AI": {"tldr": "This paper presents an approach for conjoint requirements and system specification to address GDPR compliance through privacy by design, focusing on capturing legal knowledge and supporting traceability.", "motivation": "There is limited understanding of practitioners' perspectives on specification objectives for privacy by design, and existing approaches don't adequately address the complex intersection between problem and solution space in GDPR.", "method": "Conducted literature review and practitioner interviews to understand state-of-practice and specification objectives, then developed and evaluated an approach for requirements and systems specification for PbD.", "result": "The approach successfully captures legal knowledge from GDPR text, supports specification transparency and traceability, and addresses the relationship between problem and solution space essential for PbD.", "conclusion": "GDPR demands must be addressed throughout engineering lifecycle levels of abstraction, and legal knowledge from GDPR text should be captured in specifications to ensure compliance and meet stakeholder needs."}}
